<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Dessiner une sphere · OpenGL[&quot;noël&quot;]</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Le but de ce premier exercice est de dessiner une sphere. Commencez par repartir du template de base (SDLtemplate.cpp) afin d&#x27;avoir un code propre. Voici chacune des étapes à réaliser:"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Dessiner une sphere · OpenGL[&quot;noël&quot;]"/><meta property="og:type" content="website"/><meta property="og:url" content="https://celeborn2bealive.github.io/openglnoel/"/><meta property="og:description" content="Le but de ce premier exercice est de dessiner une sphere. Commencez par repartir du template de base (SDLtemplate.cpp) afin d&#x27;avoir un code propre. Voici chacune des étapes à réaliser:"/><meta property="og:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><link rel="shortcut icon" href="/openglnoel/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/atom.xml" title="OpenGL[&quot;noël&quot;] Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/feed.xml" title="OpenGL[&quot;noël&quot;] Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/openglnoel/js/code-block-buttons.js"></script><script type="text/javascript" src="/openglnoel/js/disqus.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/openglnoel/js/scrollSpy.js"></script><link rel="stylesheet" href="/openglnoel/css/main.css"/><script src="/openglnoel/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/openglnoel/"><img class="logo" src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]"/><h2 class="headerTitleWithLogo">OpenGL[&quot;noël&quot;]</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction" target="_self">Intro et SDK</a></li><li class=""><a href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base" target="_self">Bronze</a></li><li class="siteNavGroupActive"><a href="/openglnoel/docs/silver-01-3d-theorie-01-introduction" target="_self">Silver</a></li><li class=""><a href="/openglnoel/docs/gold-01-intro-sdk-01-introduction" target="_self">Gold</a></li><li class=""><a href="/openglnoel/docs/gltf-viewer-01-intro" target="_self">glTF Viewer Tutorial</a></li><li class=""><a href="/openglnoel/blog/" target="_self">Blog</a></li><li class=""><a href="http://docs.gl" target="_self">OpenGL Documentation</a></li><li class=""><a href="https://www.khronos.org/opengl/wiki/" target="_self">OpenGL Wiki</a></li><li class=""><a href="https://github.com/celeborn2bealive/openglnoel" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>3D - La pratique</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">3D - La théorie</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-01-3d-theorie-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-01-3d-theorie-02-normal-matrix">La Normal Matrix</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-01-3d-theorie-03-3d-vertex-shader">Un exemple de Vertex Shader pour la 3D</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-01-3d-theorie-04-glm">La bibliothèque glm</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">3D - La pratique</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-02-classe-sphere-cone">Les classes Sphere et Cone</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-03-dessiner-sphere">Dessiner une sphere</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-04-dessiner-lune">Dessiner une lune</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-05-dessiner-terre">Dessiner la terre</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-06-multi-texturing">Multi-texturing</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-07-plusieurs-shaders">Utiliser plusieurs shaders</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Gestion de la caméra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-03-camera-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-03-camera-02-trackball-camera">Trackball Camera</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-03-camera-03-freefly-camera">Freefly Camera</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Put the lights on !</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-04-lighting-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-04-lighting-02-directional-light">Directional Light</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-04-lighting-03-point-light">Point Light</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-04-lighting-04-aller-plus-loin">Aller plus loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Projet(s)</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-05-projets-01-iminecraft">Projet: IM(A)ineCraft</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Dessiner une sphere</h1></header><article><div><span><p>Le but de ce premier exercice est de dessiner une sphere. Commencez par repartir du template de base (SDLtemplate.cpp) afin d'avoir un code propre. Voici chacune des étapes à réaliser:</p>
<p><span class="badge todo"></span> Créez une nouvelle variable de type <strong>Sphere</strong> à l'intialisation du programme (prenez comme rayon 1).</p>
<p><span class="badge todo"></span> En utilisant la structure <strong>ShapeVertex</strong> et les méthode de l'objet sphere créé, construisez un VBO et un VAO contenant les sommets de la sphère.</p>
<p><span class="badge todo"></span> Créez deux nouveau shaders <strong>3D.vs.glsl</strong> et <strong>normals.fs.glsl</strong>. Le vertex shader doit prendre en entrée un sommet (3 attributs: position, normale, texCoords), trois matrices uniformes (4x4) uMVPMatrix, uMVMatrix et uNormalMatrix et calculer en sortie les position et normale en view coordinates, les coordonnées de texture sans les changer. Il doit également calculer la position projeté dans <strong>gl_Position</strong>. Essayez de coder ce shader from scratch (sans regarder l'exemple donné au cours du TP précédent). Le fragment shader doit prendre en entrée les variables de sortie du vertex shader et calculer en sortie la couleur du fragment. Comme couleur, utilisez la normale récupérée en entrée (normalisez la en utilisant la fonction <strong>normalize</strong>). Afficher la normale comme une couleur est une technique assez utilisée pour le debug.</p>
<p><span class="badge todo"></span> Dans le code C++, chargez vos shaders afin d'obtenir un programme. Appelez la méthode <strong>use()</strong> afin de l'utiliser.</p>
<p><span class="badge todo"></span> Toujours à l'initialisation, récupérez les <strong>location</strong> des variables uniformes (<strong>glGetUniformLocation</strong>) de vos shaders.</p>
<p><span class="badge todo"></span> Ajoutez la ligne <strong>glEnable(GL_DEPTH_TEST);</strong> qui permet d'activer le test de profondeur du GPU. Sans cet appel de fonction, certains triangles non visible viendraient recouvrir des triangles situés devant.</p>
<p><span class="badge todo"></span> Créez 3 variables de type <strong>glm::mat4</strong>: ProjMatrix, MVMatrix et NormalMatrix.</p>
<p><span class="badge todo"></span> Calculez la matrice ProjMatrix en utilisant la fonction <strong>glm::perspective</strong>. Le premier paramètre est l'angle vertical de vue (mettez glm::radians(70.f)), le second est le ratio de la largeur de la fenêtre par sa hauteur (largeur / hauteur), les 2 derniers sont le near et le far qui définissent une range de vision sur l'axe de la profondeur: mettez 0.1f et 100.f.</p>
<p><span class="badge todo"></span> Utilisez la fonction <strong>glm::translate</strong> pour calculer la matrice <strong>MVMatrix</strong>. La convention OpenGL est de regarder du coté négatif de l'axe Z dans l'espace View. Faites donc en sorte que la sphère soit dessinée en \((0,0,−5)\) via la translation qu'on lui applique.</p>
<p>Note: le fait de choisir near=0.1f et far=100.f pour la matrice de projection signifie que l'on ne verra que les objets situés entre -0.1f et -100.f sur l'axe Z (au risque de me répéter: car on voit du coté négatif des Z par défaut en OpenGL).</p>
<p><span class="badge todo"></span> Calculez la matrice NormalMatrix en utilisant les fonction <strong>glm::inverse</strong> et <strong>glm::transpose</strong> sur la matrice MVMatrix.</p>
<p>Rappel: \(NormalMatrix=(MV^{−1})^T\), c'est à dire: <strong>glm::mat4 NormalMatrix = glm::transpose(glm::inverse(MVMatrix))</strong></p>
<p><span class="badge todo"></span> Dans la boucle de rendu à présent: remplacez la ligne <strong>glClear(GL_COLOR_BUFFER_BIT);</strong> par <strong>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</strong>. Cela permet de nettoyer le depth buffer à chaque tour de boucle.</p>
<p><span class="badge todo"></span> A la suite, envoyez les matrices au GPU en utilisant la fonction <strong>glUniformMatrix4fv</strong>. Pour la matrice MVP, il faut envoyer ProjMatrix * MVMatrix. (N'oubliez pas d'utiliser la fonction glm::value_ptr pour récupérer le pointeur sur les données de chacune des matrices).</p>
<p><span class="badge todo"></span> Enfin, bindez le VAO et utilisez <strong>glDrawArrays</strong> pour dessiner la sphère (on utilise ici glDrawArrays car le code de la sphere ne créé par de buffer d'index). Il faut dessiner des triangles et utiliser la méthode <strong>getVertexCount</strong> sur la sphère pour obtenir le nombre de sommets à dessiner. N'oubliez pas de débinder le VAO ensuite.</p>
<p><span class="badge todo"></span> Testez, et bon courage pour le déboguage de votre premier (ou pas ?) programme 3D :D Voici le résultat attendu:</p>
<p><img src="/openglnoel/img/sphere_normals.png" alt="Sphere normals"></p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/openglnoel/docs/silver-02-3d-pratique-02-classe-sphere-cone"><span class="arrow-prev">← </span><span>Les classes Sphere et Cone</span></a><a class="docs-next button" href="/openglnoel/docs/silver-02-3d-pratique-04-dessiner-lune"><span>Dessiner une lune</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/openglnoel/" class="nav-home"><img src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]" width="66" height="58"/></a><div><h5>About Me</h5><a href="http://laurentnoel.fr">Personal website</a><a href="https://github.com/Celeborn2BeAlive/">Github</a></div><div><h5>About This Website</h5><a href="/openglnoel/blog">Blog</a><a class="github-button" href="https://github.com/celeborn2bealive/openglnoel" data-icon="octicon-star" data-count-href="/celeborn2bealive/openglnoel/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">openglnoel</a><a href="https://docusaurus.io/">Powered by Docusaurus</a></div><div><h5>About OpenGL</h5><a href="docs.gl">Documentation (docs.gl)</a><a href="https://www.khronos.org/opengl/wiki/">Wiki</a></div></section><section class="copyright">Copyright © 2020 Laurent NOEL</section></footer></div></body></html>