<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Dessiner une lune · OpenGL[&quot;noël&quot;]</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;span class=&quot;badge warning&quot;&gt;&lt;/span&gt; Afin de réaliser cet exercice, vous aurez besoin de récuperer le temps écoulé. Pour cela, j&#x27;ai ajouté la méthode **getTime()** à la classe SDLWindowManager. Téléchargez les fichiers SDLWindowManager.cpp et SDLWindowManager.hpp. Dans votre template de code (repertoire **glimac**), remplacez les anciennes versions par les nouvelles."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Dessiner une lune · OpenGL[&quot;noël&quot;]"/><meta property="og:type" content="website"/><meta property="og:url" content="https://celeborn2bealive.github.io/openglnoel/"/><meta property="og:description" content="&lt;span class=&quot;badge warning&quot;&gt;&lt;/span&gt; Afin de réaliser cet exercice, vous aurez besoin de récuperer le temps écoulé. Pour cela, j&#x27;ai ajouté la méthode **getTime()** à la classe SDLWindowManager. Téléchargez les fichiers SDLWindowManager.cpp et SDLWindowManager.hpp. Dans votre template de code (repertoire **glimac**), remplacez les anciennes versions par les nouvelles."/><meta property="og:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><link rel="shortcut icon" href="/openglnoel/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/atom.xml" title="OpenGL[&quot;noël&quot;] Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/feed.xml" title="OpenGL[&quot;noël&quot;] Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/openglnoel/js/code-block-buttons.js"></script><script type="text/javascript" src="/openglnoel/js/disqus.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/openglnoel/js/scrollSpy.js"></script><link rel="stylesheet" href="/openglnoel/css/main.css"/><script src="/openglnoel/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/openglnoel/"><img class="logo" src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]"/><h2 class="headerTitleWithLogo">OpenGL[&quot;noël&quot;]</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction" target="_self">Introduction et SDK</a></li><li class=""><a href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base" target="_self">Bronze</a></li><li class="siteNavGroupActive"><a href="/openglnoel/docs/silver-01-3d-theorie-01-introduction" target="_self">Silver</a></li><li class=""><a href="/openglnoel/docs/gold-01-intro-sdk-01-introduction" target="_self">Gold</a></li><li class=""><a href="/openglnoel/blog/" target="_self">Blog</a></li><li class=""><a href="http://docs.gl" target="_self">OpenGL Documentation</a></li><li class=""><a href="https://www.khronos.org/opengl/wiki/" target="_self">OpenGL Wiki</a></li><li class=""><a href="https://github.com/celeborn2bealive/openglnoel" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>3D - La pratique</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">3D - La théorie</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-01-3d-theorie-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-01-3d-theorie-02-normal-matrix">La Normal Matrix</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-01-3d-theorie-03-3d-vertex-shader">Un exemple de Vertex Shader pour la 3D</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-01-3d-theorie-04-glm">La bibliothèque glm</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">3D - La pratique</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-02-classe-sphere-cone">Les classes Sphere et Cone</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-03-dessiner-sphere">Dessiner une sphere</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-04-dessiner-lune">Dessiner une lune</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-05-dessiner-terre">Dessiner la terre</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-06-multi-texturing">Multi-texturing</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-07-plusieurs-shaders">Utiliser plusieurs shaders</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Gestion de la caméra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-03-camera-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-03-camera-02-trackball-camera">Trackball Camera</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-03-camera-03-freefly-camera">Freefly Camera</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Put the lights on !</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-04-lighting-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-04-lighting-02-directional-light">Directional Light</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-04-lighting-03-point-light">Point Light</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-04-lighting-04-aller-plus-loin">Aller plus loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Projet(s)</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-05-projets-01-iminecraft">Projet: IM(A)ineCraft</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Dessiner une lune</h1></header><article><div><span><p><span class="badge warning"></span> Afin de réaliser cet exercice, vous aurez besoin de récuperer le temps écoulé. Pour cela, j'ai ajouté la méthode <strong>getTime()</strong> à la classe SDLWindowManager. Téléchargez les fichiers SDLWindowManager.cpp et SDLWindowManager.hpp. Dans votre template de code (repertoire <strong>glimac</strong>), remplacez les anciennes versions par les nouvelles.</p>
<p>L'objectif à présent est de dessiner une lune tournant autour de notre sphère.</p>
<p>Dans notre cas une lune n'est rien de plus qu'une deuxième sphère, plus petite, placée relativement par rapport à la première.</p>
<p>Il va donc falloir dessiner deux sphère en changeant les transformations courantes avant chaque dessin. En particulier la matrice de transformation de la lune doit être en partie constituée de la transformation associée à la planète (puisque la lune tourne autour de la planète).</p>
<p>Pour dessiner une deuxieme sphere, il ne faut surtout pas créer un deuxieme couple VBO/VAO contenant les sommets d'une sphere plus petite. A la place on appelle juste deux fois la fonction <strong>glDrawArrays</strong> en modifiant les transformations avant chaque appel (on aura en particuler une transformation de type scale pour réduire la taille de la sphere).</p>
<p>Il est possible de combiner les transformations avec GLM en utilisant le premier paramètre de chaque fonction de transformation. Voici un exemple de code commenté:</p>
<pre><code class="hljs css language-cpp">glm::mat4 MVMatrix = glm::translate(glm::mat4(<span class="hljs-number">1</span>), glm::vec3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-5</span>)); <span class="hljs-comment">// Translation</span>
MVMatrix = glm::rotate(MVMatrix, windowManager.getTime(), glm::vec3(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)); <span class="hljs-comment">// Translation * Rotation</span>
MVMatrix = glm::translate(MVMatrix, glm::vec3(<span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)); <span class="hljs-comment">// Translation * Rotation * Translation</span>
MVMatrix = glm::scale(MVMatrix, glm::vec3(<span class="hljs-number">0.2</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.2</span>)); <span class="hljs-comment">// Translation * Rotation * Translation * Scale</span>
</code></pre>
<p>La matrice passée en paramètre est multiplié à droite par la transformation demandée puis le résultat est renvoyé. Cela permet de recréer un concept de pile de transformation.</p>
<p><span class="badge todo"></span> En utilisant des combinaisons de transformations, dessinez une lune. Dans un premier temps dessinez là immobile à gauche de la première sphère. Ensuite faites la tourner autour en utilisant comme angle de rotation le temps renvoyé par la méthode <strong>getTime()</strong> du windowManager.</p>
<p><img src="/openglnoel/img/lune.png" alt="Lune normals"></p>
<p><span class="badge todo"></span> De la même manière, en utilisant une boucle, dessinez 32 lunes tournant autour de la planète, placées pseudo-aléatoirement. Pour cela il suffit de tirer l'axe de rotation aléatoirement. Avant la boucle rendu, utilisez la fonction <strong>glm::sphericalRand</strong> (<a href="https://glm.g-truc.net/0.9.9/api/a00717.html#ga22f90fcaccdf001c516ca90f6428e138">documentation</a>) pour tirer 32 axes de rotation que vous placerez dans un <strong>std::vector</strong> de <strong>glm::vec3</strong>. Utilisez ensuite ce vector dans la boucle de rendu pour dessiner toutes vos lunes. (il faut inclure le header <strong>glm/gtc/random.hpp</strong> pour utiliser <strong>glm::sphericalRand</strong>; rajoutez cet include dans le fichier <strong>glimac/include/glimac/glm.hpp</strong>). Testez le programme: il y a normalement un problème. Identifiez sa cause et corriger pour avec un résultat a peu près cohérent.</p>
<p><img src="/openglnoel/img/lunes.png" alt="Lunes normals"></p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/openglnoel/docs/silver-02-3d-pratique-03-dessiner-sphere"><span class="arrow-prev">← </span><span>Dessiner une sphere</span></a><a class="docs-next button" href="/openglnoel/docs/silver-02-3d-pratique-05-dessiner-terre"><span>Dessiner la terre</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/openglnoel/" class="nav-home"><img src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]" width="66" height="58"/></a><div><h5>About Me</h5><a href="http://laurentnoel.fr">Personal website</a><a href="https://github.com/Celeborn2BeAlive/">Github</a></div><div><h5>About This Website</h5><a href="/openglnoel/blog">Blog</a><a class="github-button" href="https://github.com/celeborn2bealive/openglnoel" data-icon="octicon-star" data-count-href="/celeborn2bealive/openglnoel/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">openglnoel</a><a href="https://docusaurus.io/">Powered by Docusaurus</a></div><div><h5>About OpenGL</h5><a href="docs.gl">Documentation (docs.gl)</a><a href="https://www.khronos.org/opengl/wiki/">Wiki</a></div></section><section class="copyright">Copyright © 2019 Laurent NOEL</section></footer></div></body></html>