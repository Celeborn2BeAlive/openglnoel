<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Physically based materials · OpenGL[&quot;noël&quot;]</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## Introduction to glTF material model"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Physically based materials · OpenGL[&quot;noël&quot;]"/><meta property="og:type" content="website"/><meta property="og:url" content="https://celeborn2bealive.github.io/openglnoel/"/><meta property="og:description" content="## Introduction to glTF material model"/><meta property="og:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><link rel="shortcut icon" href="/openglnoel/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/atom.xml" title="OpenGL[&quot;noël&quot;] Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/feed.xml" title="OpenGL[&quot;noël&quot;] Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/openglnoel/js/code-block-buttons.js"></script><script type="text/javascript" src="/openglnoel/js/disqus.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/openglnoel/js/scrollSpy.js"></script><link rel="stylesheet" href="/openglnoel/css/main.css"/><script src="/openglnoel/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/openglnoel/"><img class="logo" src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]"/><h2 class="headerTitleWithLogo">OpenGL[&quot;noël&quot;]</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/openglnoel/docs/gltf-viewer-01-intro-01-intro" target="_self">glTF Viewer Tutorial</a></li><li class=""><a href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction" target="_self">Intro et SDK</a></li><li class=""><a href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base" target="_self">Bronze</a></li><li class=""><a href="/openglnoel/docs/silver-01-3d-theorie-01-introduction" target="_self">Silver</a></li><li class=""><a href="/openglnoel/docs/gold-01-intro-sdk-01-introduction" target="_self">Gold</a></li><li class=""><a href="/openglnoel/blog/" target="_self">Blog</a></li><li class=""><a href="http://docs.gl" target="_self">OpenGL Documentation</a></li><li class=""><a href="https://www.khronos.org/opengl/wiki/" target="_self">OpenGL Wiki</a></li><li class=""><a href="https://github.com/celeborn2bealive/openglnoel" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Physically Based Materials</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction and SDK</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-01-intro-01-intro">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-01-intro-02-sdk">Software Development Kit</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-01-intro-03-devenv">Development Environment</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Loading and drawing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-02-gltf-01-roadmap">Introduction and roadmap</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-02-gltf-02-initialization">Data initialization</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-02-gltf-03-drawing">Drawing the scene</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Controlling the Camera</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-03-camera-control">Camera Control</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Directional Lighting</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-04-directional-lighting">Directional Lighting</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Physically Based Materials</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/openglnoel/docs/gltf-viewer-05-physically-based-materials">Physically based materials</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Shadow Mapping</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-06-shadow-mapping">WIP - Shadow mapping</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Deferred Rendering</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-07-deferred-rendering">WIP - Deferred rendering</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Post Processing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-08-post-processing">WIP - Post processing</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Physically based materials</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="introduction-to-gltf-material-model"></a><a href="#introduction-to-gltf-material-model" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Introduction to glTF material model</h2>
<p>As explained in <a href="/openglnoel/docs/gltf-viewer-04-directional-lighting#mathematical-model">the previous section on lighting</a>, the material at a specific point is described by a bidirectional reflectance distribution function (BRDF). We used a simple diffuse white model, but in the general case the BRDF is different for each point.</p>
<p>It is expressed from material properties such as a diffuse color, or a glossiness factor, and these properties are generally stored in textures when they are not constant on the whole mesh.</p>
<p>The glTF documentation gives us all we need to understand the material model used by the format:</p>
<ul>
<li><a href="https://raw.githubusercontent.com/KhronosGroup/glTF/master/specification/2.0/figures/gltfOverview-2.0.0b.png">The quick reference card</a> has a &quot;materials&quot; section describing how a material is represented, and a &quot;texture, images, samplers&quot; section describing how textures are represented. We also see in the &quot;meshes&quot; section that each mesh primitive can have a <code>material</code> properties containing the index of the material for this primitive.</li>
<li><a href="https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture-data">The texture data section</a> of the specification explain in details how textures, images and samplers are stored in a glTF file.</li>
<li><a href="https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#materials">The materials section</a> explain in details how a material is described, how to combine factors with textures, etc.</li>
<li><a href="https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#appendix-b-brdf-implementation">The BRDF Implementation appendix</a> gives equations to implement the BRDF \( f_r(\omega_i, \omega_o) \) at a specific point.</li>
<li>Finally, <a href="https://github.com/KhronosGroup/glTF-Sample-Viewer/">the source code for a webGL implementation</a> is available. The shaders of this repository expose an implementation of the BRDF, however it can be hard to read for someone not familiar with the code.</li>
</ul>
<p>In this tutorial I only describe concepts required for our (incomplete) implementation of the material model. For more details you need to read the specification.</p>
<p>Here is our roadmap to implement the model:</p>
<ul>
<li>Texture objects creation</li>
<li>Creation of the shader pbr_directional_light.fs.glsl with handling of diffuse component (GLSL side)</li>
<li>Send uniform data to OpenGL for handling diffuse component (C++ side)</li>
<li>Test that everything work at this point</li>
<li>Finalization of the shader to handle glossy component (GLSL side)</li>
<li>Send remaining uniform data to OpenGL for the glossy component (C++ side)</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="texture-objects-creation"></a><a href="#texture-objects-creation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Texture objects creation</h2>
<h3><a class="anchor" aria-hidden="true" id="opengl-textures"></a><a href="#opengl-textures" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>OpenGL textures</h3>
<p>In OpenGL, a texture is represented by a texture object, composed by an image and sampling parameters. Like other OpenGL objects, a texture needs to be generated and bound in order to be able to act on it (fill it with image, set sampling parameters).
The following code shows how to create a texture object and fill it with a 1920x1080 image of RGB pixels:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-title">pixels</span><span class="hljs-params">(<span class="hljs-number">1920</span> * <span class="hljs-number">1080</span> * <span class="hljs-number">3</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// "Useless" black image of RGB (3 components) float values</span>

GLuint texObject;
<span class="hljs-comment">// Generate the texture object</span>
glGenTextures(<span class="hljs-number">1</span>, &amp;texObject);

glBindTexture(GL_TEXTURE_2D, texObject); <span class="hljs-comment">// Bind to target GL_TEXTURE_2D</span>
glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGBA, <span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, <span class="hljs-number">0</span>,
        GL_RGB, GL_FLOAT, pixels.data()); <span class="hljs-comment">// Set image data</span>
<span class="hljs-comment">// Set sampling parameters</span>
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
<span class="hljs-comment">// Set wrapping parameters</span>
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_REPEAT);

glBindTexture(GL_TEXTURE_2D, <span class="hljs-number">0</span>);
</code></pre>
<p>In the call <code>glTexImage2D</code> we specify two formats:</p>
<ul>
<li>The first one (GL_RGBA in this call) is the format of the texture on the GPU. Here we put GL_RGBA but we only send RGB values: OpenGL will automatically fill the last component with 0 for each pixel. This argument is quite free, we can choose what we want that fills our needs.</li>
<li>The second format (GL_RGB and GL_FLOAT) specifies what format we give to OpenGL. Here our vector <code>pixels</code> is filled with floats, so we put GL_FLOAT, and we have 3 components per pixel, so GL_RGB. If our vector was filled with unsigned chars instead of floats, we would put GL_UNSIGNED_BYTE instead of GL_FLOAT. If we had only one component per pixel in our vector, we would put GL_RED instead of GL_RGB. So these two arguments are strongly dependent on our data.</li>
</ul>
<p>So we know how to create a texture object, let's see how to do it for a texture from a glTF file.</p>
<h3><a class="anchor" aria-hidden="true" id="gltf-textures"></a><a href="#gltf-textures" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>glTF textures</h3>
<p>The glTF contains a <code>textures</code> array describing all textures that can be referenced by materials.</p>
<p>A texture has the following shape:</p>
<pre><code class="hljs css language-json">{
    <span class="hljs-attr">"textures"</span>: [
        {
            <span class="hljs-attr">"sampler"</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">"source"</span>: <span class="hljs-number">2</span>
        }
    ]
}
</code></pre>
<p>The <code>source</code> attribute is the index of an image, the <code>sampler</code> attribute is the index of a sampler.</p>
<h4><a class="anchor" aria-hidden="true" id="images"></a><a href="#images" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Images</h4>
<p>Images are stored in an <code>images</code> array, with the following shape:</p>
<pre><code class="hljs css language-json">{
    <span class="hljs-attr">"images"</span>: [
        {
            <span class="hljs-attr">"uri"</span>: <span class="hljs-string">"duckCM.png"</span>
        },
        {
            <span class="hljs-attr">"bufferView"</span>: <span class="hljs-number">14</span>,
            <span class="hljs-attr">"mimeType"</span>: <span class="hljs-string">"image/jpeg"</span> 
        }
    ]
}
</code></pre>
<p>Here we have two images in the array: one is a file, the second is a jpeg store in a buffer of the glTF file.</p>
<p>If we were doing everything from scratch, we would need to manually load images from disk or buffers. Fortunately, the tinygltf library does that for us so we can directly access the data and send it to the GPU in texture objects. This code example shows how to fill a texture object using an image from tinygltf:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-comment">// Assume a texture object has been created and bound to GL_TEXTURE_2D</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;texture = model.textures[i]; <span class="hljs-comment">// get i-th texture</span>
assert(texture.source &gt;= <span class="hljs-number">0</span>); <span class="hljs-comment">// ensure a source image is present</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;image = model.images[texture.source]; <span class="hljs-comment">// get the image</span>

<span class="hljs-comment">// fill the texture object with the data from the image</span>
glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGBA, image.width, image.height, <span class="hljs-number">0</span>,
        GL_RGBA, image.pixel_type, image.image.data());
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="samplers"></a><a href="#samplers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Samplers</h4>
<p>A sampler describes how a texture must be read by OpenGL: what filters to use, what wrapping mode to use. Similar to all glTF objects, they are stored in a <code>samplers</code> array, with the following shape:</p>
<pre><code class="hljs css language-json">{
    <span class="hljs-attr">"samplers"</span>: [
        {
            <span class="hljs-attr">"magFilter"</span>: <span class="hljs-number">9729</span>,
            <span class="hljs-attr">"minFilter"</span>: <span class="hljs-number">9987</span>,
            <span class="hljs-attr">"wrapS"</span>: <span class="hljs-number">10497</span>,
            <span class="hljs-attr">"wrapT"</span>: <span class="hljs-number">10497</span>
        }
    ]
}
</code></pre>
<p>The constant number here correspond to OpenGL constants such as <code>GL_LINEAR</code>, <code>NEAREST_MIPMAP_NEAREST</code>, <code>GL_REPEAT</code>, etc. It means we can directly use the values to setup texture sampling with the OpenGL API:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-comment">// Assume a texture object has been created and bound to GL_TEXTURE_2D</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;texture = model.textures[i]; <span class="hljs-comment">// get i-th texture</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;sampler =
        texture.sampler &gt;= <span class="hljs-number">0</span> ? model.samplers[texture.sampler] : defaultSampler;
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
   sampler.minFilter != <span class="hljs-number">-1</span> ? sampler.minFilter : GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
   sampler.magFilter != <span class="hljs-number">-1</span> ? sampler.magFilter : GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, sampler.wrapS);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, sampler.wrapT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, sampler.wrapR);
</code></pre>
<p>When a filter is undefined, we use <code>GL_LINEAR</code> as default filter. And when no sampler is defined for the texture (in that case we have <code>texture.sampler == -1</code>), we use a default sampler defined as:</p>
<pre><code class="hljs css language-cpp">tinygltf::Sampler defaultSampler;
defaultSampler.minFilter = GL_LINEAR;
defaultSampler.magFilter = GL_LINEAR;
defaultSampler.wrapS = GL_REPEAT;
defaultSampler.wrapT = GL_REPEAT;
defaultSampler.wrapR = GL_REPEAT;
</code></pre>
<p>Some samplers use mipmapping for their minification filter. In that case, the specification tells us we need to have mipmaps computed for the texture. OpenGL can compute them for us:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-keyword">if</span> (sampler.minFilter == GL_NEAREST_MIPMAP_NEAREST ||
   sampler.minFilter == GL_NEAREST_MIPMAP_LINEAR ||
   sampler.minFilter == GL_LINEAR_MIPMAP_NEAREST ||
   sampler.minFilter == GL_LINEAR_MIPMAP_LINEAR) {
   glGenerateMipmap(GL_TEXTURE_2D);
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="the-practice"></a><a href="#the-practice" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The practice</h3>
<p>To manipulate our textures from the input glTF file, we need a few things:</p>
<p><span class="todo badge"></span> In the <code>ViewerApplication</code> class, implement a method with prototype: <code>std::vector&lt;GLuint&gt; ViewerApplication::createTextureObjects(const tinygltf::Model &amp;model) const;</code>. This method should compute a vector of texture objects. Each texture object is filled with an image and sampling parameters from the corresponding texture of the glTF file. This step basically consists of picking code examples from this section and putting them in a loop in order to initialize each texture object.</p>
<p><span class="todo badge"></span> Add a call to your method in the <code>run()</code> method, in the initialization step, before the drawing loop (for example, before the call to <code>createBufferObjects</code>). Store the result in a vector <code>textureObjects</code>.</p>
<p><span class="todo badge"></span> After the call, create a single texture object with a variable <code>GLuint whiteTexture</code> to reference it. Fill it with a single white RGBA pixel (<code>float white[] = {1, 1, 1, 1};</code>) and set sampling parameters to <code>GL_LINEAR</code> and wrapping parameters to <code>GL_REPEAT</code>. This texture will be used for the base color of objects that have no materials (as specified in the glTF specification, if no base color texture is present, we should use white).</p>
<h2><a class="anchor" aria-hidden="true" id="diffuse-component-in-glsl"></a><a href="#diffuse-component-in-glsl" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Diffuse component in GLSL</h2>
<h3><a class="anchor" aria-hidden="true" id="reading-textures-in-glsl"></a><a href="#reading-textures-in-glsl" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reading textures in GLSL</h3>
<p>In GLSL, it is quite easy to declare and use a texture. Textures are declared as samplers in uniform variables, and we read them with the texture function.</p>
<p>For example a simple shader using texture could be like that:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-meta">#version 330</span>

<span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> vTexCoords;

<span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> uTextureSky;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> uTextureCloud;

<span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fColor;

<span class="hljs-type">void</span> main()
{
   <span class="hljs-type">vec4</span> skyColor = <span class="hljs-built_in">texture</span>(uTextureSky, vTexCoords);
   <span class="hljs-type">vec4</span> cloudColor = <span class="hljs-built_in">texture</span>(uTextureCloud, vTexCoords);

   fColor = skyColor.rgb + cloudColor.rgb; <span class="hljs-comment">// we don't use the alpha component in this simple shader</span>
}
</code></pre>
<p>Here we have two texture and we add the colors we read from them.</p>
<p>However, a subtility might occur when we manipulate material textures. This is the case for the base color texture of glTF (but not the metal roughness texture that we'll use later).</p>
<p>The base color texture has RGB values encoded in sRGB color space. It basically means that these values are not real lighting intensities as you would compute them in a render engine (or lighting simulation), but have been modified to be displayed on a computer screen. This transform is necessary if we want to be able to see the same image on a computer screen as we would see in reality, on a printing for example.</p>
<p>You can find more information <a href="https://en.wikipedia.org/wiki/SRGB">on wikipedia</a> about this transform and why it exists. Another good resource about color is <a href="https://hg2dc.com/">The Hitchiker's Guide to Digital Colour</a>.</p>
<p>What does it mean for us ? It means we have to invert the sRGB transform to correctly read the base color texture before doing any lighting computation. Now similarly, to correctly display a color obtained from a lighting computation on a computer screen, we need to apply a transform that gives colors in sRGB space. This is commonly referred as gamma correction (or more generally &quot;tone mapping&quot;). Here is an example of a simple diffuse shader that uses a base color texture to get the diffuse color:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-meta">#version 330</span>

<span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> vViewSpaceNormal;
<span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> vTexCoords;

<span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> uLightDirection;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> uLightIntensity;

<span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> uBaseColorTexture;

<span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fColor;

<span class="hljs-comment">// Constants</span>
<span class="hljs-keyword">const</span> <span class="hljs-type">float</span> GAMMA = <span class="hljs-number">2.2</span>;
<span class="hljs-keyword">const</span> <span class="hljs-type">float</span> INV_GAMMA = <span class="hljs-number">1.</span> / GAMMA;
<span class="hljs-keyword">const</span> <span class="hljs-type">float</span> M_PI = <span class="hljs-number">3.141592653589793</span>;
<span class="hljs-keyword">const</span> <span class="hljs-type">float</span> M_1_PI = <span class="hljs-number">1.0</span> / M_PI;

<span class="hljs-comment">// We need some simple tone mapping functions</span>
<span class="hljs-comment">// Basic gamma = 2.2 implementation</span>
<span class="hljs-comment">// Stolen here: https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/master/src/shaders/tonemapping.glsl</span>

<span class="hljs-comment">// linear to sRGB approximation</span>
<span class="hljs-comment">// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html</span>
<span class="hljs-type">vec3</span> LINEARtoSRGB(<span class="hljs-type">vec3</span> color)
{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(color, <span class="hljs-type">vec3</span>(INV_GAMMA));
}

<span class="hljs-comment">// sRGB to linear approximation</span>
<span class="hljs-comment">// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html</span>
<span class="hljs-type">vec4</span> SRGBtoLINEAR(<span class="hljs-type">vec4</span> srgbIn)
{
  <span class="hljs-keyword">return</span> <span class="hljs-type">vec4</span>(<span class="hljs-built_in">pow</span>(srgbIn.xyz, <span class="hljs-type">vec3</span>(GAMMA)), srgbIn.w);
}

<span class="hljs-type">void</span> main()
{
  <span class="hljs-type">vec3</span> N = <span class="hljs-built_in">normalize</span>(vViewSpaceNormal);
  <span class="hljs-type">vec3</span> L = uLightDirection;

  <span class="hljs-type">vec4</span> baseColorFromTexture = SRGBtoLINEAR(<span class="hljs-built_in">texture</span>(uBaseColorTexture, vTexCoords));
  <span class="hljs-type">float</span> NdotL = <span class="hljs-built_in">clamp</span>(<span class="hljs-built_in">dot</span>(N, L), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
  <span class="hljs-type">vec3</span> diffuse = baseColorFromTexture.rgb * M_1_PI;

  fColor = LINEARtoSRGB(diffuse * uLightIntensity * NdotL);
}
</code></pre>
<p>You should see some similarities with the &quot;white diffuse&quot; shader of the previous section. The main differences are:</p>
<ul>
<li>instead of white we use a color from the texture</li>
<li>we apply tone mapping functions to compute lighting in a linear RGB color space, but to output values in sRGB color space (for the screen display).</li>
</ul>
<p><span class="todo badge"></span> Copy this shader in a file called <code>pbr_directional_light.fs.glsl</code> in the shaders folder.</p>
<p><span class="todo badge"></span> In <code>ViewerApplication.hpp</code>, replace the default fragment shader with this new shader.</p>
<p><span class="todo badge"></span> Try your application, you should have a black image at this point.</p>
<h3><a class="anchor" aria-hidden="true" id="binding-textures-for-rendering"></a><a href="#binding-textures-for-rendering" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Binding textures for rendering</h3>
<p>As any uniform variable, there is a bit of work to do in the C++ side of the code to send/bind values before drawing each object.</p>
<p>The first step is to get the uniform location of <code>uBaseColorTexture</code>.</p>
<p><span class="todo badge"></span> In the <code>run()</code> method, get the uniform location of <code>uBaseColorTexture</code> with <code>glGetUniformLocation</code> (put it in the code where other uniform locations are obtained).</p>
<p>Then just before drawing a primitive, we need to bind the base color texture and tell OpenGL where it is bound.</p>
<p>By &quot;where it is bound&quot;, we mean &quot;on which texture unit&quot; it is bound. But what are texture units ?</p>
<p>In order to use multiple textures at the same time in a shader (like uTextureSky and uTextureCloud of first example of shader), OpenGL offers us multiple texture units, represented by an index. The following C++ example shows an example of binding two textures that could be used for the first shader example:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-comment">// Assume we have:</span>
<span class="hljs-comment">// - uTextureSkyLocation, the uniform location of uTextureSky</span>
<span class="hljs-comment">// - uTextureCloudLocation, the uniform location of uTextureCloud</span>
<span class="hljs-comment">// - skyTexObject, a texture object containing a texture for the sky</span>
<span class="hljs-comment">// - cloudTexObject, a texture object containing a texture for the clouds</span>

<span class="hljs-comment">// Bind skyTexObject to target GL_TEXTURE_2D of texture unit 0</span>
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, skyTexObject);
<span class="hljs-comment">// By setting the uniform to 0, we tell OpenGL the texture is bound on tex unit 0:</span>
glUniform1i(uTextureSkyLocation, <span class="hljs-number">0</span>);

<span class="hljs-comment">// Bind cloudTexObject to target GL_TEXTURE_2D of texture unit 1</span>
glActiveTexture(GL_TEXTURE1);
glBindTexture(GL_TEXTURE_2D, cloudTexObject);
<span class="hljs-comment">// By setting the uniform to 1, we tell OpenGL the texture is bound on tex unit 1:</span>
glUniform1i(uTextureCloudLocation, <span class="hljs-number">1</span>);
</code></pre>
<p>After that we could draw some object (a sky dome ?) that would represent a sky with clouds.</p>
<p>A thing to keep is mind is that, like most calls of OpenGL, everything acts on some global state. So when we do <code>glActiveTexture(GL_TEXTURE1);</code>, then any subsequent calls to texture functions (like <code>glBindTexture</code>) will act on the texture unit 1 and no more on the texture unit 0 (which is the default one).
When we implemented the function <code>createTextureObjects</code> we did a bunch of texture related function calls. These calls act on the currently active texture unit. In our case it should be texture unit 0 since we did not call <code>glActiveTexture</code> before. But in another context, a big application with a lot of code, it might become an issue to just blindly call texture functions of OpenGL without ensuring we have the correct texture unit activated.</p>
<p>So in our case we will use texture units but just to bind multiple textures. For now we only have base color texture, but later we will have the metallic roughness texture.</p>
<p>In order to have a more or less clean implementation, we will implement the texture binding in a specific lambda function <code>bindMaterial(int materialIdx)</code>. For now this function will just bind the base color texture, but it will quickly grow so having the code in a specific function is better. Some other code of the drawing function could also be extracted in dedicated functions, to make things more clear, but it is up to you to do some refactor.</p>
<p><span class="todo badge"></span> Just before the definition of the <code>drawScene</code> lambda function, add the following lambda function:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> bindMaterial = [&amp;](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> materialIndex) {
   <span class="hljs-comment">// Material binding</span>
};
</code></pre>
<p><span class="todo badge"></span> In the <code>drawScene</code> lambda function, just before drawing a specific primitive (before binding its VAO), add a call to <code>bindMaterial</code> with the material index of the primitive as argument.</p>
<p><span class="todo badge"></span> In <code>bindMaterial</code>, implement two cases:</p>
<ul>
<li>if the material index is &gt;= 0, and if this material has a base color texture, bind the base color texture of the material to the texture unit 0 and set the associated uniform to 0.</li>
<li>otherwise, bind the white texture to the texture unit 0 and set the base color texture uniform to 0.</li>
</ul>
<p>As previously, you need a bit of indirections to access the texture index of the base color texture:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-comment">// only valid is materialIndex &gt;= 0</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;material = model.materials[materialIndex];
<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;pbrMetallicRoughness = material.pbrMetallicRoughness;
<span class="hljs-comment">// only valid if pbrMetallicRoughness.baseColorTexture.index &gt;= 0:</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;texture = model.textures[pbrMetallicRoughness.baseColorTexture.index];
</code></pre>
<p><span class="todo badge"></span> Test your application, at this point you should see textures of your scene.</p>
<h3><a class="anchor" aria-hidden="true" id="using-the-base-color-factor"></a><a href="#using-the-base-color-factor" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using the base color factor</h3>
<p>So far we only used the texture of the base color. But the glTF specification specify that we can also have a RGBA factor for the base color. This factor needs to be muliplied by the value read from the texture in order to obtain the full base color.</p>
<p>This factor is stored in <code>pbrMetallicRoughness.baseColorFactor</code> (double array that should contain 4 values). The following code shows how to set a vec4 uniform with this factor:</p>
<pre><code class="hljs css language-cpp">glUniform4f(uBaseColorFactorLocation,
   (<span class="hljs-keyword">float</span>)pbrMetallicRoughness.baseColorFactor[<span class="hljs-number">0</span>],
   (<span class="hljs-keyword">float</span>)pbrMetallicRoughness.baseColorFactor[<span class="hljs-number">1</span>],
   (<span class="hljs-keyword">float</span>)pbrMetallicRoughness.baseColorFactor[<span class="hljs-number">2</span>],
   (<span class="hljs-keyword">float</span>)pbrMetallicRoughness.baseColorFactor[<span class="hljs-number">3</span>]);
</code></pre>
<p><span class="todo badge"></span> In the shader, add a uniform <code>uniform vec4 uBaseColorFactor;</code> and use it in the main function to multiply the <code>baseColorFromTexture</code> variable and store the result in a variable <code>baseColor</code>. Use this new variable for the diffuse computation.</p>
<p><span class="todo badge"></span> In the <code>run()</code> function of <code>ViewerApplication</code>, get the uniform location for <code>uBaseColorFactor</code>.</p>
<p><span class="todo badge"></span> In <code>bindMaterial</code>, set the uniform with <code>glUniform4f</code> as shown previously. If their is no material, set it to white (1, 1, 1, 1).</p>
<h2><a class="anchor" aria-hidden="true" id="diffuse--glossy-material-model-in-glsl"></a><a href="#diffuse--glossy-material-model-in-glsl" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Diffuse + Glossy material model in GLSL</h2>
<p>We now need to complete the shader with the code to handle the glossy component. The diffuse component also have to be modified to match the equations of the model.</p>
<p>As said previously, the goal is to implement the model described here: <a href="https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#appendix-b-brdf-implementation">https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#appendix-b-brdf-implementation</a>, so keep it open and read the appendix carefully.</p>
<p><span class="todo badge"></span> Add uniform variables <code>float uMetallicFactor</code>, <code>float uRougnessFactor</code> and <code>sampler2D uMetallicRoughnessTexture</code> to the shader.</p>
<p>Similar to base color, we will need to multiply the factor by the value read in the texture.</p>
<p>The uMetallicRoughnessTexture contains the metallic value in the blue component, and the rougness value in the green component (source: <a href="https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#pbrmetallicroughnessmetallicroughnesstexture">https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#pbrmetallicroughnessmetallicroughnesstexture</a>).
Also you don't need to call <code>SRGBtoLINEAR()</code> when you read this texture because the values are not really colors, so they are already in a linear space and not sRGB space.</p>
<p><span class="todo badge"></span> Implement the full model from the equations in the <code>main()</code> function of the shader.</p>
<p>Here you really just need to &quot;translate&quot; the mathematical equations to GLSL code. Here are a few tips/hints:</p>
<ul>
<li>The <code>lerp(A, B, x)</code> function mentionned in the specification can be computed in GLSL with <code>mix(A, B, x)</code>.</li>
<li>You already have N and L variables which are the normal and the light direction. You can obtain the view direction V as <code>vec3 V = normalize(-vViewSpacePosition);</code> (works because position in view space is the same as direction), and H as <code>vec3 H = normalize(L + V);</code>.</li>
<li>Keep the same variable names are symbols in the equations, it helps to debug. So \( f_{diffuse} \) should be <code>f_diffuse</code> in your code, for example.</li>
<li>clamp all dot products between 0 and 1, like it is already done for <code>NdotL</code> in the current implementation of the shader</li>
<li>There is two equations for \( f_{specular} \) in the specification. Only the second one is important for us (\( F * Vis * D \))</li>
<li>The same is true for \( Vis \), there is two equation, only the second one is important (the long one, witch square roots in the denominator)</li>
<li>Check your denominator before dividing to compute Vis: if zero or negative, you should put Vis = 0.</li>
<li>At the end you should compute \( f = f_{diffuse} + f_{specular} \). One computed, you obtain the final color of the fragment as <code>LINEARtoSRGB((f_diffuse + f_specular) * uLightIntensity * NdotL)</code>.</li>
<li>Finally, at some point you need to compute the schlick fresnel F that contains a power of 5. To compute a power of 5, don't use <code>pow()</code> function (expensive), instead do something like this:</li>
</ul>
<pre><code class="hljs css language-glsl"><span class="hljs-comment">// You need to compute baseShlickFactor first</span>
<span class="hljs-type">float</span> shlickFactor = baseShlickFactor * baseShlickFactor; <span class="hljs-comment">// power 2</span>
shlickFactor *= shlickFactor; <span class="hljs-comment">// power 4</span>
shlickFactor *= baseShlickFactor; <span class="hljs-comment">// power 5</span>
</code></pre>
<p>Good luck, and have fun !</p>
<h2><a class="anchor" aria-hidden="true" id="setting-uniforms-and-binding-metallic-roughness-texture"></a><a href="#setting-uniforms-and-binding-metallic-roughness-texture" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Setting uniforms and binding metallic-roughness texture</h2>
<p>The last thing to do is to set uniforms and bind the metallic rougness texture. Everything should be the same as we did before: getting uniform locations, reading data from the texture object of the glTF file, setting uniform and binding the texture. We already bound the base color texture to the texture unit 0, so we need to bind this new one on texture unit 1. If there is no material or texture, the specular component should be black: for that it is enough to bind 0 (the same as unbinding).</p>
<p><span class="todo badge"></span> Finish the C++ side by doing what needs to be done, and test you application.</p>
<h2><a class="anchor" aria-hidden="true" id="what-should-be-done-next"></a><a href="#what-should-be-done-next" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What should be done next</h2>
<p>At this point we have what is called a &quot;PBR material model&quot;, PBR standing for &quot;physically based rendering&quot;. If you search information about this on internet, you should find a lot of resources.</p>
<p>However, the material model of glTF is a bit more complex and allows to add more details to the appearance of an object:</p>
<ul>
<li>An emissive factor/map: this one is quite easy to implement, it is basically an ambiant factor.</li>
<li>An occlusion map, which is just a factor to apply to the whole lighting equation, quite easy too</li>
<li>A normal map: this one is harder, but allows to get a really realistic look by simulating some kind of microgeometry (bonus / possibility for the project)</li>
<li>Alpha blending to handle transparency (see &quot;alpha coverage&quot; of the specification). This requires depth sorting for correct rendering (bonus / possibility for the project)</li>
</ul>
<p>Also all we did for lighting is a directional light. This is quite restrictive and very unrealistic. If you really want nice and realistic rendering with PBR materials, you should definitely implement environment lighting for diffuse and glossy components. You can find tutorials here (these are bonus / possibilities for the project):</p>
<ul>
<li><a href="https://learnopengl.com/PBR/IBL/Diffuse-irradiance">https://learnopengl.com/PBR/IBL/Diffuse-irradiance</a></li>
<li><a href="https://learnopengl.com/PBR/IBL/Specular-IBL">https://learnopengl.com/PBR/IBL/Specular-IBL</a></li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/openglnoel/docs/gltf-viewer-04-directional-lighting"><span class="arrow-prev">← </span><span>Directional Lighting</span></a><a class="docs-next button" href="/openglnoel/docs/gltf-viewer-06-shadow-mapping"><span>WIP - Shadow mapping</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#introduction-to-gltf-material-model">Introduction to glTF material model</a></li><li><a href="#texture-objects-creation">Texture objects creation</a><ul class="toc-headings"><li><a href="#opengl-textures">OpenGL textures</a></li><li><a href="#gltf-textures">glTF textures</a></li><li><a href="#the-practice">The practice</a></li></ul></li><li><a href="#diffuse-component-in-glsl">Diffuse component in GLSL</a><ul class="toc-headings"><li><a href="#reading-textures-in-glsl">Reading textures in GLSL</a></li><li><a href="#binding-textures-for-rendering">Binding textures for rendering</a></li><li><a href="#using-the-base-color-factor">Using the base color factor</a></li></ul></li><li><a href="#diffuse--glossy-material-model-in-glsl">Diffuse + Glossy material model in GLSL</a></li><li><a href="#setting-uniforms-and-binding-metallic-roughness-texture">Setting uniforms and binding metallic-roughness texture</a></li><li><a href="#what-should-be-done-next">What should be done next</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/openglnoel/" class="nav-home"><img src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]" width="66" height="58"/></a><div><h5>About Me</h5><a href="http://laurentnoel.fr">Personal website</a><a href="https://github.com/Celeborn2BeAlive/">Github</a></div><div><h5>About This Website</h5><a href="/openglnoel/blog">Blog</a><a class="github-button" href="https://github.com/celeborn2bealive/openglnoel" data-icon="octicon-star" data-count-href="/celeborn2bealive/openglnoel/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">openglnoel</a><a href="https://docusaurus.io/">Powered by Docusaurus</a></div><div><h5>About OpenGL</h5><a href="docs.gl">Documentation (docs.gl)</a><a href="https://www.khronos.org/opengl/wiki/">Wiki</a></div></section><section class="copyright">Copyright © 2020 Laurent NOEL</section></footer></div></body></html>