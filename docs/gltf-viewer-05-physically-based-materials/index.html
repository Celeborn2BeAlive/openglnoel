<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>WIP - Physically based materials · OpenGL[&quot;noël&quot;]</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## Introduction to glTF material model"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="WIP - Physically based materials · OpenGL[&quot;noël&quot;]"/><meta property="og:type" content="website"/><meta property="og:url" content="https://celeborn2bealive.github.io/openglnoel/"/><meta property="og:description" content="## Introduction to glTF material model"/><meta property="og:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><link rel="shortcut icon" href="/openglnoel/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/atom.xml" title="OpenGL[&quot;noël&quot;] Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/feed.xml" title="OpenGL[&quot;noël&quot;] Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/openglnoel/js/code-block-buttons.js"></script><script type="text/javascript" src="/openglnoel/js/disqus.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/openglnoel/js/scrollSpy.js"></script><link rel="stylesheet" href="/openglnoel/css/main.css"/><script src="/openglnoel/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/openglnoel/"><img class="logo" src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]"/><h2 class="headerTitleWithLogo">OpenGL[&quot;noël&quot;]</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/openglnoel/docs/gltf-viewer-01-intro-01-intro" target="_self">glTF Viewer Tutorial</a></li><li class=""><a href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction" target="_self">Intro et SDK</a></li><li class=""><a href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base" target="_self">Bronze</a></li><li class=""><a href="/openglnoel/docs/silver-01-3d-theorie-01-introduction" target="_self">Silver</a></li><li class=""><a href="/openglnoel/docs/gold-01-intro-sdk-01-introduction" target="_self">Gold</a></li><li class=""><a href="/openglnoel/blog/" target="_self">Blog</a></li><li class=""><a href="http://docs.gl" target="_self">OpenGL Documentation</a></li><li class=""><a href="https://www.khronos.org/opengl/wiki/" target="_self">OpenGL Wiki</a></li><li class=""><a href="https://github.com/celeborn2bealive/openglnoel" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Physically Based Materials</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction and SDK</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-01-intro-01-intro">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-01-intro-02-sdk">Software Development Kit</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-01-intro-03-devenv">Development Environment</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Loading and drawing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-02-gltf-01-roadmap">Introduction and roadmap</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-02-gltf-02-initialization">Data initialization</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-02-gltf-03-drawing">Drawing the scene</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Controlling the Camera</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-03-camera-control">Camera Control</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Directional Lighting</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-04-directional-lighting">Directional Lighting</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Physically Based Materials</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/openglnoel/docs/gltf-viewer-05-physically-based-materials">WIP - Physically based materials</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Shadow Mapping</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-06-shadow-mapping">WIP - Shadow mapping</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Deferred Rendering</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-07-deferred-rendering">WIP - Deferred rendering</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Post Processing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-08-post-processing">WIP - Post processing</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">WIP - Physically based materials</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="introduction-to-gltf-material-model"></a><a href="#introduction-to-gltf-material-model" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Introduction to glTF material model</h2>
<p>As explained in <a href="/openglnoel/docs/gltf-viewer-04-directional-lighting#mathematical-model">the previous section on lighting</a>, the material at a specific point is described by a bidirectional reflectance distribution function (BRDF). We used a simple diffuse white model, but in the general case the BRDF is different for each point.</p>
<p>It is expressed from material properties such as a diffuse color, or a glossiness factor, and these properties are generally stored in textures when they are not constant on the whole mesh.</p>
<p>The glTF documentation gives us all we need to understand the material model used by the format:</p>
<ul>
<li><a href="https://raw.githubusercontent.com/KhronosGroup/glTF/master/specification/2.0/figures/gltfOverview-2.0.0b.png">The quick reference card</a> has a &quot;materials&quot; section describing how a material is represented, and a &quot;texture, images, samplers&quot; section describing how textures are represented. We also see in the &quot;meshes&quot; section that each mesh primitive can have a <code>material</code> properties containing the index of the material for this primitive.</li>
<li><a href="https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture-data">The texture data section</a> of the specification explain in details how textures, images and samplers are stored in a glTF file.</li>
<li><a href="https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#materials">The materials section</a> explain in details how a material is described, how to combine factors with textures, etc.</li>
<li><a href="https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#appendix-b-brdf-implementation">The BRDF Implementation appendix</a> gives equations to implement the BRDF \( f_r(\omega_i, \omega_o) \) at a specific point.</li>
<li>Finally, <a href="https://github.com/KhronosGroup/glTF-Sample-Viewer/">the source code for a webGL implementation</a> is available. The shaders of this repository expose an implementation of the BRDF, however it can be hard to read for someone not familiar with the code.</li>
</ul>
<p>In this tutorial I only describe concepts required for our (incomplete) implementation of the material model. For more details you need to read the specification.</p>
<p>Here is our roadmap to implement the model:</p>
<ul>
<li>Texture objects creation</li>
<li>Creation of the shader pbr_directional_light.fs.glsl with handling of diffuse component (GLSL side)</li>
<li>Send uniform data to OpenGL for handling diffuse component (C++ side)</li>
<li>Test that everything work at this point</li>
<li>Finalization of the shader to handle glossy component (GLSL side)</li>
<li>Send remaining uniform data to OpenGL for the glossy component (C++ side)</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="texture-objects-creation"></a><a href="#texture-objects-creation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Texture objects creation</h2>
<h3><a class="anchor" aria-hidden="true" id="gltf-textures"></a><a href="#gltf-textures" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>glTF textures</h3>
<p>The glTF contains a <code>textures</code> array describing all textures that can be referenced by materials.</p>
<p>A texture has the following shape:</p>
<pre><code class="hljs css language-json">{
    <span class="hljs-attr">"textures"</span>: [
        {
            <span class="hljs-attr">"sampler"</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">"source"</span>: <span class="hljs-number">2</span>
        }
    ]
}
</code></pre>
<p>The <code>source</code> attribute is the index of an image, the <code>sampler</code> attribute is the index of a sampler.</p>
<h4><a class="anchor" aria-hidden="true" id="images"></a><a href="#images" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Images</h4>
<p>Images are stored in an <code>images</code> array, with the following shape:</p>
<pre><code class="hljs css language-json">{
    <span class="hljs-attr">"images"</span>: [
        {
            <span class="hljs-attr">"uri"</span>: <span class="hljs-string">"duckCM.png"</span>
        },
        {
            <span class="hljs-attr">"bufferView"</span>: <span class="hljs-number">14</span>,
            <span class="hljs-attr">"mimeType"</span>: <span class="hljs-string">"image/jpeg"</span> 
        }
    ]
}
</code></pre>
<p>Here we have two images in the array: one is a file, the second is a jpeg store in a buffer of the glTF file.</p>
<p>If we were doing everything from scratch, we would need to manually load images from disk or buffers. Fortunately, the tinygltf library does that for us so we can directly access the data and send it to the GPU in texture objects. This code examples shows how to fill a texture object using an image from tinygltf:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-comment">// Assume a texture object has been created and bound to GL_TEXTURE_2D</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;texture = model.textures[i]; <span class="hljs-comment">// get i-th texture</span>
assert(texture.source &gt;= <span class="hljs-number">0</span>); <span class="hljs-comment">// ensure a source image is present</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;image = model.images[texture.source]; <span class="hljs-comment">// get the image</span>

<span class="hljs-comment">// fill the texture object with the data from the image</span>
glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGBA, image.width, image.height, <span class="hljs-number">0</span>,
        GL_RGBA, image.pixel_type, image.image.data());
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="samplers"></a><a href="#samplers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Samplers</h4>
<p>A sampler describes how a texture must be read by OpenGL: what filters to use, what wrapping mode to use. Similar to all glTF objects, they are stored in a <code>samplers</code> array, with the following shape:</p>
<pre><code class="hljs css language-json">{
    <span class="hljs-attr">"samplers"</span>: [
        {
            <span class="hljs-attr">"magFilter"</span>: <span class="hljs-number">9729</span>,
            <span class="hljs-attr">"minFilter"</span>: <span class="hljs-number">9987</span>,
            <span class="hljs-attr">"wrapS"</span>: <span class="hljs-number">10497</span>,
            <span class="hljs-attr">"wrapT"</span>: <span class="hljs-number">10497</span>
        }
    ]
}
</code></pre>
<p>The constant number here correspond to OpenGL constants such as <code>GL_LINEAR</code>, <code>NEAREST_MIPMAP_NEAREST</code>, <code>GL_REPEAT</code>, etc. It means we can directly use the values to setup texture sampling with the OpenGL API:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-comment">// Assume a texture object has been created and bound to GL_TEXTURE_2D</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;texture = model.textures[i]; <span class="hljs-comment">// get i-th texture</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;sampler =
        texture.sampler &gt;= <span class="hljs-number">0</span> ? model.samplers[texture.sampler] : defaultSampler;
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
   sampler.minFilter != <span class="hljs-number">-1</span> ? sampler.minFilter : GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
   sampler.magFilter != <span class="hljs-number">-1</span> ? sampler.magFilter : GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, sampler.wrapS);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, sampler.wrapT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, sampler.wrapR);
</code></pre>
<p>When a filter is undefined, we use <code>GL_LINEAR</code> as default filter. And when no sampler is defined for the texture (in that case we have <code>texture.sampler == -1</code>), we use a default sampler defined as:</p>
<pre><code class="hljs css language-cpp">tinygltf::Sampler defaultSampler;
defaultSampler.minFilter = GL_LINEAR;
defaultSampler.magFilter = GL_LINEAR;
defaultSampler.wrapS = GL_REPEAT;
defaultSampler.wrapT = GL_REPEAT;
defaultSampler.wrapR = GL_REPEAT;
</code></pre>
<p>Some samplers use mipmapping for their minification filter. In that case, the specification tells us we need to have mipmaps computed for the texture. OpenGL can compute them for us:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-keyword">if</span> (sampler.minFilter == GL_NEAREST_MIPMAP_NEAREST ||
   sampler.minFilter == GL_NEAREST_MIPMAP_LINEAR ||
   sampler.minFilter == GL_LINEAR_MIPMAP_NEAREST ||
   sampler.minFilter == GL_LINEAR_MIPMAP_LINEAR) {
   glGenerateMipmap(GL_TEXTURE_2D);
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="diffuse-component-in-glsl"></a><a href="#diffuse-component-in-glsl" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Diffuse component in GLSL</h2>
<h3><a class="anchor" aria-hidden="true" id="reading-textures-in-glsl"></a><a href="#reading-textures-in-glsl" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reading textures in GLSL</h3>
<p>In GLSL, it is quite easy to declare and use a texture. Textures are declared as samplers in uniform variables, and we read them with the texture function.</p>
<p>For example a simple shader using texture could be like that:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-meta">#version 330</span>

<span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> vTexCoords;

<span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> uTextureSky;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> uTextureCloud;

<span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fColor;

<span class="hljs-type">void</span> main()
{
   <span class="hljs-type">vec4</span> skyColor = <span class="hljs-built_in">texture</span>(uTextureSky, vTexCoords);
   <span class="hljs-type">vec4</span> cloudColor = <span class="hljs-built_in">texture</span>(uTextureCloud, vTexCoords);

   fColor = skyColor.rgb + cloudColor.rgb; <span class="hljs-comment">// we don't use the alpha component in this simple shader</span>
}
</code></pre>
<p>Here we have two texture and we add the colors we read from them.</p>
<p>However, a subtility might occur when we manipulate material textures. This is the case for the base color texture of glTF (but not the metal roughness texture that we'll use later).</p>
<p>The base color texture has RGB values encoded in sRGB color space. It basically means that these values are not real lighting intensities as you would compute them in a render engine (or lighting simulation), but have been modified to be displayed on a computer screen. This transform is necessary if we want to be able to see the same image on a computer screen as we would see in reality, on a printing for example.</p>
<p>You can find more information <a href="https://en.wikipedia.org/wiki/SRGB">on wikipedia</a> about this transform and why it exists. Another good resource about color is <a href="https://hg2dc.com/">The Hitchiker's Guide to Digital Colour</a>.</p>
<p>What does it mean for us ? It means we have to invert the sRGB transform</p>
<hr>
<p>Work in Progress.</p>
<p>If you arrive to this point but I still have not written this tutorial, here is the roadmap, you should be able to do it by yourself.</p>
<p>Documentation:</p>
<ul>
<li>Carefully read the parts &quot;textures, images, samplers&quot; and &quot;materials&quot; of the quick reference image <a href="https://raw.githubusercontent.com/KhronosGroup/glTF/master/specification/2.0/figures/gltfOverview-2.0.0b.png">https://raw.githubusercontent.com/KhronosGroup/glTF/master/specification/2.0/figures/gltfOverview-2.0.0b.png</a>. Note that <code>tinygltf</code> loads for you the images, so you don't need to read image files yourself.</li>
<li>Read the parts <a href="https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture-data">https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture-data</a> and <a href="https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#materials">https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#materials</a> of the specification.</li>
<li>Read appendix B <a href="https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#appendix-b-brdf-implementation">https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#appendix-b-brdf-implementation</a> for more details about the BRDF.</li>
</ul>
<p>Proposed steps for implementation:</p>
<ol>
<li>Start by trying to adapt our white diffuse model to the material base color. The goal is to replace our constant \( (\frac{1}{\pi}, \frac{1}{\pi}, \frac{1}{\pi}) \) with the base color of the material of the object
<ol>
<li>You need to add a uBaseColorFactor in your fragment shading and use it for the lighting calculation</li>
<li>At the moment you draw a mesh in your drawing function, you need to get the material of this mesh</li>
<li>Then set the base color factor uniform from what is stored in the material</li>
</ol></li>
<li>Then use textures
<ol>
<li>You need to create openGL textures for each texture of the glTF</li>
<li>You need to add a sampler2D uBaseColor uniform in your shader and use it for the lighting calculation (multiply what you read from it with the base color factor)</li>
<li>And again in the drawing function, you need to bind the texture from what is stored in the material</li>
</ol></li>
<li>At this point, you should already have correct colors and textures with just diffuse shading. Now you need to implement the full shading model by following the documentation (specification + appendix). If you do it properly, you should have nice metallic or plastic materials.</li>
</ol>
<p>And if you want to finish it, you need to implement (these are bonus / possibilities for the project):</p>
<ul>
<li>Normal mapping with the normal texture</li>
<li>Alpha blending to handle transparency (see &quot;alpha coverage&quot; of the specification). This requires depth sorting for correct rendering</li>
</ul>
<p>If you really want nice and realistic rendering with this kind of material, you would like to implement environment lighting for diffuse and glossy. You can find tutorials here (again, these are bonus / possibilities for the project):</p>
<ul>
<li><a href="https://learnopengl.com/PBR/IBL/Diffuse-irradiance">https://learnopengl.com/PBR/IBL/Diffuse-irradiance</a></li>
<li><a href="https://learnopengl.com/PBR/IBL/Specular-IBL">https://learnopengl.com/PBR/IBL/Specular-IBL</a></li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/openglnoel/docs/gltf-viewer-04-directional-lighting"><span class="arrow-prev">← </span><span>Directional Lighting</span></a><a class="docs-next button" href="/openglnoel/docs/gltf-viewer-06-shadow-mapping"><span>WIP - Shadow mapping</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#introduction-to-gltf-material-model">Introduction to glTF material model</a></li><li><a href="#texture-objects-creation">Texture objects creation</a><ul class="toc-headings"><li><a href="#gltf-textures">glTF textures</a></li></ul></li><li><a href="#diffuse-component-in-glsl">Diffuse component in GLSL</a><ul class="toc-headings"><li><a href="#reading-textures-in-glsl">Reading textures in GLSL</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/openglnoel/" class="nav-home"><img src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]" width="66" height="58"/></a><div><h5>About Me</h5><a href="http://laurentnoel.fr">Personal website</a><a href="https://github.com/Celeborn2BeAlive/">Github</a></div><div><h5>About This Website</h5><a href="/openglnoel/blog">Blog</a><a class="github-button" href="https://github.com/celeborn2bealive/openglnoel" data-icon="octicon-star" data-count-href="/celeborn2bealive/openglnoel/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">openglnoel</a><a href="https://docusaurus.io/">Powered by Docusaurus</a></div><div><h5>About OpenGL</h5><a href="docs.gl">Documentation (docs.gl)</a><a href="https://www.khronos.org/opengl/wiki/">Wiki</a></div></section><section class="copyright">Copyright © 2020 Laurent NOEL</section></footer></div></body></html>