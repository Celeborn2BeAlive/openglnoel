<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Percentage Closest Filtering · OpenGL[&quot;noël&quot;]</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## Percentage Closest Filtering"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Percentage Closest Filtering · OpenGL[&quot;noël&quot;]"/><meta property="og:type" content="website"/><meta property="og:url" content="https://celeborn2bealive.github.io/openglnoel/"/><meta property="og:description" content="## Percentage Closest Filtering"/><meta property="og:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><link rel="shortcut icon" href="/openglnoel/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/atom.xml" title="OpenGL[&quot;noël&quot;] Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/feed.xml" title="OpenGL[&quot;noël&quot;] Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/openglnoel/js/code-block-buttons.js"></script><script type="text/javascript" src="/openglnoel/js/disqus.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/openglnoel/js/scrollSpy.js"></script><link rel="stylesheet" href="/openglnoel/css/main.css"/><script src="/openglnoel/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/openglnoel/"><img class="logo" src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]"/><h2 class="headerTitleWithLogo">OpenGL[&quot;noël&quot;]</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction" target="_self">Intro et SDK</a></li><li class=""><a href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base" target="_self">Bronze</a></li><li class=""><a href="/openglnoel/docs/silver-01-3d-theorie-01-introduction" target="_self">Silver</a></li><li class="siteNavGroupActive"><a href="/openglnoel/docs/gold-01-intro-sdk-01-introduction" target="_self">Gold</a></li><li class=""><a href="/openglnoel/docs/gltf-viewer-01-intro" target="_self">glTF Viewer Tutorial</a></li><li class=""><a href="/openglnoel/blog/" target="_self">Blog</a></li><li class=""><a href="http://docs.gl" target="_self">OpenGL Documentation</a></li><li class=""><a href="https://www.khronos.org/opengl/wiki/" target="_self">OpenGL Wiki</a></li><li class=""><a href="https://github.com/celeborn2bealive/openglnoel" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Shadow Mapping</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction et SDK</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-01-intro-sdk-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-01-intro-sdk-03-fiche-info">Fiche d&#x27;information</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-01-intro-sdk-05-projet">Projet - Un viewer glTF</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Forward Renderer</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-01-pipeline">Pipeline de Rendu</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-02-geometrie">Geometrie</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-03-shaders">Shaders</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-04-transformations">Transformations</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-05-lighting">Lighting</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-06-textures">Textures</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-07-load-obj">Chargement de modèles OBJ</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-08-plus-loin">Aller plus loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Deferred Renderer</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-01-pipeline">Pipeline de Rendu</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-02-geometry-pass">Geometrie Pass</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-03-shading-pass">Shading Pass</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-04-plus-loin">Aller plus loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Shadow Mapping</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-02-dir-shadow-map">Directional Shadow Map</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-03-percentage-closest-filtering">Percentage Closest Filtering</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-04-aller-plus-loin">Aller Plus Loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Post Processing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-02-gamma-correction">Gamma Correction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-03-extraction-contours">Extraction et Rendu de Contours</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-04-depth-of-field">Depth of Field</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Annexe: API OpenGL</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-01-opengl-context">Contexte OpenGL</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-02-gpu-pipeline">Pipeline de Rendu</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-03-opengl-extensions">Extensions OpenGL</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-04-opengl-objects">Objets OpenGL</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-05-buffer-objects">Buffer Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-06-vertex-array-objects">Vertex Array Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-07-textures">Texture Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-08-framebuffer-objects">Framebuffer Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-09-shaders">Shaders</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Percentage Closest Filtering</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="percentage-closest-filtering"></a><a href="#percentage-closest-filtering" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Percentage Closest Filtering</h2>
<h3><a class="anchor" aria-hidden="true" id="basique"></a><a href="#basique" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Basique</h3>
<p>L'aspect visuel du shadow mapping dépend grandement de la résolution choisie. Pour une résolution de 512, vous avez du constater que le rendu des ombres est très aliasé. Il faut monter à 4096 au moins pour ne plus voir l'aliasing à une distance correcte, qui reste très visible en se rapprochant.</p>
<p>Une manière de palier à cet aliasing est d'utiliser une méthode de filtrage appelée <em>Percentage Closest Filtering</em>, qui consiste à moyenner la visibilité dans un voisinage du point afin de flouter/bruiter les ombres sur leur bord.</p>
<p>Cette technique est en partie supportée par le GPU en passant par un sampler de type <em>sampler2DShadow</em> en GLSL.</p>
<p>Dans <em>shadingPass.fs.glsl</em>, remplacez la déclaration des uniformes du shadow mapping par:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> uDirLightViewProjMatrix;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2DShadow</span> uDirLightShadowMap;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">float</span> uDirLightShadowMapBias;
</code></pre>
<p>Puis remplacez le code de calcul de la visibilité par:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-type">vec4</span> positionInDirLightScreen = uDirLightViewProjMatrix * <span class="hljs-type">vec4</span>(position, <span class="hljs-number">1</span>); <span class="hljs-comment">// Compute fragment position in NDC space of light</span>
<span class="hljs-type">vec3</span> positionInDirLightNDC = <span class="hljs-type">vec3</span>(positionInDirLightScreen / positionInDirLightScreen.w) * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>; <span class="hljs-comment">// Homogeneize + put between 0 and 1</span>
<span class="hljs-type">float</span> dirLightVisibility = <span class="hljs-built_in">textureProj</span>(uDirLightShadowMap, <span class="hljs-type">vec4</span>(positionInDirLightNDC.xy, positionInDirLightNDC.z - uDirLightShadowMapBias, <span class="hljs-number">1.0</span>), <span class="hljs-number">0.0</span>);
</code></pre>
<p>On utilise donc un <em>sampler2DShadow</em> à la place d'un <em>sampler2D</em> et la fonction <em>textureProj</em> à la place de <em>texture</em>. Ce code permet d'obtenir un filtrage 2x2 (bilinéaire) sur nos ombres.</p>
<p>Afin que ce shader fonctionne, il faut rajouter deux lignes à l'initialisation du sampler m_directionalSMSampler:</p>
<pre><code class="hljs css language-cpp">glGenSamplers(<span class="hljs-number">1</span>, &amp;m_directionalSMSampler);
glSamplerParameteri(m_directionalSMSampler, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glSamplerParameteri(m_directionalSMSampler, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
glSamplerParameteri(m_directionalSMSampler, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
glSamplerParameteri(m_directionalSMSampler, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
glSamplerParameteri(m_directionalSMSampler, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_REF_TO_TEXTURE); <span class="hljs-comment">// Cette ligne</span>
glSamplerParameteri(m_directionalSMSampler, GL_TEXTURE_COMPARE_FUNC, GL_LEQUAL) <span class="hljs-comment">// Et celle ci;</span>
</code></pre>
<p>Ces lignes définissent le comportement de la fonction <em>textureProj</em> dans le shader.</p>
<p>Une fois ces modifications effectuées, lancez votre application et constatez que les ombres sont un peu floutées.</p>
<h3><a class="anchor" aria-hidden="true" id="arbitraire"></a><a href="#arbitraire" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arbitraire</h3>
<p>Il est possible d'allouer plus loin dans le filtrage des ombres en appliquant un filtre arbitraire lors de la lecture de la shadow map. Cela est plus couteux mais également plus agréable visuellement.</p>
<p>Dans <em>shadingPass.fs.glsl</em>, ajoutez les uniform:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-keyword">uniform</span> <span class="hljs-type">int</span> uDirLightShadowMapSampleCount;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">float</span> uDirLightShadowMapSpread;
</code></pre>
<p>et le code utilitaires (avant le main):</p>
<pre><code class="hljs css language-glsl"><span class="hljs-type">vec2</span> poissonDisk[<span class="hljs-number">16</span>] = <span class="hljs-type">vec2</span>[](
    <span class="hljs-type">vec2</span>( <span class="hljs-number">-0.94201624</span>, <span class="hljs-number">-0.39906216</span> ),
    <span class="hljs-type">vec2</span>( <span class="hljs-number">0.94558609</span>, <span class="hljs-number">-0.76890725</span> ),
    <span class="hljs-type">vec2</span>( <span class="hljs-number">-0.094184101</span>, <span class="hljs-number">-0.92938870</span> ),
    <span class="hljs-type">vec2</span>( <span class="hljs-number">0.34495938</span>, <span class="hljs-number">0.29387760</span> ),
    <span class="hljs-type">vec2</span>( <span class="hljs-number">-0.91588581</span>, <span class="hljs-number">0.45771432</span> ),
    <span class="hljs-type">vec2</span>( <span class="hljs-number">-0.81544232</span>, <span class="hljs-number">-0.87912464</span> ),
    <span class="hljs-type">vec2</span>( <span class="hljs-number">-0.38277543</span>, <span class="hljs-number">0.27676845</span> ),
    <span class="hljs-type">vec2</span>( <span class="hljs-number">0.97484398</span>, <span class="hljs-number">0.75648379</span> ),
    <span class="hljs-type">vec2</span>( <span class="hljs-number">0.44323325</span>, <span class="hljs-number">-0.97511554</span> ),
    <span class="hljs-type">vec2</span>( <span class="hljs-number">0.53742981</span>, <span class="hljs-number">-0.47373420</span> ),
    <span class="hljs-type">vec2</span>( <span class="hljs-number">-0.26496911</span>, <span class="hljs-number">-0.41893023</span> ),
    <span class="hljs-type">vec2</span>( <span class="hljs-number">0.79197514</span>, <span class="hljs-number">0.19090188</span> ),
    <span class="hljs-type">vec2</span>( <span class="hljs-number">-0.24188840</span>, <span class="hljs-number">0.99706507</span> ),
    <span class="hljs-type">vec2</span>( <span class="hljs-number">-0.81409955</span>, <span class="hljs-number">0.91437590</span> ),
    <span class="hljs-type">vec2</span>( <span class="hljs-number">0.19984126</span>, <span class="hljs-number">0.78641367</span> ),
    <span class="hljs-type">vec2</span>( <span class="hljs-number">0.14383161</span>, <span class="hljs-number">-0.14100790</span> )
);

<span class="hljs-type">float</span> random(<span class="hljs-type">vec4</span> seed)
{
    <span class="hljs-type">float</span> dot_product = <span class="hljs-built_in">dot</span>(seed, <span class="hljs-type">vec4</span>(<span class="hljs-number">12.9898</span>,<span class="hljs-number">78.233</span>,<span class="hljs-number">45.164</span>,<span class="hljs-number">94.673</span>));
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fract</span>(<span class="hljs-built_in">sin</span>(dot_product) * <span class="hljs-number">43758.5453</span>);
}
</code></pre>
<p>Le tableau poissonDisk definit 16 échantillons d'une distribution de poisson 2D centrée en (0,0). La fonction random permet d'obtenir un nombre pseudo-aléatoire à partir d'une graine.</p>
<p>Dans le main du shader, remplacez le calcul de la visibilité par:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-type">float</span> dirLightVisibility = <span class="hljs-number">0.0</span>;
<span class="hljs-type">float</span> dirSampleCountf = <span class="hljs-type">float</span>(uDirLightShadowMapSampleCount);
<span class="hljs-type">int</span> <span class="hljs-built_in">step</span> = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">16</span> / uDirLightShadowMapSampleCount);
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; uDirLightShadowMapSampleCount; ++i)
{
    <span class="hljs-comment">// Noisy shadows:</span>
    <span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-type">int</span>(dirSampleCountf * random(<span class="hljs-type">vec4</span>(<span class="hljs-built_in">gl_FragCoord</span>.xyy, i))) % uDirLightShadowMapSampleCount;

    dirLightVisibility += <span class="hljs-built_in">textureProj</span>(uDirLightShadowMap, <span class="hljs-type">vec4</span>(positionInDirLightNDC.xy + uDirLightShadowMapSpread * poissonDisk[<span class="hljs-keyword">index</span>], positionInDirLightNDC.z - uDirLightShadowMapBias, <span class="hljs-number">1.0</span>), <span class="hljs-number">0.0</span>);
}
dirLightVisibility /= dirSampleCountf;
</code></pre>
<p>Dans le code de l'application, faites en sorte de pouvoir setter les deux nouvelles uniforms uDirLightShadowMapSampleCount et uDirLightShadowMapSpread via la GUI. La variable uDirLightShadowMapSpread doit être relativement petite (de l'ordre de 0.0005) afin de ne pas trop disperser les ombres.</p>
<p>Essayez ce code. Il devrait vous donner des ombres bruitées mais douces.</p>
<p>Une alternative pour obtenir des ombres floutées plutot que bruitées est de calculer l'index dans la boucle avec:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-comment">// Blurred shadows:</span>
<span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = (i + <span class="hljs-built_in">step</span>) % uDirLightShadowMapSampleCount;
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/openglnoel/docs/gold-04-shadow-mapping-02-dir-shadow-map"><span class="arrow-prev">← </span><span>Directional Shadow Map</span></a><a class="docs-next button" href="/openglnoel/docs/gold-04-shadow-mapping-04-aller-plus-loin"><span>Aller Plus Loin</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#percentage-closest-filtering">Percentage Closest Filtering</a><ul class="toc-headings"><li><a href="#basique">Basique</a></li><li><a href="#arbitraire">Arbitraire</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/openglnoel/" class="nav-home"><img src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]" width="66" height="58"/></a><div><h5>About Me</h5><a href="http://laurentnoel.fr">Personal website</a><a href="https://github.com/Celeborn2BeAlive/">Github</a></div><div><h5>About This Website</h5><a href="/openglnoel/blog">Blog</a><a class="github-button" href="https://github.com/celeborn2bealive/openglnoel" data-icon="octicon-star" data-count-href="/celeborn2bealive/openglnoel/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">openglnoel</a><a href="https://docusaurus.io/">Powered by Docusaurus</a></div><div><h5>About OpenGL</h5><a href="docs.gl">Documentation (docs.gl)</a><a href="https://www.khronos.org/opengl/wiki/">Wiki</a></div></section><section class="copyright">Copyright © 2020 Laurent NOEL</section></footer></div></body></html>