<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Camera Control · OpenGL[&quot;noël&quot;]</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Our viewer is now able to render 3d models with a basic normal shader. You can also control the camera with a &quot;First Person Camera Controller&quot;. While this kind of controller can be good for video game, we generally don&#x27;t use that for production or viewer applications."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Camera Control · OpenGL[&quot;noël&quot;]"/><meta property="og:type" content="website"/><meta property="og:url" content="https://celeborn2bealive.github.io/openglnoel/"/><meta property="og:description" content="Our viewer is now able to render 3d models with a basic normal shader. You can also control the camera with a &quot;First Person Camera Controller&quot;. While this kind of controller can be good for video game, we generally don&#x27;t use that for production or viewer applications."/><meta property="og:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><link rel="shortcut icon" href="/openglnoel/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/atom.xml" title="OpenGL[&quot;noël&quot;] Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/feed.xml" title="OpenGL[&quot;noël&quot;] Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/openglnoel/js/code-block-buttons.js"></script><script type="text/javascript" src="/openglnoel/js/disqus.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/openglnoel/js/scrollSpy.js"></script><link rel="stylesheet" href="/openglnoel/css/main.css"/><script src="/openglnoel/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/openglnoel/"><img class="logo" src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]"/><h2 class="headerTitleWithLogo">OpenGL[&quot;noël&quot;]</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/openglnoel/docs/gltf-viewer-01-intro-01-intro" target="_self">glTF Viewer Tutorial</a></li><li class=""><a href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction" target="_self">Intro et SDK</a></li><li class=""><a href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base" target="_self">Bronze</a></li><li class=""><a href="/openglnoel/docs/silver-01-3d-theorie-01-introduction" target="_self">Silver</a></li><li class=""><a href="/openglnoel/docs/gold-01-intro-sdk-01-introduction" target="_self">Gold</a></li><li class=""><a href="/openglnoel/blog/" target="_self">Blog</a></li><li class=""><a href="http://docs.gl" target="_self">OpenGL Documentation</a></li><li class=""><a href="https://www.khronos.org/opengl/wiki/" target="_self">OpenGL Wiki</a></li><li class=""><a href="https://github.com/celeborn2bealive/openglnoel" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Controlling the Camera</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction and SDK</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-01-intro-01-intro">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-01-intro-02-sdk">Software Development Kit</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-01-intro-03-devenv">Development Environment</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Loading and drawing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-02-gltf-01-roadmap">Introduction and roadmap</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-02-gltf-02-initialization">Data initialization</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-02-gltf-03-drawing">Drawing the scene</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Controlling the Camera</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/openglnoel/docs/gltf-viewer-03-camera-control">Camera Control</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Directional Lighting</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-04-directional-lighting">Directional Lighting</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Physically Based Materials</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-05-physically-based-materials">Physically based materials</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Projet 2020 (Fr, Imac et Master 2 Image)</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-2020-projet">Projet</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Work in Progress</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-06-shadow-mapping">WIP - Shadow mapping</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-07-deferred-rendering">WIP - Deferred rendering</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-08-post-processing">WIP - Post processing</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Camera Control</h1></header><article><div><span><p>Our viewer is now able to render 3d models with a basic normal shader. You can also control the camera with a &quot;First Person Camera Controller&quot;. While this kind of controller can be good for video game, we generally don't use that for production or viewer applications.</p>
<p>A more common camera controller is the TrackballCamera. We will implement that in the second part of this section. We will first try to compute a better default camera when no camera is specified on the command line.</p>
<h2><a class="anchor" aria-hidden="true" id="the-camera-model"></a><a href="#the-camera-model" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Camera model</h2>
<p>A camera is generally represented by three points:</p>
<ul>
<li>an eye: the position of the camera</li>
<li>a center: where the camera is looking at</li>
<li>an up vector: which direction is up relative to the axis [eye, center]</li>
</ul>
<p>These three points are enough to compute a view matrix with the <code>glm::lookAt</code> function.</p>
<p>It's important to understand that the Camera model is more powerful than the concept of matrices: you can compute a single view matrix from a camera, but for a single view matrix, there is an infinite number of camera (all cameras with the same position, orientation, but with a different center along the camera z axis).</p>
<p>That's why we choose to manipulate a Camera from the inputs rather than a view matrix.</p>
<p>In terms of code, the Camera class is defined in cameras.hpp. I've implemented a bunch of operations for reference but it's likely we won't use them. Each operation correspond to the terminology of real cameras, and you can find more information atthe following link and in the figure below.</p>
<ul>
<li><a href="http://learnwebgl.brown37.net/07_cameras/camera_movement.html">http://learnwebgl.brown37.net/07_cameras/camera_movement.html</a></li>
</ul>
<p><img src="/openglnoel/img/gltf/camera.png" alt="camera_movements"></p>
<h2><a class="anchor" aria-hidden="true" id="implementing-a-better-default-camera"></a><a href="#implementing-a-better-default-camera" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Implementing a better default camera</h2>
<p>Right now our default camera is simple:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-comment">// Somewhere in the run() function</span>
cameraController.setCamera(
        Camera{glm::vec3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), glm::vec3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>), glm::vec3(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)});
</code></pre>
<p>This correspond to the default view of OpenGL. It gives an identity view matrix (by default we look at the negative z axis with OpenGL).</p>
<p>Our goal is to implement a default camera that is better for our scene. It will not be amazing for some scenes, but most standard objects will be well presented.</p>
<p>The idea is to use the bounding box of the scene and compute our parameters from it. A bounding box is defined by a lower point bboxMin and higher point bboxMax. We want to have our center point at the center of the bounding box of the scene, and to look at it from the diagonal, far enough to see most of the scene.</p>
<p><span class="todo badge"></span> What is the formula for the center point of the bounding box defined by bboxMin and bboxMax ?</p>
<p><span class="todo badge"></span> What is the formula for the diagonal vector going from bboxMin to bboxMax ?</p>
<p>To compute the bounds of the scene, I've implemented a function in <code>utils/gltf.hpp</code>:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">computeSceneBounds</span><span class="hljs-params">(
    <span class="hljs-keyword">const</span> tinygltf::Model &amp;model, glm::vec3 &amp;bboxMin, glm::vec3 &amp;bboxMax)</span></span>;
</code></pre>
<p>(the function is not too complicated, but it is quite similar to what we already did to build VAOs and draw the scene, you can take a look if you want or even try to reimplement it without looking).</p>
<p><span class="todo badge"></span> After loading the scene, use this function to compute the bounding box of the scene.</p>
<blockquote>
<p>For the next todos you might need to reorder a bit the run() function: load the scene before computing matrices.</p>
</blockquote>
<p><span class="todo badge"></span> Replace the default camera with a camera such that center is the center of the bounding box, eye is computed as center + diagonal vector, and up is (0, 1, 0). (ideally the up vector should be specified with the file, on the command line for example, because some 3d modelers use the convention up = (0, 0, 1)).</p>
<p><span class="todo badge"></span> Test your code on Sponza and DamagedHelmet.</p>
<p>A special case we need to handle is flat scenes (like a single triangle). In that case, we need to use align our view with a vector orthogonal to the scene. We will only handle flat scenes on the z axis.</p>
<p><span class="todo badge"></span> What is a condition to test if the scene is flat on the z axis ?</p>
<p><span class="todo badge"></span> It the scene is flat on the z axis, use this eye point instead: center + 2.f * glm::cross(diag, up);</p>
<p>To finish improving our camera, we will also improve the projection matrix and the controller speed.</p>
<p><span class="todo badge"></span> Use the diagonal vector to compute a maximum distance between two points of the scene. If it is zero, set it to 100. instead.</p>
<p><span class="todo badge"></span> Use near = 0.001f * maxDistance and far = 1.5f * maxDistance to compute the project matrix (the call to <code>glm::perspective</code>).</p>
<p><span class="todo badge"></span> Set the camera controller speed (second argument of the controller) to a percentage of the maxDistance. Try different values and choose one that suits you.</p>
<hr>
<p>Solution:</p>
<ul>
<li><a href="https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/8a5fb770286ae51e61471c46345c8abb8d2da2ad">https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/8a5fb770286ae51e61471c46345c8abb8d2da2ad</a></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="trackball-camera-controller"></a><a href="#trackball-camera-controller" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Trackball camera controller</h2>
<blockquote>
<p>For this exercise, you may need some modifications I made on the master branch. If your fork of my repository has been done before 2020-02-05, then please do a pull request of my master branch to your master branch. What you need is this commit <a href="https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/2f9f96926c443b9dd2eca2f5f28f4c8359eef7ab">https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/2f9f96926c443b9dd2eca2f5f28f4c8359eef7ab</a> that cleans up a bit some useless parts of the template code. To perform the merge request, follow <a href="gltf-viewer-02-gltf-03-drawing#optional-merge-master-branch-from-the-base-repository">this part of the tutorial</a>.</p>
</blockquote>
<blockquote>
<p>Sponza is not the best to test the trackball camera controller. Personally I am testing mine on DamagedHelmet that you can get in the glTF samples repository or here: <a href="/openglnoel/files/DamagedHelmet.zip">DamagedHelmet</a></p>
</blockquote>
<p>Now our goal is to implement a new camera controller. The trackall controller should offer the following functionalities:</p>
<ul>
<li>Rotate around center with middle mouse pressed</li>
<li>Move on plane orthogonal to the view axis with shift+middle mouse pressed</li>
<li>Dolly in/out with ctrl+middle mouse pressed</li>
</ul>
<p>It you have Blender 2.8 installed, this are the control offered by the camera. This kind of controller is very important for a viewer because we generally want to rotate around a loaded model and zoom towards it.</p>
<p>The big part of the code must be done in the <code>update()</code> method of <code>TrackballCameraController</code> which is empty for now. We will do that in multiple step. The first step is super easy:</p>
<p><span class="todo badge"></span> In <code>ViewerApplication::run()</code> replace the <code>FirstPersonCameraController</code> by a <code>TrackballCameraController</code>.</p>
<p>If you try the code right now, the camera should be &quot;locked&quot;, we need to implement the <code>update()</code> method.</p>
<p>First we need to gather user inputs: is the middle button pressed ? how did the mouse moved since the last update ? is shift or ctrl pressed ? All of this must be done with functions from <code>glfw</code> in a way very similar to <code>FirstPersonCameraController::update()</code>. The beginning of the function should be almost identical except that we are intersted in the middle button instead of the left button of the mouse.</p>
<p><span class="todo badge"></span> Implement the beginning of <code>TrackballCameraController::update()</code> by taking example in <code>FirstPersonCameraController::update()</code>.</p>
<p>Then we need to isolate three cases: is shift pressed ? in that case we want to pan the camera (lateral movement orthogonal to the view direction). Is ctrl pressed ? in that case we want to zoom/unzoom toward/backward the target. And if no keyboard key is pressed, we just rotate aroung the target.</p>
<p><span class="todo badge"></span> Add the tests for the various possibilities and extract meaningful parameters from the mouse movements. For pan and rotate we need horizontal and vertical movements. For zoom we need only horizontal movement (going right will zoom, going left will unzoom).</p>
<p>Solution:</p>
<ul>
<li><a href="https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/44281e941903c25e56252156433b9fdf1fa5416f">https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/44281e941903c25e56252156433b9fdf1fa5416f</a></li>
</ul>
<p><span class="todo badge"></span> Implement the &quot;pan&quot; case. This one is the easier, you just need to use the <code>moveLocal</code> method of <code>m_camera</code> with the correct parameters (movement only on x and y axis of the camera, no move on z).</p>
<p>Solution:</p>
<ul>
<li><a href="https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/f85b2db19bac9d94a45b01b1e74152138907d591">https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/f85b2db19bac9d94a45b01b1e74152138907d591</a></li>
</ul>
<p>The zoom case one is a bit harder, the camera need to move along its view axis, but only the eye should move, not the center. We cannot use <code>moveLocal</code> because it moves both the eye and the center. Also we need to be careful to always keep eye != center (but you can ignore that initially and fix it later).</p>
<p>So if we define <code>const auto viewVector = m_camera.center() - m_camera.eye()</code> we want to move the eye along that vector by some amount that depends on the mouse horizontal movement. This gives us a translation vector that we use to compute a new eye position. Then we use this new eye position, the center of the camera and the world up axis to compute a new camera in <code>m_camera</code>.</p>
<p><span class="todo badge"></span> Implement the &quot;zoom&quot; case.</p>
<p>Finally, the most difficult case is the rotate case. Again the center of the camera need to stay the same, and only the eye moves around. For that we need to perform two rotations: one vertical rotation around the horizontal axis of the camera (which can be obtained with <code>m_camera.left()</code>), and then an horizontal rotation around the world up axis.</p>
<p>These two rotations must be done on the vector <code>const auto depthAxis = m_camera.eye() - m_camera.center();</code> that points from the center to the eye. Once totally rotated, we should obtained a new <code>finalDepthAxis</code> that points from the center to the new eye position. The new eye position is then obtained with <code>const auto newEye = m_camera.center() + finalDepthAxis;</code>. We should use this new eye position, the center of the camera and the world up axis to compute a new camera in <code>m_camera</code>.</p>
<p>To perform the rotation, you need to use the <code>rotate</code> function from glm that computes a 4x4 rotation matrix. For example:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> latitudeRotationMatrix = rotate(mat4(<span class="hljs-number">1</span>), latitudeAngle, m_worldUpAxis);
</code></pre>
<p>this code compute a rotation matrix of <code>latitudeAngle</code> radians around <code>m_worldUpAxis</code>.</p>
<p>Since we work with 4x4 rotation matrices, but we have vectors with 3 coordinates, don't forget to convert to vec4, then back to vec3:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> result = vec3(latitudeRotationMatrix * vec4(myVector, <span class="hljs-number">0</span>)); <span class="hljs-comment">// A direction should have 0 on its 4-th coordinate.</span>
</code></pre>
<p><span class="todo badge"></span> Implement the &quot;rotate&quot; case.</p>
<p>Solution:</p>
<ul>
<li><a href="https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/1ca458f242e63991d7ddaf57c2f2567c4698d371">https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/1ca458f242e63991d7ddaf57c2f2567c4698d371</a></li>
</ul>
<blockquote>
<p>An alternative solution that pre-multiplies the two matrices before applying it to the depthAxis (using the first argument of <code>glm::rotate</code>), but this one is not mandatory and probably less readable:</p>
</blockquote>
<ul>
<li><a href="https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/a5ab1d78794ec15a7b0e8b4b428342cebc8fefa2">https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/a5ab1d78794ec15a7b0e8b4b428342cebc8fefa2</a></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="refactoring-and-switching-between-two-controllers"></a><a href="#refactoring-and-switching-between-two-controllers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Refactoring and switching between two controllers</h2>
<p>Our two camera controllers are now very similar, with the same methods. Our drawing code makes use of <code>getCamera()</code>, <code>setCamera()</code> and <code>update()</code>. We can easily introduce an interface <code>CameraController</code> with these three virtual methods and make our two classed inherit from it. That way, we will be able to switch between them from the user interface of the viewer.</p>
<p><span class="todo badge"></span> Add an interface <code>CameraController</code> as base class for <code>FirstPersonCameraController</code> and <code>TrackballCameraController</code>. In these two classes, use the C++11 keywork <code>override</code> to mark the overrided virtual methods.</p>
<p>If we want to easily switch between our two controllers, we need to manipulate a pointer to a <code>CameraController</code> instead of a variable to a concrete type in our <code>run()</code> method. We will use dynamic allocation and <code>std::unique_ptr</code> for that.</p>
<p><span class="todo badge"></span> In <code>run()</code>, replace our <code>TrackballCameraController cameraController</code> with a <code>std::unique_ptr&lt;CameraController&gt; cameraController</code> that should be allocated with the function <code>std::make_unique&lt;TrackballCameraController&gt;</code>.</p>
<p>Solution:</p>
<ul>
<li><a href="https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/c56afb81740bf007fea174154784786c6b80e6e8">https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/c56afb81740bf007fea174154784786c6b80e6e8</a></li>
</ul>
<p>Finally, we will add the possibility to switch between the two controllers using radio buttons in the GUI. To learn how to use functions from ImGui, the best places are:</p>
<ul>
<li>On the internet, search for &quot;ImGUI [THE WIDGET YOU WANT TO USE]&quot;</li>
<li>In the file <code>third-party/imgui-VERSION/imgui_demo.cpp</code>, that provides many examples</li>
</ul>
<p>In my case, I forgot how to use radio buttons with ImGui so I just pressed Ctrl+Shift+F in my editor (VS code), search for &quot;ImGui::RadioButton&quot;, and found examples in <code>imgui_demo.cpp</code>. Easy.</p>
<p>Also keep in mind that most ImGui functions returns <code>true</code> when the widget have been pressed, or changed state.</p>
<p><span class="todo badge"></span> In the GUI, propose a radio button or a dropdown to select either the First Person Camera or the Trackball Camera. When you switch controller, don't forget to assign it the camera of the previous controller.</p>
<p>Solution:</p>
<ul>
<li><a href="https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/8d480aab722830fb9a284c3d43caeb48f0038f7a">https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/8d480aab722830fb9a284c3d43caeb48f0038f7a</a></li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/openglnoel/docs/gltf-viewer-02-gltf-03-drawing"><span class="arrow-prev">← </span><span>Drawing the scene</span></a><a class="docs-next button" href="/openglnoel/docs/gltf-viewer-04-directional-lighting"><span>Directional Lighting</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#the-camera-model">The Camera model</a></li><li><a href="#implementing-a-better-default-camera">Implementing a better default camera</a></li><li><a href="#trackball-camera-controller">Trackball camera controller</a></li><li><a href="#refactoring-and-switching-between-two-controllers">Refactoring and switching between two controllers</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/openglnoel/" class="nav-home"><img src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]" width="66" height="58"/></a><div><h5>About Me</h5><a href="http://laurentnoel.fr">Personal website</a><a href="https://github.com/Celeborn2BeAlive/">Github</a></div><div><h5>About This Website</h5><a href="/openglnoel/blog">Blog</a><a class="github-button" href="https://github.com/celeborn2bealive/openglnoel" data-icon="octicon-star" data-count-href="/celeborn2bealive/openglnoel/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">openglnoel</a><a href="https://docusaurus.io/">Powered by Docusaurus</a></div><div><h5>About OpenGL</h5><a href="docs.gl">Documentation (docs.gl)</a><a href="https://www.khronos.org/opengl/wiki/">Wiki</a></div></section><section class="copyright">Copyright © 2020 Laurent NOEL</section></footer></div></body></html>