<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Directional Lighting · OpenGL[&quot;noël&quot;]</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## Introduction to lighting"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Directional Lighting · OpenGL[&quot;noël&quot;]"/><meta property="og:type" content="website"/><meta property="og:url" content="https://celeborn2bealive.github.io/openglnoel/"/><meta property="og:description" content="## Introduction to lighting"/><meta property="og:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><link rel="shortcut icon" href="/openglnoel/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/atom.xml" title="OpenGL[&quot;noël&quot;] Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/feed.xml" title="OpenGL[&quot;noël&quot;] Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/openglnoel/js/code-block-buttons.js"></script><script type="text/javascript" src="/openglnoel/js/disqus.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/openglnoel/js/scrollSpy.js"></script><link rel="stylesheet" href="/openglnoel/css/main.css"/><script src="/openglnoel/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/openglnoel/"><img class="logo" src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]"/><h2 class="headerTitleWithLogo">OpenGL[&quot;noël&quot;]</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/openglnoel/docs/gltf-viewer-01-intro-01-intro" target="_self">glTF Viewer Tutorial</a></li><li class=""><a href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction" target="_self">Intro et SDK</a></li><li class=""><a href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base" target="_self">Bronze</a></li><li class=""><a href="/openglnoel/docs/silver-01-3d-theorie-01-introduction" target="_self">Silver</a></li><li class=""><a href="/openglnoel/docs/gold-01-intro-sdk-01-introduction" target="_self">Gold</a></li><li class=""><a href="/openglnoel/blog/" target="_self">Blog</a></li><li class=""><a href="http://docs.gl" target="_self">OpenGL Documentation</a></li><li class=""><a href="https://www.khronos.org/opengl/wiki/" target="_self">OpenGL Wiki</a></li><li class=""><a href="https://github.com/celeborn2bealive/openglnoel" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Directional Lighting</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction and SDK</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-01-intro-01-intro">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-01-intro-02-sdk">Software Development Kit</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-01-intro-03-devenv">Development Environment</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Loading and drawing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-02-gltf-01-roadmap">Introduction and roadmap</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-02-gltf-02-initialization">Data initialization</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-02-gltf-03-drawing">Drawing the scene</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Controlling the Camera</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-03-camera-control">Camera Control</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Directional Lighting</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/openglnoel/docs/gltf-viewer-04-directional-lighting">Directional Lighting</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Physically Based Materials</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-05-physically-based-materials">Physically based materials</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Shadow Mapping</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-06-shadow-mapping">WIP - Shadow mapping</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Deferred Rendering</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-07-deferred-rendering">WIP - Deferred rendering</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Post Processing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-08-post-processing">WIP - Post processing</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Directional Lighting</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="introduction-to-lighting"></a><a href="#introduction-to-lighting" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Introduction to lighting</h2>
<p>We will now add a light to our scene and a basic diffuse material model (just to check that our lighting code is working and before implementing the material model of glTF).</p>
<p>The type of light we will implement is the &quot;directional light&quot;. A directional light emits from a single direction all points of the scene. It is a coarse approximation of a distant light like the sun would be for the earth. A directional light can indeed be seen as a point light placed infinitely far and emitting an infinite amount of energy.</p>
<p>Directional lights are said to be &quot;non physically based&quot;, because they are really far from real world lights. Point lights and spot lights are other kinds of non physically based lights.</p>
<p>Examples of physically based lights in other 3D softwares are area lights (with various shapes), environment lights (often described by aa HDR texture) or mesh lights (meshes that act as emitters). These kind of lights are also not perfectly describing the reality, but they are a bit closer (anyway, nothing really describes reality in computer graphics, and what is reality ?).</p>
<h2><a class="anchor" aria-hidden="true" id="fragments-colors"></a><a href="#fragments-colors" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fragments colors</h2>
<p>Our goal is to compute a color for each fragment. A color is physically described by a quantity called <em>radiance</em>. Radiance has a precise physical definition, but for us it will be a quantification of the &quot;amount&quot; of light in a given direction for each red, green and blue component, so a color.</p>
<p>The direction of interest for us is the direction of the 3D position of the fragment to the eye of the camera. In our fragment shaders, this direction can be obtained by the position in the view space:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-type">vec3</span> viewDirection = -vViewSpacePosition; <span class="hljs-comment">// Note that it is unormalized here</span>
</code></pre>
<p>It works because in view space the position of the eye is (0, 0, 0) (in world space, the view direction would be <code>cameraEye - worldSpacePosition</code>).</p>
<p>The point that is being illuminated (the &quot;fragment&quot;) is referred as the &quot;shading point&quot; and described by its position, normal and texture coordinates (the inputs of the fragment shader).</p>
<h2><a class="anchor" aria-hidden="true" id="mathematical-model"></a><a href="#mathematical-model" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mathematical model</h2>
<blockquote>
<p>The model described here is only valid for a single directional light. For multiple directional lights we just need to accumulate the results. For point lights the model is a bit different but not too much. For physically based lights the model includes integrals over the hemisphere of the shading point.</p>
</blockquote>
<p>Let \( \omega_i \) be the lighting direction (a normalized vector of \( \mathbb{R}^3 \)) and let \( \omega_o \) be the view direction (&quot;i&quot; stands for &quot;incoming&quot; and &quot;o&quot; stands for &quot;outgoing&quot;). Let \( L_i \) be the radiance emitted by the directional light (a color also).</p>
<p>The radiance \( L(\omega_o) \)  in the view direction is then expressed by:</p>
<p>$$
L(\omega_o) = f_r(\omega_i, \omega_o)L_i\cos \theta_{n,\omega_i}
$$</p>
<p>In this expression \( f_r(\omega_i, \omega_o) \) is a function called the <em>BRDF</em>, short for <em>bidirectional reflectance distribution function</em>. In the general case, this function is different for every point in the scene, and basically describes the material of each point. It quantify the ratio of &quot;energy&quot; that is transfered from the incoming direction \( \omega_i \) to the outgoing direction \( \omega_o \).</p>
<p>For now we will use a super simple BRDF:</p>
<p>$$
f_r(\omega_i, \omega_o) = (\frac{1}{\pi}, \frac{1}{\pi}, \frac{1}{\pi})
$$</p>
<p>This BRDF gives an approximation of a white diffuse material.</p>
<p>The cosine \( \cos \theta_{n,\omega_i} \) is the cosine of the angle between then normal of the shading point and the lighting direction. It can be obtained with a dot product between the two vectors, provided they are normalized.</p>
<p>With that, we should be able to implement the rendering of our scene with a directional light and allow the user to change its intensity and direction from the GUI.</p>
<h2><a class="anchor" aria-hidden="true" id="the-fragment-shader"></a><a href="#the-fragment-shader" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The fragment shader</h2>
<p><span class="todo badge"></span> Create a new shader &quot;diffuse_directional_light.fs.glsl&quot; in the shaders directory of the source code and implement the above mathematical model. The lighting direction \( \omega_i \) and lighting intensity \( L_i \) should be obtained as uniform variables of the shader. The lighting direction is supposed to be already normalized and expressed in view space, so no need to do complex computations for that (we will do that later in <code>run()</code>). You can take example on other fragment shaders in the directory. For \( \pi \) you can use 3.14.</p>
<blockquote>
<p>Since you are adding a new source file to the project, you will need to re-run cmake (<code>cmake .</code> in the build folder) to take it into account.</p>
</blockquote>
<p><span class="todo badge"></span> In ViewerApplication.hpp, change the default shader &quot;normals.fs.glsl&quot; with your new shader.</p>
<p>If you try it now, you should see a black image.</p>
<p>Solution:</p>
<ul>
<li><a href="https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/03262195840dd0e66e1661188266e8d4c4c3f556">https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/03262195840dd0e66e1661188266e8d4c4c3f556</a></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="send-light-parameters-from-the-application"></a><a href="#send-light-parameters-from-the-application" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Send light parameters from the application</h2>
<p>We now need to send the light parameters from the application. For that we need to get uniform locations with <code>glGetUniformLocation</code> at the begining of <code>run()</code> (like other uniforms).</p>
<p>Then in the render loop we need to set our uniforms with <code>glUniform3f</code>. For the light direction, we must be careful to muliply it with the view matrix, and normalize it, before sending it to the shader. Otherwise, we will see the light move as we move the camera, and that's not what we want of course.</p>
<p>Before the render loop:</p>
<p><span class="todo badge"></span> Get uniforms for light parameters.</p>
<p><span class="todo badge"></span> Declare and initialize two <code>glm::vec3</code> variables <code>lightDirection</code> and <code>lightIntensity</code>.</p>
<p>During the render loop (in <code>drawScene</code> lambda, after getting the view matrix and before the loop over nodes):</p>
<p><span class="todo badge"></span> Send <code>lightIntensity</code> to the shader and transform to view space and normalize <code>lightDirection</code> then pass it to the shader. However, before sending the data, check if the location are not negative (it can happen if we use another shader than our lighting fragment shader).</p>
<p>Solution:</p>
<ul>
<li><a href="https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/9bbad4eacaaf8b2820f32c7e44d14cd851e8a3bc">https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/9bbad4eacaaf8b2820f32c7e44d14cd851e8a3bc</a></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="control-the-light-from-the-gui"></a><a href="#control-the-light-from-the-gui" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Control the light from the GUI</h2>
<p>Our light direction is expressed as a vector, but it is not really intuitive to set from a GUI. A better control can be done with two angles (spherical coordinates), to convert to a direction with the following equation:</p>
<p>$$
\omega_i = (\sin \theta \cos \phi, \cos \theta, \sin \theta \sin \phi)
$$</p>
<p><span class="todo badge"></span> In the GUI, add a new section &quot;Light&quot; (with  <code>ImGui::CollapsingHeader()</code>) containing two sliders for \( \theta \) (between 0 and \( \pi \)) and \( \phi \) (between 0 and \( 2\pi \)) angles. When they are changed, compute <code>lightDirection</code> from them using the above formula.</p>
<p>For the intensity, it is better to give the user the possibility of choosing a color and a scalar intensity, then to multiply both before sending it to the shader.</p>
<p><span class="todo badge"></span> Add a <code>ImGui::ColorEdit3</code> to specify a color and an input float for the intensity factor. If they are changed, update <code>lightIntensity</code> with their product.</p>
<p>Solution:</p>
<ul>
<li><a href="https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/ea7420667a899d33d613754fc40404da50d58fae">https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/ea7420667a899d33d613754fc40404da50d58fae</a></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="lighting-from-camera"></a><a href="#lighting-from-camera" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lighting from camera</h2>
<p>It can sometimes be useful to emit light from the camera instead of a fixed direction. It is kind of easy from the code: just send the negative view direction <code>-camera.front()</code> to the light direction uniform instead of <code>lightDirection</code>. Actually, this is even easier in our case because we are doing calculations in view space: just send (0, 0, 1), since in view space the view direction is the negative z axis.</p>
<p><span class="todo badge"></span> Add a checkbox &quot;light from camera&quot; that control a boolean. If set, then send (0, 0, 1) instead of <code>lightDirection</code> in the drawing function for the uniform controlling the light direction.</p>
<p>Solution:</p>
<ul>
<li><a href="https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/59625f2a0cdd7ac22ee82a54ec5a9752c267cbeb">https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/59625f2a0cdd7ac22ee82a54ec5a9752c267cbeb</a></li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/openglnoel/docs/gltf-viewer-03-camera-control"><span class="arrow-prev">← </span><span>Camera Control</span></a><a class="docs-next button" href="/openglnoel/docs/gltf-viewer-05-physically-based-materials"><span>Physically based materials</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#introduction-to-lighting">Introduction to lighting</a></li><li><a href="#fragments-colors">Fragments colors</a></li><li><a href="#mathematical-model">Mathematical model</a></li><li><a href="#the-fragment-shader">The fragment shader</a></li><li><a href="#send-light-parameters-from-the-application">Send light parameters from the application</a></li><li><a href="#control-the-light-from-the-gui">Control the light from the GUI</a></li><li><a href="#lighting-from-camera">Lighting from camera</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/openglnoel/" class="nav-home"><img src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]" width="66" height="58"/></a><div><h5>About Me</h5><a href="http://laurentnoel.fr">Personal website</a><a href="https://github.com/Celeborn2BeAlive/">Github</a></div><div><h5>About This Website</h5><a href="/openglnoel/blog">Blog</a><a class="github-button" href="https://github.com/celeborn2bealive/openglnoel" data-icon="octicon-star" data-count-href="/celeborn2bealive/openglnoel/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">openglnoel</a><a href="https://docusaurus.io/">Powered by Docusaurus</a></div><div><h5>About OpenGL</h5><a href="docs.gl">Documentation (docs.gl)</a><a href="https://www.khronos.org/opengl/wiki/">Wiki</a></div></section><section class="copyright">Copyright © 2020 Laurent NOEL</section></footer></div></body></html>