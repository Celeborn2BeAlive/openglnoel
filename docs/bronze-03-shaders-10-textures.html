<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Textures · OpenGL[&quot;noël&quot;]</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;L&#x27;objectif est à présent d&#x27;appliquer une texture aux triangles. Téléchargez le fichier &lt;a href=&quot;/openglnoel/docs/assets/triforce.png&quot;&gt;triforce.png&lt;/a&gt; et placez le dans un répertoire nommé assets/textures à la racine de votre répertoire de TP.&lt;/p&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Textures · OpenGL[&quot;noël&quot;]"/><meta property="og:type" content="website"/><meta property="og:url" content="https://celeborn2bealive.github.io/openglnoel/index.html"/><meta property="og:description" content="&lt;p&gt;L&#x27;objectif est à présent d&#x27;appliquer une texture aux triangles. Téléchargez le fichier &lt;a href=&quot;/openglnoel/docs/assets/triforce.png&quot;&gt;triforce.png&lt;/a&gt; et placez le dans un répertoire nommé assets/textures à la racine de votre répertoire de TP.&lt;/p&gt;
"/><meta property="og:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><link rel="shortcut icon" href="/openglnoel/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/atom.xml" title="OpenGL[&quot;noël&quot;] Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/feed.xml" title="OpenGL[&quot;noël&quot;] Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/openglnoel/js/code-block-buttons.js"></script><script type="text/javascript" src="/openglnoel/js/disqus.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><link rel="stylesheet" href="/openglnoel/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/openglnoel/"><img class="logo" src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]"/><h2 class="headerTitleWithLogo">OpenGL[&quot;noël&quot;]</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction" target="_self">Introduction et SDK</a></li><li class="siteNavGroupActive"><a href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base" target="_self">Bronze</a></li><li class=""><a href="/openglnoel/docs/silver-01-3d-theorie-01-introduction" target="_self">Silver</a></li><li class=""><a href="/openglnoel/docs/gold-01-intro-sdk-01-introduction" target="_self">Gold</a></li><li class=""><a href="/openglnoel/blog/" target="_self">Blog</a></li><li class=""><a href="http://docs.gl" target="_self">OpenGL Documentation</a></li><li class=""><a href="https://www.khronos.org/opengl/wiki/" target="_self">OpenGL Wiki</a></li><li class=""><a href="https://github.com/celeborn2bealive/openglnoel" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Les shaders</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Hello Triangle</h3><ul><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base">Le code de base</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-02-hello-triangle-02-triangle-blanc">Dessiner un triangle blanc</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-02-hello-triangle-03-triangle-couleurs">Dessiner un triangle en couleurs</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-02-hello-triangle-04-vertex-structure">Utiliser une structure de vertex</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-02-hello-triangle-05-dessiner-quad">Dessiner un quad</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-02-hello-triangle-06-dessiner-disque">Dessiner un disque</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-02-hello-triangle-07-index-buffers">Utiliser les buffers d&#x27;index</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Les shaders</h3><ul><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-01-kesako">Shaders, kesako ?</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-02-exemple">Les shaders par l&#x27;exemple</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-03-compilation">Charger, compiler et utiliser</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-04-jouer">Jouer avec les shaders</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-05-mandelbrot">Mandelbrot</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-06-la-suite">Préparer la suite</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-07-triangle-tourne">Un triangle qui tourne</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-08-matrices">Envoyer des matrices</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-09-plusieurs-triangles">Plusieur triangles</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-10-textures">Textures</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Textures</h1></header><article><div><span><p>L'objectif est à présent d'appliquer une texture aux triangles. Téléchargez le fichier <a href="/openglnoel/docs/assets/triforce.png">triforce.png</a> et placez le dans un répertoire nommé assets/textures à la racine de votre répertoire de TP.</p>
<h2><a class="anchor" aria-hidden="true" id="charger-l-image"></a><a href="#charger-l-image" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Charger l'image</h2>
<p>La fonction <strong>loadImage</strong> déclarée dans le fichier <strong>glimac/Image.hpp</strong> vous permet de charger une image depuis le disque. Cette fonction renvoit un <strong>std::unique_ptr<Image></strong> (pointeur sur une image qui désalloue sa mémoire tout seul dans son destructeur).</p>
<p><span class="badge todo"></span> En utilisant cette fonction, chargez la texture de triforce (utilisez le chemin absolu vers le fichier). Vérifiez que le chargement a bien réussi en testant si le pointeur renvoyé vaut NULL. Le chargement de la texture doit être fait avant la boucle de rendu (par exemple juste avant le chargement des shaders).</p>
<p><span class="badge warning"></span> Dans un vrai moteur on n'utilise pas des chemins absolus vers les fichier: on s'arrange pour que les assets soient situés relativement par rapport à l'executable et on les charge en utilisant le chemin de l'executable (c'est ce qui est fait pour les shaders dans votre code). J'ai décidé de ne pas faire copier au CMake les assets à coté de l'executable car ces derniers peuvent être gros (comparé à un shader) et votre place en mémoire est limitée sur les machine de la fac.</p>
<h2><a class="anchor" aria-hidden="true" id="creer-un-texture-object-opengl"></a><a href="#creer-un-texture-object-opengl" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Créer un texture object OpenGL</h2>
<p>Il faut ensuite envoyer la texture à la carte graphique. Pour cela OpenGL propose les texture objects.</p>
<p><span class="badge todo"></span> En utilisant la fonction <a href="http://docs.gl/gl3/glGenTextures">glGenTextures</a>, créez un nouveau texture object.</p>
<p><span class="badge todo"></span> A l'aide de la fonction <a href="http://docs.gl/gl3/glBindTexture">glBindTexture</a>, bindez la texture sur la cible <strong>GL_TEXTURE_2D</strong>.</p>
<p><span class="badge todo"></span> Utilisez ensuite la fonction <a href="http://docs.gl/gl3/glTexImage2D">glTexImage2D</a> pour envoyer l'image à la carte graphique afin qu'elle soit stockée dans votre texture object. Pour cela il faut utiliser les membres suivants de la classe Image: <strong>pImage-&gt;getWidth()</strong> pour obtenir la largeur, <strong>pImage-&gt;getHeight()</strong> pour obtenir la hauteur et <strong>pImage-&gt;getPixels()</strong> pour obtenir le tableau de pixels. La fonction <strong>glTexImage2D</strong> prend également en paramètre des formats (internalFormat et format), passez lui pour ces deux paramètres la constante <strong>GL_RGBA</strong>. Le paramètre <strong>type</strong> doit être <strong>GL_FLOAT</strong> car la classe Image stocke ses pixels en flottants. Enfin les paramètres <strong>level</strong> et <strong>border</strong> doivent être mis à 0.</p>
<p><span class="badge todo"></span> Afin de pouvoir utiliser une texture, il faut spécifier à OpenGL des filtres que ce dernier appliquera lorsque 1) plusieurs pixels à l'écran sont couvert par un pixel de texture et 2) un pixel à l'écran couvre plusieurs pixels de texture. Rajoutez les lignes suivantes:</p>
<pre><code class="hljs css language-cpp">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
</code></pre>
<p>Ces deux lignes permettent d'appliquer un filtre linéaire dans les deux cas cités plus haut. Référez vous à la documentation si vous êtes interessé par d'autres filtres.</p>
<p><span class="badge todo"></span> Débindez la texture en utilisant <a href="http://docs.gl/gl3/glBindTexture">glBindTexture</a> avec 0 passé en deuxième paramètre.</p>
<p><span class="badge todo"></span> A la fin du programme, ajoutez un appel à <a href="http://docs.gl/gl3/glDeleteTextures">glDeleteTextures</a> afin de détruire le texture object.</p>
<h2><a class="anchor" aria-hidden="true" id="specifier-les-coordonnees-de-texture"></a><a href="#specifier-les-coordonnees-de-texture" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spécifier les coordonnées de texture</h2>
<p>Jusqu'a présent nous avions mis les coordonnées de texture des vertex à \((0,0)\). Il faut les changer afin que chaque vertex soit associé au bon pixel dans la texture. Voici un schéma indiquant les coordonnées de texture à associer à chaque vertex:</p>
<p><img src="/openglnoel/img/texture_shema.png" alt="Texture schema"></p>
<p>Le coin haut-gauche a pour coordonnées \((0,0)\) et le coin bas-droit \((1,1)\) (quelque soit les dimensions de l'image d'entrée).</p>
<p><span class="badge todo"></span> Dans le tableau de sommets, modifiez les coordonnées de texture de chacun des sommets à partir du schéma ci dessus.</p>
<h2><a class="anchor" aria-hidden="true" id="utiliser-la-texture-dans-le-shader"></a><a href="#utiliser-la-texture-dans-le-shader" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Utiliser la texture dans le shader</h2>
<p>Une texture s'utilise dans un fragment shader en utilisant une variable uniforme de type <strong>sampler2D</strong>.</p>
<p><span class="badge todo"></span> Ajoutez une variable uniforme nommée <strong>uTexture</strong> dans votre fragment shader.</p>
<p>Il est ensuite possible de lire dans la texture en utilisant la fonction GLSL <strong>texture(sampler, texCoords)</strong>. Le premier paramètre est le sampler2D (<strong>uTexture</strong> dans notre shader) et le deuxième paramètre les coordonnées de texture du fragment. Ces dernières doivent être récupérée en entrée du fragment shader depuis le vertex shader (comme nous faisions au TP précédent pour la couleur et la position).</p>
<p><span class="badge todo"></span> Faite en sorte que la couleur affichée par le fragment shader soit celle lue depuis la texture à la bonne position. Attention: la fonction <strong>texture</strong> renvoit un <strong>vec4</strong>, il faut donc le transformer en <strong>vec3</strong> si votre variable de sortie du fragment shader est de type <strong>vec3</strong>.</p>
<h2><a class="anchor" aria-hidden="true" id="specifier-la-valeur-de-la-variable-uniforme"></a><a href="#specifier-la-valeur-de-la-variable-uniforme" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spécifier la valeur de la variable uniforme</h2>
<p><span class="badge todo"></span> Dans le code de l'application, récupérez la location de la variable uniforme en utilisant <strong>glGetUniformLocation</strong></p>
<p>Les sampler GLSL sont en réalité des entiers. Il faut les remplir à l'indice de l'unité de texture sur laquelle est branchée la texture voulue. Nous verrons plus tard les unités de texture, pour l'instant nous en utilisons une sans nous en rendre compte: l'unité de texture 0. Il faut donc remplir la variable uniforme avec la valeur 0 en utilisant la fonction <strong>glUniform1i</strong>.</p>
<p><span class="badge todo"></span> Dans la boucle de rendu, avant l'appel à <strong>glDrawArrays</strong>: bindez la texture sur la cible <strong>GL_TEXTURE_2D</strong>, puis fixez la valeur de la variable uniforme <strong>uTexture</strong> à 0. Après l'appel à <strong>glDrawArrays</strong>, débindez la texture. Testez votre programme: les triangles doivent à présent être texturés.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/openglnoel/docs/bronze-03-shaders-09-plusieurs-triangles"><span class="arrow-prev">← </span><span>Plusieur triangles</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#charger-l-image">Charger l'image</a></li><li><a href="#creer-un-texture-object-opengl">Créer un texture object OpenGL</a></li><li><a href="#specifier-les-coordonnees-de-texture">Spécifier les coordonnées de texture</a></li><li><a href="#utiliser-la-texture-dans-le-shader">Utiliser la texture dans le shader</a></li><li><a href="#specifier-la-valeur-de-la-variable-uniforme">Spécifier la valeur de la variable uniforme</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/openglnoel/" class="nav-home"><img src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]" width="66" height="58"/></a><div><h5>About Me</h5><a href="http://laurentnoel.fr">Personal website</a><a href="https://github.com/Celeborn2BeAlive/">Github</a></div><div><h5>About This Website</h5><a href="/openglnoel/blog">Blog</a><a class="github-button" href="https://github.com/celeborn2bealive/openglnoel" data-icon="octicon-star" data-count-href="/celeborn2bealive/openglnoel/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">openglnoel</a><a href="https://docusaurus.io/">Powered by Docusaurus</a></div><div><h5>About OpenGL</h5><a href="docs.gl">Documentation (docs.gl)</a><a href="https://www.khronos.org/opengl/wiki/">Wiki</a></div></section><section class="copyright">Copyright © 2019 Laurent NOEL</section></footer></div></body></html>