<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Data initialization · OpenGL[&quot;noël&quot;]</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="The first part of the `run()` method should be data initialization. It already contains a bit of code, which are:"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Data initialization · OpenGL[&quot;noël&quot;]"/><meta property="og:type" content="website"/><meta property="og:url" content="https://celeborn2bealive.github.io/openglnoel/"/><meta property="og:description" content="The first part of the `run()` method should be data initialization. It already contains a bit of code, which are:"/><meta property="og:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><link rel="shortcut icon" href="/openglnoel/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/atom.xml" title="OpenGL[&quot;noël&quot;] Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/feed.xml" title="OpenGL[&quot;noël&quot;] Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/openglnoel/js/code-block-buttons.js"></script><script type="text/javascript" src="/openglnoel/js/disqus.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/openglnoel/js/scrollSpy.js"></script><link rel="stylesheet" href="/openglnoel/css/main.css"/><script src="/openglnoel/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/openglnoel/"><img class="logo" src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]"/><h2 class="headerTitleWithLogo">OpenGL[&quot;noël&quot;]</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/openglnoel/docs/gltf-viewer-01-intro-01-intro" target="_self">glTF Viewer Tutorial</a></li><li class=""><a href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction" target="_self">Intro et SDK</a></li><li class=""><a href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base" target="_self">Bronze</a></li><li class=""><a href="/openglnoel/docs/silver-01-3d-theorie-01-introduction" target="_self">Silver</a></li><li class=""><a href="/openglnoel/docs/gold-01-intro-sdk-01-introduction" target="_self">Gold</a></li><li class=""><a href="/openglnoel/blog/" target="_self">Blog</a></li><li class=""><a href="http://docs.gl" target="_self">OpenGL Documentation</a></li><li class=""><a href="https://www.khronos.org/opengl/wiki/" target="_self">OpenGL Wiki</a></li><li class=""><a href="https://github.com/celeborn2bealive/openglnoel" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Loading and drawing</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction and SDK</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-01-intro-01-intro">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-01-intro-02-sdk">Software Development Kit</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-01-intro-03-devenv">Development Environment</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Loading and drawing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-02-gltf-01-roadmap">Introduction and roadmap</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/openglnoel/docs/gltf-viewer-02-gltf-02-initialization">Data initialization</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-02-gltf-03-drawing">Drawing the scene</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Controlling the Camera</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-03-camera-control">Camera Control</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Directional Lighting</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-04-directional-lighting">Directional Lighting</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Physically Based Materials</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-05-physically-based-materials">WIP - Physically based materials</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Shadow Mapping</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-06-shadow-mapping">WIP - Shadow mapping</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Deferred Rendering</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-07-deferred-rendering">WIP - Deferred rendering</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Post Processing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gltf-viewer-08-post-processing">WIP - Post processing</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Data initialization</h1></header><article><div><span><p>The first part of the <code>run()</code> method should be data initialization. It already contains a bit of code, which are:</p>
<ul>
<li>Loading of the shaders and initialization of uniform locations</li>
<li>Creation of projection and view matrix</li>
<li>Setup GL state for 3D</li>
</ul>
<p>Our goal for this part of the tutorial is to implement things related to glTF data. We'll come back later on the previous points. Put your code before what is already in the function.</p>
<h2><a class="anchor" aria-hidden="true" id="loading-the-gltf-file"></a><a href="#loading-the-gltf-file" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Loading the glTF file</h2>
<blockquote>
<p>The part to replace in this section is <code>// TODO Loading the glTF file</code> with a call to the method that you must implement.</p>
</blockquote>
<p>The path to the glTF file is stored in the member variable <code>m_gltfFilePath</code>.</p>
<p>A glTF file is just a json file with references to binary files to store geometry data and images to store textures.</p>
<p>The tinygltf library is included in the project and can parse the json for us, as well as loading data from referenced file.</p>
<p><span class="todo badge"></span> Implement a method <code>bool loadGltfFile(tinygltf::Model &amp; model);</code> that should use <code>m_gltfFilePath.string()</code> to load the correct file into the model structure. The method return value should correspond to what gltf returns. If there is errors or warning, print them.</p>
<p>For that, use the readme of the tinygltf repository <a href="https://github.com/syoyo/tinygltf">https://github.com/syoyo/tinygltf</a></p>
<p><span class="todo badge"></span> In the run() method, define a <code>tinygltf::Model</code> instance and call your method on it.</p>
<p>Another place to look at for tinygltf documentation is simply the file &quot;tiny_gltf.h&quot; stored in third-party/tinygltf/.</p>
<p><span class="todo badge"></span> Check compilation, run, commit and push your code.</p>
<hr>
<p>Solution (two commits):</p>
<ul>
<li><a href="https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/4e703149aa559e2df1857e66a06784c1ce2fa310">https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/4e703149aa559e2df1857e66a06784c1ce2fa310</a></li>
<li><a href="https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/499663004ccb2a7b0acb8aeab67749558b7c1141">https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/499663004ccb2a7b0acb8aeab67749558b7c1141</a></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="understanding-gltf-data"></a><a href="#understanding-gltf-data" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Understanding glTF data</h2>
<p>The glTF format is precisely defined on its dedicated repository: <a href="https://github.com/KhronosGroup/glTF">https://github.com/KhronosGroup/glTF</a></p>
<p>No other resource is needed to understand and use the format.</p>
<p>The first file to look at is a quick reference card: <a href="https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/figures/gltfOverview-2.0.0b.png">https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/figures/gltfOverview-2.0.0b.png</a> (open it in new tab or download it to zoom on it).</p>
<p>It gives a large overview of how a scene is described by a glTF file is described and is most often enough.</p>
<p>When more precise explanation are required, as well as exact type information and knowing if a field is optional or required, the specification is here: <a href="https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md">https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md</a></p>
<p>Even is reading the full document would be a good idea to deeply understand the format, if you are in a hurry you should use and abuse CTRL+F to find useful information about the fields you will use.</p>
<p>Most of the fields of a glTF file (&quot;buffers&quot;, &quot;nodes&quot;, etc) are directly available in the <code>tinygltf::Model</code> instance. An exception I found for now is <code>scene</code> which is stored in <code>model.defaultScene</code> (and I don't know why). Other exceptions are buffer and texture data, that are stored in buffers. Again look at the file <code>tiny_gltf.h</code> for all structures definitions. The relationship with glTF specification is pretty obvious.</p>
<p><span class="todo badge"></span> Take a look at the quick reference card and try to understand the sections &quot;Concepts&quot;, &quot;scenes, nodes&quot;, &quot;meshes&quot; and &quot;buffers, bufferViews, accessors&quot;. We will start by focusing on these.</p>
<h3><a class="anchor" aria-hidden="true" id="buffer-objects-and-vertex-array-objects"></a><a href="#buffer-objects-and-vertex-array-objects" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Buffer Objects and Vertex Array Objects</h3>
<p>To understand the close relationship between glTF data and OpenGL, a reminder about Vertex/Index Buffer Objects (VBO, IBO) and Vertex Array Objects (VAOs) can help.</p>
<p>To be rendered on the GPU, geometry data is stored in buffer objects. Buffers objects correspond to buffers allocated on the GPU's memory, for quick access by the GPU.</p>
<p>A buffer object can be created with the following code:</p>
<pre><code class="hljs css language-cpp">GLuint bufferObject = <span class="hljs-number">0</span>; <span class="hljs-comment">// 0 represents a "null" buffer object, it does not exist yet</span>
glGenBuffers(<span class="hljs-number">1</span>, &amp;bufferObject); <span class="hljs-comment">// Ask opengl to reserve an identifier for our buffer object and store it in bufferObject.</span>
<span class="hljs-comment">// At this point we should have bufferObject &gt; 0. </span>
<span class="hljs-comment">// We generally don't test for that, if it happens our program is likely to fail anyway.</span>
glBindBuffer(GL_ARRAY_BUFFER, bufferObject); <span class="hljs-comment">// A buffer must be bound to be used</span>
glBufferStorage(GL_ARRAY_BUFFER, data.size(), data.data(), <span class="hljs-number">0</span>); <span class="hljs-comment">// Assuming data is a std::vector containing some data</span>
glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>); <span class="hljs-comment">// Generally a good idea to cleanup the binding point after</span>
</code></pre>
<blockquote>
<p>Here we use glBufferStorage instead of glBufferData, which could also be used. The difference is that once a buffer has been allocated with glBufferStorage, you cannot change its size anymore. Knowing the buffer will remain the same size might give to the driver the opportunity to do some optimizations.</p>
</blockquote>
<p>Similarly we can create multiple buffer objects and fill them with a loop:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;GLuint&gt; <span class="hljs-title">bufferObjects</span><span class="hljs-params">(buffers.size(), <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// Assuming buffers is a std::vector of Buffer</span>
glGenBuffers(buffers.size(), bufferObjects.data());
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; buffers.size(); ++i) {
  glBindBuffer(GL_ARRAY_BUFFER, bufferObjects[i]);
  glBufferStorage(GL_ARRAY_BUFFER, buffers[i].data.size(), <span class="hljs-comment">// Assume a Buffer has a data member variable of type std::vector</span>
      buffers[i].data.data(), <span class="hljs-number">0</span>);
}
glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>); <span class="hljs-comment">// Cleanup the binding point after the loop only</span>
</code></pre>
<p>For clarity, we call a buffer object used to store vertex data (positions, normals, texture coordinates, ...) a vertex buffer object (VBO) and a buffer object used to stored index data an index buffer object (IBO).</p>
<p>OpenGL can't do anything with buffer objects: they are just bytes of data for OpenGL. Like a <code>void*</code> and a byte size would just be a pointer to an area of memory with a specific size. We can't do nothing with it if we don't know the structure of the data inside.</p>
<p>For OpenGL to correctly interpret the data, we need to describe its structure. And for that we use <strong>Vertex Array Objects</strong> (VAOs). A VAO is used to describe the data of a primitive to draw (a primitive can be composed of triangles, points or lines). A primitive is described by its vertices, and each vertex is defined by vertex attributes.</p>
<p>So the VAO of a primitive describes:</p>
<ul>
<li>What vertex attributes (position, normal, ...) are enabled. Each one identified by an index (that we generally choose based on our shaders, more on that later).</li>
<li>For each vertex attribute, what buffer object store its data, and how to read it (what type, how much components per attribute, where the data starts, how much bytes there is between 2 attributes).</li>
<li>If the primitive has indices, what buffer object stores the indices and what is the type used (uint8, uint16 or uint32).</li>
</ul>
<p>Now it is up to us to decide how we split our data in buffer objects:</p>
<ul>
<li>Should we use one or multiple buffer objects for our vertex attributes ?</li>
<li>Should we pack or interleave the data ?</li>
</ul>
<p>For our application, we actually don't really care: we will just follow what the glTF file tells us.</p>
<p>Here is a piece of code to create a fill a vertex array object:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-comment">// Each vertex attribute is identified by an index</span>
<span class="hljs-comment">// What vertex attribute we use, and what are their index is defined by the vertex shader</span>
<span class="hljs-comment">// we will use (more information later).</span>
<span class="hljs-comment">// position, normal and texcoord is pretty standard for 3D applications</span>
<span class="hljs-keyword">const</span> GLuint VERTEX_ATTRIB_POSITION_IDX = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> GLuint VERTEX_ATTRIB_NORMAL_IDX = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> GLuint VERTEX_ATTRIB_TEXCOORD0_IDX = <span class="hljs-number">2</span>;

GLint vertexArrayObject = <span class="hljs-number">0</span>;
glGenVertexArrays(<span class="hljs-number">1</span>, &amp;vertexArrayObject);
glBindVertexArray(vertexArrayObject);
<span class="hljs-comment">// Tell OpenGL we use this index:</span>
glEnableVertexAttribArray(VERTEX_ATTRIB_POSITION_IDX);
<span class="hljs-comment">// Assume positionBufferObject is previously created buffer object</span>
<span class="hljs-comment">// storing our positions</span>
glBindBuffer(GL_ARRAY_BUFFER, positionBufferObject);
<span class="hljs-comment">// Tell OpenGL to use the buffer object currently bound to GL_ARRAY_BUFFER</span>
<span class="hljs-comment">// and how to read data from it: 3 float per position, starting at positionByteOffset, and each next position</span>
<span class="hljs-comment">// being positionByteStride bytes later from the current one</span>
glVertexAttribPointer(VERTEX_ATTRIB_POSITION_IDX, GL_FLOAT, <span class="hljs-number">3</span>, GL_FALSE, 
  positionByteStride, (<span class="hljs-keyword">const</span> GLvoid*)positionByteOffset);

glBindBuffer(GL_ARRAY_BUFFER, normalBufferObject);
glEnableVertexAttribArray(VERTEX_ATTRIB_NORMAL_IDX);
glVertexAttribPointer(VERTEX_ATTRIB_NORMAL_IDX, GL_FLOAT, <span class="hljs-number">3</span>, GL_FALSE, 
  normalByteStride, (<span class="hljs-keyword">const</span> GLvoid*)normalByteOffset);

glEnableVertexAttribArray(VERTEX_ATTRIB_TEXCOORD0_IDX);
<span class="hljs-comment">// Note the 2 here, tex coords are generally 2 floats only:</span>
glVertexAttribPointer(VERTEX_ATTRIB_TEXCOORD0_IDX, GL_FLOAT, <span class="hljs-number">2</span>, GL_FALSE, 
  texCoordsByteStride, (<span class="hljs-keyword">const</span> GLvoid*)texCoordsByteOffset);

<span class="hljs-comment">// Tell OpenGL we use an index buffer for this primitive:</span>
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBufferObject);

<span class="hljs-comment">// End the description of our vertex array object:</span>
glBindVertexArray(<span class="hljs-number">0</span>);
</code></pre>
<p>Keep the documentation <a href="http://docs.gl/">http://docs.gl/</a> open because you will likely need it.</p>
<h3><a class="anchor" aria-hidden="true" id="relationship-between-gltf-data-and-opengl-data"></a><a href="#relationship-between-gltf-data-and-opengl-data" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Relationship between glTF data and OpenGL data</h3>
<p>If you look at the part &quot;buffers, bufferView, accessors&quot; of the quick reference card or glTF, you might start to notice some connexion with VBOs, IBOs and VAOs.</p>
<p>A good way to vizualize the relationshop between buffer, bufferView and accessor is to use the glTF-Sample-Models repository. For simple models they provide a picture illustrating the data layout, look at the end of each page:</p>
<ul>
<li><a href="https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/TriangleWithoutIndices">https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/TriangleWithoutIndices</a></li>
<li><a href="https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/Triangle">https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/Triangle</a></li>
<li><a href="https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/SimpleMeshes">https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/SimpleMeshes</a></li>
</ul>
<p>For reference, here is the image from the quick reference card:
<img src="/openglnoel/img/gltf/buffers_bufferView_accessors.png" alt="buffers_bufferView_accessors"></p>
<hr>
<p>The &quot;buffers&quot; stores a list of buffer, each one containing the data that must fill a buffer object. With tinygtlf we can access <code>model.buffers[i]</code> which has type <code>tinygltf::Buffer</code>.</p>
<p>A <code>tinygltf::Buffer</code> has a member variable <code>std::vector&lt;unsigned char&gt; data</code>. So we have <code>model.buffers[i].data.size()</code> which is the &quot;byteLength&quot; field of the i-th buffer defined in the glTF file, and <code>model.buffers[i].data.data()</code> which is a pointer to the raw data loaded by tinygltf.</p>
<p>You can notice the <code>unsigned char</code> type used for the vector. An <code>unsigned char</code> is 1 byte of data (from the C specification), so it basically mean that we have a buffer of data but we don't really know what is inside, how to read the data, exactly like the GPU for a simple buffer object.</p>
<hr>
<p>Then we have &quot;bufferViews&quot;, storing a list of buffer views. You can see it looks like this in json:</p>
<pre><code class="hljs css language-js"><span class="hljs-string">"bufferViews"</span>: [
  {
    <span class="hljs-string">"buffer"</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">"byteOffset"</span>: <span class="hljs-number">4</span>,
    <span class="hljs-string">"byteLength"</span>: <span class="hljs-number">28</span>,
    <span class="hljs-string">"byteStride"</span>: <span class="hljs-number">12</span>,
    <span class="hljs-string">"target"</span>: <span class="hljs-number">34963</span>
  }
]
</code></pre>
<p>Ok this look a bit like a part of a Vertex Array Object. We have the index of a buffer to bind. This index refers to an index of the array in <code>model.buffers</code>.</p>
<p>The strange &quot;34963&quot; correspond to a binding target for the buffer. Here is is GL_ELEMENT_ARRAY_BUFFER (if you print it in your program you'll see the value is indeed 34963), so the buffer view must correspond to an index buffer object.</p>
<p>The other parameters look like some parameters we pass to <code>glVertexAttribPointer</code>. Remember the prototype:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">glVertexAttribPointer</span><span class="hljs-params">(
  GLuint index, 
    GLint size,
    GLenum type,
    GLboolean normalized,
    GLsizei stride, <span class="hljs-comment">// Correspond to byteStride</span>
    <span class="hljs-keyword">const</span> GLvoid * pointer)</span> <span class="hljs-comment">// Correspond to byteOffset, almost...</span>
</span></code></pre>
<p>However we miss some arguments. To fill the gap we have the concept of &quot;accessors&quot;. Lets take look on the example from the quick reference card:</p>
<pre><code class="hljs css language-js"><span class="hljs-string">"accessors"</span>: [
  {
    <span class="hljs-string">"bufferView"</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">"byteOffset"</span>: <span class="hljs-number">4</span>,
    <span class="hljs-string">"type"</span>: <span class="hljs-string">"VEC2"</span>
    <span class="hljs-string">"componentType"</span>: <span class="hljs-number">5126</span>,
    <span class="hljs-string">"count"</span>: <span class="hljs-number">2</span>,
    <span class="hljs-string">"min"</span>: [<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>],
    <span class="hljs-string">"max"</span>: [<span class="hljs-number">0.9</span>, <span class="hljs-number">0.8</span>]
  }
]
</code></pre>
<p>This seem to describe the missing parameters, more or less. Again the strange 5126 correspond to a OpenGL enum. Here it is GL_FLOAT (meaning that the example of the quick ref card is invalid: the accessor tells we have float data, but the bufferView ask to bind it GL_ELEMENT_ARRAY_BUFFER, which is basically invalid because we need integer data on GL_ELEMENT_ARRAY_BUFFER).</p>
<p>The byteOffset of the accessor must be combined with the byteOffset of the buffer view to get the last argument of glVertexAttribPointer.</p>
<p>The type and componentType should be used to compute &quot;size&quot; and &quot;type&quot; parameters. For that we can thank tinygltf because it parse them and gives us &quot;accessor.type&quot; for &quot;size&quot; (wtf ?) and &quot;accessor.componentType&quot; for &quot;type&quot;.</p>
<p>What about the other parameters ? &quot;count&quot; is the number of values to read from the buffer view and we'll be used at render time to specify the number of vertices to draw. &quot;min&quot; and &quot;max&quot; are here to get bounds on the data and normalize it if we want (we won't use them).</p>
<p>OK, this is a bit complicated, but we have the following relationship:</p>
<ul>
<li>glTF Buffer &lt;-&gt; OpenGL Buffer Object</li>
<li>glTF Buffer View + glTF Accessor &lt;-&gt; part of OpenGL Vertex Array (only describe one vertex attributes)</li>
</ul>
<p>To get all vertex attributes, we need to look at the &quot;meshes&quot; section of the quick reference card, we have this:</p>
<pre><code class="hljs css language-js"><span class="hljs-string">"meshes"</span>: [
  {
    <span class="hljs-string">"primitives"</span>: [
      {
        <span class="hljs-string">"mode"</span>: <span class="hljs-number">4</span>,
        <span class="hljs-string">"indices"</span>: <span class="hljs-number">0</span>,
        <span class="hljs-string">"attributes"</span>: {
          <span class="hljs-string">"POSITION"</span>: <span class="hljs-number">1</span>,
          <span class="hljs-string">"NORMAL"</span>: <span class="hljs-number">2</span>
        },
        <span class="hljs-string">"material"</span>: <span class="hljs-number">2</span>
      }
    ]
  }
]
</code></pre>
<p>This tells us that a mesh is defined by a list of primitives. In a given primitive we have:</p>
<ul>
<li>&quot;mode&quot;, again a GL enum that correspond to GL_TRIANGLES, GL_POINTS or GL_LINES</li>
<li>&quot;indices&quot;, the index of an accessor that must be used to obtain indices of the primitive. It is optional, and if not present the primitive has no indices.</li>
<li>&quot;attributes&quot;, an object with a field for each vertex attribute composing the primitive. All are optional. The index specified for each one is the index of an accessor that must be used to get the vertex attribute data.</li>
<li>&quot;material&quot;, we don't care for now but we'll use it in a later part of the tutorial</li>
</ul>
<p>All possible vertex attributes are defined in <a href="https://github.com/KhronosGroup/glTF/tree/master/specification/2.0">https://github.com/KhronosGroup/glTF/tree/master/specification/2.0</a>. We will focus on POSITION, NORMAL and TEXCOORD_0 for now.</p>
<p>The complete relationship is:</p>
<ul>
<li>glTF Buffer &lt;-&gt; OpenGL Buffer Object</li>
<li>glTF Buffer View + glTF Accessor + glTF Primitive &lt;-&gt; OpenGL Vertex Array</li>
</ul>
<p>This tells us how to build our OpenGL Data from the glTF Data. It can be a bit complicated to implement because we need to keep track of many vector indices (there is many indirections). That is why we need to use good explicit names for our indices, and not just &quot;i&quot; or &quot;j&quot;. If you don't, you will become crazy.</p>
<h2><a class="anchor" aria-hidden="true" id="creation-of-buffer-objects"></a><a href="#creation-of-buffer-objects" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creation of Buffer Objects</h2>
<blockquote>
<p>The part to replace in this section is <code>// TODO Loading the glTF file</code> with a call to the method that you must implement.</p>
</blockquote>
<p>We start with the easy one: converting glTF buffers to OpenGL buffer objects. This is easy because we have a direct mapping glTF Buffer &lt;-&gt; OpenGL Buffer Object. What we need to do:</p>
<ul>
<li>Create a vector of GLuint with the correct size (<code>model.buffers.size()</code>) and use <code>glGenBuffers</code> to create buffer objects.</li>
<li>In a loop, fill each buffer object with the data using <code>glBindBuffer</code> and <code>glBufferStorage</code>. The data should be obtained from <code>model.buffers[bufferIdx].data</code>.</li>
<li>Don't forget to unbind the buffer object from GL_ARRAY_BUFFER after the loop</li>
</ul>
<p>This code will look like the Buffer Object example code from before.</p>
<p><span class="todo badge"></span> Implement a method <code>std::vector&lt;GLuint&gt; ViewerApplication::createBufferObjects( const tinygltf::Model &amp;model)</code> that compute the vector of buffer objects from a model and returns it. Call this functions in <code>run()</code> after loading the glTF.</p>
<p><span class="todo badge"></span> Check compilation, run, commit and push your code.</p>
<hr>
<p>Solution (warning: also the solution of the next exercice, I messed up my commits)</p>
<ul>
<li><a href="https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/3bdd469d474d037900acf8fcaac5d429bbc037f2">https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/3bdd469d474d037900acf8fcaac5d429bbc037f2</a></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="creation-of-vertex-array-objects"></a><a href="#creation-of-vertex-array-objects" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creation of Vertex Array Objects</h2>
<blockquote>
<p>The part to replace in this section is <code>// TODO Creation of Vertex Array Objects</code> with a call to the method that you must implement.</p>
</blockquote>
<p>Now the hard part. Honestly, once you succeed to implement this part and understand it, you should understand glTF (and more generally: indirections).</p>
<p><span class="todo badge"></span> Start by adding en empty method <code>std::vector&lt;GLuint&gt; ViewerApplication::createVertexArrayObjects( const tinygltf::Model &amp;model, const std::vector&lt;GLuint&gt; &amp;bufferObjects, std::vector&lt;VaoRange&gt; &amp; meshIndexToVaoRange);</code></p>
<p>This method is supposed to take the model and the buffer objects we previously created, create an array of vertex array objects and return it. It should also fill the input vector <code>meshIndexToVaoRange</code> with the range of VAOs for each mesh (see below). This vector will be used later during drawing of the scene.</p>
<p><span class="todo badge"></span> In the function declare <code>std::vector&lt;GLuint&gt; vertexArrayObjects;</code></p>
<p>This vector will contain our vertex array objects. Take note that I don't give a size, because we don't know it yet.</p>
<p>Indeed, we should have a VAO for each primitive of the file. But the top level description of geometry is made with &quot;meshes&quot;. And each mesh can have multiple &quot;primitives&quot;. So the only way to know the total number of primitives (and thus of VAOs) is to loop over the meshes and add the number of primitives of each one. But we won't do that. We will loop, but use <code>resize()</code> to extend the vector as required at each loop turn.</p>
<p><span class="todo badge"></span> Create a loop over meshes of the glTF (<code>model.meshes</code>). Extend the size of <code>vertexArrayObjects</code> using <code>resize()</code>, by adding the number of primitives of the current mesh of the loop (<code>model.meshes[meshIdx].primitives.size()</code>). Push back the corresponding range of vertex array objects in <code>meshIndexToVaoRange</code> (see code below).</p>
<p>Here you need to understand that <code>vertexArrayObjects</code> will grow of <code>model.meshes[meshIdx].primitives.size()</code> elements at each loop turn. At turn <code>meshId - 1</code> we have <code>const auto vaoOffset = vertexArrayObjects.size()</code> elements. Then at turn <code>meshIdx</code> we call resize that way:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> vaoOffset = vertexArrayObjects.size();
vertexArrayObjects.resize(vaoOffset + model.meshes[meshIdx].primitives.size());
meshIndexToVaoRange.push_back(VaoRange{vaoOffset, model.meshes[meshIdx].primitives.size()}); <span class="hljs-comment">// Will be used during rendering</span>
</code></pre>
<p>The VAOs for are new primitives span the range <code>[vaoOffset, vaoOffset + model.meshes[meshIdx].primitives.size()]</code>. We need to call glGenVertexArrays on this range of data to create our VAOs. Remember that <code>&amp;vertexArrayObjects[vaoOffset]</code> is a pointer the the start of the range, and the size of the range is <code>model.meshes[meshIdx].primitives.size()</code>. This is important for the next todo:</p>
<p><span class="todo badge"></span> Call glGenVertexArrays to create new vertex arrays, one for each primitives. For that you will need to pass a pointer to the correct index <code>vertexArrayObjects</code>, which is the size of <code>vertexArrayObjects</code> before it was extended. So you need to store it in a variable before extending its size.</p>
<p>Now we need to initialize each vertex array object in a loop over primitives.</p>
<p><span class="todo badge"></span> Create a loop over the primitives of the current mesh (so this second loop is inside the first one). Inside that loop, get the VAO corresponding to the primitive (<code>vertexArrayObjects[vaoOffset + primitiveIdx]</code>) and bind it (<code>glBindVertexArray</code>).</p>
<p>Now inside that new loop we will need to enable and initialize the parameters for each vertex attribute (POSITION, NORMAL, TEXCOORD_0). The good news is, the code for each one is the same (we will duplicate it but it can easily be factorized with a loop over [&quot;POSITION&quot;, &quot;NORMAL&quot;, &quot;TEXCOORD_0&quot;]). The bas news is, we will have many indirections here, so a high potential of errors. Also each attribute is optional, se wo need to get use <code>find</code> on the <code>std::map</code> of attributes, which returns an iterator.</p>
<p>So for this one I will give you the uncompleted code and you need to replace comments starting with TODO with correct code:</p>
<pre><code class="hljs css language-cpp">{ <span class="hljs-comment">// I'm opening a scope because I want to reuse the variable iterator in the code for NORMAL and TEXCOORD_0</span>
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> iterator = primitive.attributes.find(<span class="hljs-string">"POSITION"</span>);
  <span class="hljs-keyword">if</span> (iterator != end(primitive.attributes)) { <span class="hljs-comment">// If "POSITION" has been found in the map</span>
    <span class="hljs-comment">// (*iterator).first is the key "POSITION", (*iterator).second is the value, ie. the index of the accessor for this attribute</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> accessorIdx = (*iterator).second;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;accessor = <span class="hljs-comment">// TODO get the correct tinygltf::Accessor from model.accessors</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;bufferView = <span class="hljs-comment">// TODO get the correct tinygltf::BufferView from model.bufferViews. You need to use the accessor</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> bufferIdx = <span class="hljs-comment">// TODO get the index of the buffer used by the bufferView (you need to use it)</span>

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> bufferObject = <span class="hljs-comment">// TODO get the correct buffer object from the buffer index</span>

    <span class="hljs-comment">// TODO Enable the vertex attrib array corresponding to POSITION with glEnableVertexAttribArray (you need to use VERTEX_ATTRIB_POSITION_IDX which has to be defined at the top of the cpp file)</span>
    <span class="hljs-comment">// TODO Bind the buffer object to GL_ARRAY_BUFFER</span>

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> byteOffset = <span class="hljs-comment">// TODO Compute the total byte offset using the accessor and the buffer view</span>
    <span class="hljs-comment">// TODO Call glVertexAttribPointer with the correct arguments. </span>
    <span class="hljs-comment">// Remember size is obtained with accessor.type, type is obtained with accessor.componentType. </span>
    <span class="hljs-comment">// The stride is obtained in the bufferView, normalized is always GL_FALSE, and pointer is the byteOffset (don't forget the cast).</span>
  }
}
</code></pre>
<p><span class="todo badge"></span> Copy the previous code after the bind of the vertex array object and complete it. You should also define the variable <code>VERTEX_ATTRIB_POSITION_IDX</code> of type <code>GLuint</code> with value 0 (the value should be set according to the vertex shader that we use, ie. <code>shaders/forward.vs.glsl</code>, using the corresponding <code>layout(location = ...)</code>)</p>
<p>Now that you got it filled, you can duplicate it two times and replace &quot;POSITION&quot; with &quot;NORMAL&quot; and &quot;TEXCOORD_0&quot;; and VERTEX_ATTRIB_POSITION_IDX with VERTEX_ATTRIB_NORMAL_IDX and VERTEX_ATTRIB_TEXCOORD0_IDX (or you can factorized with a loop).</p>
<p>The last thing we need in our inner loop is to set the index buffer of the vertex array object, if one exists. For that you need to check if <code>primitive.indices &gt;= 0</code>. If that's the case then you need to get the accessor of index <code>primitive.indices</code>, its buffer view, and call <code>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, /* TODO fill with the correct buffer object */)</code></p>
<p><span class="todo badge"></span> Set the index buffer of the VAO if it exists.</p>
<p>To finish the function, after the outer loop:</p>
<p><span class="todo badge"></span> Unbind the VAO, returns <code>vertexArrayObjects</code>. Add a call to your function in <code>run()</code>.</p>
<p><span class="todo badge"></span> Check compilation, run, commit and push your code.</p>
<hr>
<p>Solution (warning: also the solution of the previous exercice, I messed up my commits)</p>
<ul>
<li><a href="https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/3bdd469d474d037900acf8fcaac5d429bbc037f2">https://github.com/Celeborn2BeAlive/gltf-viewer-tutorial/commit/3bdd469d474d037900acf8fcaac5d429bbc037f2</a></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="more-details-about-vertex-array-objects-and-the-global-gl-state"></a><a href="#more-details-about-vertex-array-objects-and-the-global-gl-state" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>More details about Vertex Array Objects and the global GL state</h2>
<p>People generally struggle with Vertex Array Objects when they start OpenGL. <code>glVertexAttribPointer</code> is indeed not really intuitive for a human, since it describes how to convert raw bytes into readable arrays. This is something done by compilers in general, that why we have things like <code>std::vector</code> and not just <code>void*</code>. But in the GPU world we are a bit more low level. This is required to be able to layout our data the way we want, to optimize as much as we want.</p>
<p>Another thing to always keep in mind is the notion of state with OpenGL. We when call <code>glBindVertexArray(vertexArrayObject);</code> we are modifing the OpenGL state, which acts like a big global variable. It's a bit like <code>glBindVertexArray</code> was implemented like this:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_BIND_VERTEX_ARRAY</span><span class="hljs-params">(GLuint vaoId)</span> </span>{
  GLOBAL_GL_STATE.currentBoundVao = vaos[vaoId];
}
</code></pre>
<p>and then later call to OpenGL use that global state to act, like if <code>glEnableVertexAttribArray</code> was implemented that way:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_ENABLE_VERTEX_ATTRIB_ARRAY</span><span class="hljs-params">(GLuint vertexAttribIndex)</span> </span>{
  GLOBAL_GL_STATE.currentBoundVao-&gt;isVertexAttribEnabled[vertexAttribIndex] = <span class="hljs-literal">true</span>;
}
</code></pre>
<p>Here you can see I am reusing <code>GLOBAL_GL_STATE.currentBoundVao</code>. So if nothing was bound previously, there will be a problem. The same is true if some random VAO has been bound and the code who did this forgot to unbound it after: I will modify it by mistake.</p>
<p>And so finally the most important thing to understand about <code>glVertexAttribPointer</code>: it read two states. It reads the currently bound VAO to modify it,and it reads the currently bound buffer object on GL_ARRAY_BUFFER, to read its id and store it in the VAO. Again, an implementation could look like this:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MY_VERTEX_ATTRIB_POINTER</span><span class="hljs-params">(
  GLuint vertexAttribIndex,
    GLint size,
    GLenum type,
    GLboolean normalized,
    GLsizei stride,
    <span class="hljs-keyword">const</span> GLvoid * pointer)</span> 
</span>{
  <span class="hljs-keyword">const</span> GLuint currentBoundBO = GLOBAL_GL_STATE.currentBoundBufferObjects[GL_ARRAY_BUFFER]; <span class="hljs-comment">// Taking the currently bound BO on GL_ARRAY_BUFFER</span>
  GLOBAL_GL_STATE.currentBoundVao-&gt;vertexAttribParams[vertexAttribIndex].bufferObject = currentBoundBO; <span class="hljs-comment">// Store it for this vertex attrib</span>
  <span class="hljs-comment">// Store the remaining parameters:</span>
  GLOBAL_GL_STATE.currentBoundVao-&gt;vertexAttribParams[vertexAttribIndex].size = size;
  GLOBAL_GL_STATE.currentBoundVao-&gt;vertexAttribParams[vertexAttribIndex].type = type;
  GLOBAL_GL_STATE.currentBoundVao-&gt;vertexAttribParams[vertexAttribIndex].normalized = normalized;
  GLOBAL_GL_STATE.currentBoundVao-&gt;vertexAttribParams[vertexAttribIndex].pointer = pointer;
}
</code></pre>
<p>So here you see that I am accessing <code>GLOBAL_GL_STATE.currentBoundBufferObjects[GL_ARRAY_BUFFER]</code>, and <code>GLOBAL_GL_STATE.currentBoundVao</code>, two fields of the global state.</p>
<p>Why is OpenGL done that way you may ask ? Why does it use so much global states ? Why do we need to keep track of that ? Well probably because of the architecture of early GPUs of history. The OpenGL API has evolved with GPUs and has been designed to fill the need to exploit them efficiently.</p>
<p>Nowadays the architecture of GPUs has changed a lot. That why new APIs like Vulkan have emerged. In the meantime, OpenGL has also evolved and provide new possibilities using extensions. And one specific extension is called &quot;direct_state_access&quot; and offers alternative ways of manipulating OpenGL, with less global state, by directly passing object identifies to functions.</p>
<p>Unfortunately this extension is core only starting at OpenGL 4.5, and I want to keep this tutorial accessible to earlier versions of OpenGL. If you are curious you can start here: <a href="https://www.khronos.org/opengl/wiki/Direct_State_Access">https://www.khronos.org/opengl/wiki/Direct_State_Access</a>.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/openglnoel/docs/gltf-viewer-02-gltf-01-roadmap"><span class="arrow-prev">← </span><span>Introduction and roadmap</span></a><a class="docs-next button" href="/openglnoel/docs/gltf-viewer-02-gltf-03-drawing"><span>Drawing the scene</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#loading-the-gltf-file">Loading the glTF file</a></li><li><a href="#understanding-gltf-data">Understanding glTF data</a><ul class="toc-headings"><li><a href="#buffer-objects-and-vertex-array-objects">Buffer Objects and Vertex Array Objects</a></li><li><a href="#relationship-between-gltf-data-and-opengl-data">Relationship between glTF data and OpenGL data</a></li></ul></li><li><a href="#creation-of-buffer-objects">Creation of Buffer Objects</a></li><li><a href="#creation-of-vertex-array-objects">Creation of Vertex Array Objects</a></li><li><a href="#more-details-about-vertex-array-objects-and-the-global-gl-state">More details about Vertex Array Objects and the global GL state</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/openglnoel/" class="nav-home"><img src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]" width="66" height="58"/></a><div><h5>About Me</h5><a href="http://laurentnoel.fr">Personal website</a><a href="https://github.com/Celeborn2BeAlive/">Github</a></div><div><h5>About This Website</h5><a href="/openglnoel/blog">Blog</a><a class="github-button" href="https://github.com/celeborn2bealive/openglnoel" data-icon="octicon-star" data-count-href="/celeborn2bealive/openglnoel/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">openglnoel</a><a href="https://docusaurus.io/">Powered by Docusaurus</a></div><div><h5>About OpenGL</h5><a href="docs.gl">Documentation (docs.gl)</a><a href="https://www.khronos.org/opengl/wiki/">Wiki</a></div></section><section class="copyright">Copyright © 2020 Laurent NOEL</section></footer></div></body></html>