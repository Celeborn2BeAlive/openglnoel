<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Multi-texturing · OpenGL[&quot;noël&quot;]</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Il est possible d&#x27;utiliser plusieurs textures à la fois dans un même shader. C&#x27;est ce qu&#x27;on appelle le **Multi-texturing**. L&#x27;utilisation la plus courante est l&#x27;application de materiaux: on a généralement une texture pour chaque type de reflexion (diffuse, speculaire, ...). Nous verrons cette application lors du TP sur les lumières. Pour le moment nous allons ajouter une couche de nuages à la terre, representée par une nouvelle texture."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Multi-texturing · OpenGL[&quot;noël&quot;]"/><meta property="og:type" content="website"/><meta property="og:url" content="https://celeborn2bealive.github.io/openglnoel/"/><meta property="og:description" content="Il est possible d&#x27;utiliser plusieurs textures à la fois dans un même shader. C&#x27;est ce qu&#x27;on appelle le **Multi-texturing**. L&#x27;utilisation la plus courante est l&#x27;application de materiaux: on a généralement une texture pour chaque type de reflexion (diffuse, speculaire, ...). Nous verrons cette application lors du TP sur les lumières. Pour le moment nous allons ajouter une couche de nuages à la terre, representée par une nouvelle texture."/><meta property="og:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><link rel="shortcut icon" href="/openglnoel/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/atom.xml" title="OpenGL[&quot;noël&quot;] Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/feed.xml" title="OpenGL[&quot;noël&quot;] Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/openglnoel/js/code-block-buttons.js"></script><script type="text/javascript" src="/openglnoel/js/disqus.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/openglnoel/js/scrollSpy.js"></script><link rel="stylesheet" href="/openglnoel/css/main.css"/><script src="/openglnoel/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/openglnoel/"><img class="logo" src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]"/><h2 class="headerTitleWithLogo">OpenGL[&quot;noël&quot;]</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction" target="_self">Intro et SDK</a></li><li class=""><a href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base" target="_self">Bronze</a></li><li class="siteNavGroupActive"><a href="/openglnoel/docs/silver-01-3d-theorie-01-introduction" target="_self">Silver</a></li><li class=""><a href="/openglnoel/docs/gold-01-intro-sdk-01-introduction" target="_self">Gold</a></li><li class=""><a href="/openglnoel/blog/" target="_self">Blog</a></li><li class=""><a href="http://docs.gl" target="_self">OpenGL Documentation</a></li><li class=""><a href="https://www.khronos.org/opengl/wiki/" target="_self">OpenGL Wiki</a></li><li class=""><a href="https://github.com/celeborn2bealive/openglnoel" target="_self">GitHub</a></li><li class=""><a href="https://gltf-viewer-tutorial.gitlab.io" target="_self">My glTF Viewer Tutorial</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>3D - La pratique</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">3D - La théorie</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-01-3d-theorie-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-01-3d-theorie-02-normal-matrix">La Normal Matrix</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-01-3d-theorie-03-3d-vertex-shader">Un exemple de Vertex Shader pour la 3D</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-01-3d-theorie-04-glm">La bibliothèque glm</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">3D - La pratique</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-02-classe-sphere-cone">Les classes Sphere et Cone</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-03-dessiner-sphere">Dessiner une sphere</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-04-dessiner-lune">Dessiner une lune</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-05-dessiner-terre">Dessiner la terre</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-06-multi-texturing">Multi-texturing</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-07-plusieurs-shaders">Utiliser plusieurs shaders</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Gestion de la caméra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-03-camera-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-03-camera-02-trackball-camera">Trackball Camera</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-03-camera-03-freefly-camera">Freefly Camera</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Put the lights on !</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-04-lighting-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-04-lighting-02-directional-light">Directional Light</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-04-lighting-03-point-light">Point Light</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-04-lighting-04-aller-plus-loin">Aller plus loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Projet(s)</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-05-projets-01-iminecraft">Projet: IM(A)ineCraft</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Multi-texturing</h1></header><article><div><span><p>Il est possible d'utiliser plusieurs textures à la fois dans un même shader. C'est ce qu'on appelle le <strong>Multi-texturing</strong>. L'utilisation la plus courante est l'application de materiaux: on a généralement une texture pour chaque type de reflexion (diffuse, speculaire, ...). Nous verrons cette application lors du TP sur les lumières. Pour le moment nous allons ajouter une couche de nuages à la terre, representée par une nouvelle texture.</p>
<p><span class="badge todo"></span> Téléchargez le fichier <a href="/openglnoel/docs/assets/CloudMap.jpg">CloudMap.jpg</a> et placez le dans votre repertoire de textures.</p>
<p><span class="badge todo"></span> Copiez le code source du TP précédent et renommez le.</p>
<p><span class="badge todo"></span> Dans le code source, partie initialisation, chargez la nouvelle image et créez un texture object à partir de cette dernière.</p>
<p><span class="badge todo"></span> Créez un nouveau shader <strong>multiTex3D.fs.glsl</strong>. Reprenez le code du shader <strong>tex3D.fs.glsl</strong> et ajoutez une nouvelle variable uniforme de type <strong>sampler2D</strong> pour la deuxième texture. Dans le main, lisez la couleur de chacune des textures. Additionnez les deux couleurs et placez le résultat dans la couleur de sortie.</p>
<p>Modifiez le code C++ pour charger votre nouveau shader.</p>
<p>Pour pouvoir utiliser plusieurs textures en même temps, il faut les binder sur des <strong>unités de texture</strong> différentes. Une unité de texture est représentée par une constant de la forme <strong>GL_TEXTUREi</strong>. Par exemple <strong>GL_TEXTURE0</strong> représente l'unité de texture 0, <strong>GL_TEXTURE1</strong> l'unité de texture 1, etc. A noter qu'on peut aussi utiliser <strong>GL_TEXTURE0 + 1</strong> pour obtenir <strong>GL_TEXTURE1</strong>.</p>
<p>Pour binder sur une unité de texture particulière, il faut l'activer avec la fonction <strong>glActiveTexture</strong>.</p>
<p>Voici un exemple de code:</p>
<pre><code class="hljs css language-cpp">glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE2D, earthTexture); <span class="hljs-comment">// la texture earthTexture est bindée sur l'unité GL_TEXTURE0</span>
glActiveTexture(GL_TEXTURE1);
glBindTexture(GL_TEXTURE2D, cloudTexture); <span class="hljs-comment">// la texture cloudTexture est bindée sur l'unité GL_TEXTURE1</span>
</code></pre>
<p>Les textures restent bindées sur les unités de texture tant qu'on ne les débind pas. Voici un exemple de débinding correspondant au code précédent:</p>
<pre><code class="hljs css language-cpp">glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE2D, <span class="hljs-number">0</span>); <span class="hljs-comment">// débind sur l'unité GL_TEXTURE0</span>
glActiveTexture(GL_TEXTURE1);
glBindTexture(GL_TEXTURE2D, <span class="hljs-number">0</span>); <span class="hljs-comment">// débind sur l'unité GL_TEXTURE1</span>
</code></pre>
<p>Lorsqu'une texture est bindée sur une unité de texture, les shaders peuvent l'utiliser même si l'unité n'est plus &quot;active&quot; au sens d'OpenGL (le nom de la fonction <strong>glActiveTexture</strong> est assez mal choisi selon moi).</p>
<p>Il faut alors associer chaque variable uniforme de texture présente dans les shaders à une unité de texture. Pour cela on utilise la fonction <strong>glUniform1i</strong> en lui passant l'index de l'unité de texture sur laquelle on souhaite lire. Voici un exemple:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-comment">// Récupère la location de la première texture dans le shader</span>
GLint uEarthTexture = glGetUniformLocation(program.getGLId(), <span class="hljs-string">"uEarthTexture"</span>);
<span class="hljs-comment">// Récupère la location de deuxieme texture dans le shader</span>
GLint uCloudTexture = glGetUniformLocation(program.getGLId(), <span class="hljs-string">"uCloudTexture"</span>);
<span class="hljs-comment">// Indique à OpenGL qu'il doit aller chercher sur l'unité de texture 0 </span>
<span class="hljs-comment">// pour lire dans la texture uEarthTexture:</span>
glUniform1i(uEarthTexture, <span class="hljs-number">0</span>);
<span class="hljs-comment">// Indique à OpenGL qu'il doit aller chercher sur l'unité de texture 1</span>
<span class="hljs-comment">// pour lire dans la texture uEarthTexture:</span>
glUniform1i(uEarthTexture, <span class="hljs-number">1</span>);
</code></pre>
<p>Vous noterez que pour les variables uniforme, on n'utilise pas les constantes GL_TEXTUREi mais directement l'index i.</p>
<p><span class="badge todo"></span> Dans votre code C++, récupérez la location des variables uniformes correspondant à vos deux textures et utilisez <strong>glUniform1i</strong> comme indiqué dans l'exemple pour aller lire sur les unités de texture 0 et 1.</p>
<p><span class="badge todo"></span> Dans votre boucle de rendu, bindez les textures sur les bonnes unités afin de pouvoir utiliser les deux textures. Dans le cas du dessin de la terre on utilise la texture de terre et la texture de nuage. Dans le cas du dessin de la lune on utilise la texture de lune et la texture de nuage. Voici un exemple de code pour dessiner la terre:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-comment">// Les transformation viennent avant...</span>
glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, earthTexture);
glActiveTexture(GL_TEXTURE1);
glBindTexture(GL_TEXTURE_2D, cloudTexture);

glDrawArrays(GL_TRIANGLES, <span class="hljs-number">0</span>, sphere.getVertexCount());
</code></pre>
<p>Voici une image du résultat attendu:</p>
<p><img src="/openglnoel/img/multitexturing.jpg" alt="Terre multi-texturing"></p>
<h2><a class="anchor" aria-hidden="true" id="retirer-les-nuages-des-lunes"></a><a href="#retirer-les-nuages-des-lunes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Retirer les nuages des lunes</h2>
<p>Avoir des nuages sur les lunes, ce n'est pas très logique. On a deux solutions pour les retirer:</p>
<ul>
<li>Solution simple mais peu générique: débinder la texture située sur l'unité de texture 1. En faisant ça, le shader essaiera de lire sur une unité de texture ne contenant aucune texture. Dans ce cas le comportement par défaut est de renvoyer la couleur noire (vec3(0)). On additionnera donc la couleur de la lune à vec3(0), ce qui affichera simplement la lune sans nuages.</li>
<li>Solution compliquée mais plus souple: on utilise deux shaders, un pour dessiner la terre et un pour dessiner les lunes.</li>
</ul>
<p><span class="badge todo"></span> Essayez la première solution.</p>
<p>Comme on aime les choses compliqués, et surtout qu'il est important de savoir utiliser plusieurs shaders pour dessiner différents objets de manière différente, nous allons également coder la deuxième solution dans l'exercice suivant.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/openglnoel/docs/silver-02-3d-pratique-05-dessiner-terre"><span class="arrow-prev">← </span><span>Dessiner la terre</span></a><a class="docs-next button" href="/openglnoel/docs/silver-02-3d-pratique-07-plusieurs-shaders"><span>Utiliser plusieurs shaders</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#retirer-les-nuages-des-lunes">Retirer les nuages des lunes</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/openglnoel/" class="nav-home"><img src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]" width="66" height="58"/></a><div><h5>About Me</h5><a href="http://laurentnoel.fr">Personal website</a><a href="https://github.com/Celeborn2BeAlive/">Github</a></div><div><h5>About This Website</h5><a href="/openglnoel/blog">Blog</a><a class="github-button" href="https://github.com/celeborn2bealive/openglnoel" data-icon="octicon-star" data-count-href="/celeborn2bealive/openglnoel/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">openglnoel</a><a href="https://docusaurus.io/">Powered by Docusaurus</a></div><div><h5>About OpenGL</h5><a href="docs.gl">Documentation (docs.gl)</a><a href="https://www.khronos.org/opengl/wiki/">Wiki</a></div></section><section class="copyright">Copyright © 2021 Laurent NOEL</section></footer></div></body></html>