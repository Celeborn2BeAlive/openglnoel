<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Le Rendu Direct · OpenGL[&quot;noël&quot;]</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="![Immediate Mode](/openglnoel/img/claims-to-know-opengl-uses-immediate-mode.jpg)"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Le Rendu Direct · OpenGL[&quot;noël&quot;]"/><meta property="og:type" content="website"/><meta property="og:url" content="https://celeborn2bealive.github.io/openglnoel/"/><meta property="og:description" content="![Immediate Mode](/openglnoel/img/claims-to-know-opengl-uses-immediate-mode.jpg)"/><meta property="og:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><link rel="shortcut icon" href="/openglnoel/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/atom.xml" title="OpenGL[&quot;noël&quot;] Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/feed.xml" title="OpenGL[&quot;noël&quot;] Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/openglnoel/js/code-block-buttons.js"></script><script type="text/javascript" src="/openglnoel/js/disqus.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/openglnoel/js/scrollSpy.js"></script><link rel="stylesheet" href="/openglnoel/css/main.css"/><script src="/openglnoel/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/openglnoel/"><img class="logo" src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]"/><h2 class="headerTitleWithLogo">OpenGL[&quot;noël&quot;]</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction" target="_self">Intro et SDK</a></li><li class=""><a href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base" target="_self">Bronze</a></li><li class=""><a href="/openglnoel/docs/silver-01-3d-theorie-01-introduction" target="_self">Silver</a></li><li class=""><a href="/openglnoel/docs/gold-01-intro-sdk-01-introduction" target="_self">Gold</a></li><li class=""><a href="/openglnoel/blog/" target="_self">Blog</a></li><li class=""><a href="http://docs.gl" target="_self">OpenGL Documentation</a></li><li class=""><a href="https://www.khronos.org/opengl/wiki/" target="_self">OpenGL Wiki</a></li><li class=""><a href="https://github.com/celeborn2bealive/openglnoel" target="_self">GitHub</a></li><li class=""><a href="https://gltf-viewer-tutorial.gitlab.io" target="_self">My glTF Viewer Tutorial</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>La Philosophie OpenGL 3+</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">La Philosophie OpenGL 3+</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction">Introduction</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/openglnoel/docs/intro-sdk-01-philogl-02-rendu-direct">Le Rendu Direct</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/intro-sdk-01-philogl-03-pipeline-programmable">Pipeline Programmable</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/intro-sdk-01-philogl-04-deprecation-model">Deprecation Model</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/intro-sdk-01-philogl-05-exemple">Exemple</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/intro-sdk-01-philogl-06-conclusion">Conclusion</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Software Development Kit (SDK)</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/intro-sdk-02-SDK-01-repository">Le repository Github</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/intro-sdk-02-SDK-02-compilation">Compilation du SDK</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/intro-sdk-02-SDK-03-structure-du-sdk">Structure du SDK</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/intro-sdk-02-SDK-04-le-site-web">Le site web</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Aller plus loin</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/intro-sdk-03-aller-plus-loin-01-liens">Liens externes</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Le Rendu Direct</h1></header><article><div><span><p><img src="/openglnoel/img/claims-to-know-opengl-uses-immediate-mode.jpg" alt="Immediate Mode"></p>
<h2><a class="anchor" aria-hidden="true" id="quest-ce-que-le-rendu-direct"></a><a href="#quest-ce-que-le-rendu-direct" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Qu'est ce que le rendu direct</h2>
<p>Le rendu direct (ou &quot;immediate mode rendering&quot;), c'est ce que vous avez pratiqué en Synthèse d'Image 1: utiliser les fonctions glBegin, glEnd, glVertex, glColor, etc. dans la boucle principale pour faire votre rendu. Voici un exemple qui dessine un triangle coloré:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-comment">// OpenGL 2 et rendu direct:</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    initWindowSystem(); <span class="hljs-comment">// SDL, GLFW, SFML, etc.</span>
    
    <span class="hljs-keyword">bool</span> loop = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">while</span>(loop) {
        glBegin(GL_TRIANGLES);
            glColor3ub(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
            glVertex2f(<span class="hljs-number">-0.5</span>, <span class="hljs-number">-0.5</span>);
            glColor3ub(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>);
            glVertex2f(<span class="hljs-number">0.5</span>, <span class="hljs-number">-0.5</span>);
            glColor3ub(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>);
            glVertex2f(<span class="hljs-number">0.</span>, <span class="hljs-number">0.5</span>);
        glEnd();
        
        SDL_GL_SwapBuffers();
        SDL_Event e;
        <span class="hljs-keyword">while</span>(SDL_PollEvent(&amp;e)) {
            <span class="hljs-keyword">if</span>(e.type == SDL_QUIT) {
                loop = <span class="hljs-literal">false</span>;
            }
        }
    }
    
    exitWindowSystem();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>Le résultat:</p>
<p><img src="/openglnoel/img/triangle.png" alt="Triangle"></p>
<h2><a class="anchor" aria-hidden="true" id="le-problème-du-rendu-direct"></a><a href="#le-problème-du-rendu-direct" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Le problème du rendu direct</h2>
<p>Le code précédent cache un gros problème de performance: à chaque tour de boucle l'ensemble des données est renvoyé à la carte graphique (tous les nombres là dans les appels de fonction). De plus appeler autant de fonctions est couteux en temps. Quand il s'agit de dessiner un seul triangle ça va, vous devriez faire tourner le code en temps réel. Par compte s'il faut en dessiner un million, ça va commencer à ramer.</p>
<p>Mettez vous à la place des développeurs OpenGL et essayez de trouver une manière d'optimiser cela. Le but est d'avoir le moins de chose possible à faire dans la boucle de rendu afin de minimiser le temps passé dans cette dernière et ainsi augmenter le nombre d'images calculées par seconde.</p>
<p><img src="/openglnoel/img/direct_rendering.png" alt="Direct Rendering"></p>
<h2><a class="anchor" aria-hidden="true" id="le-rendu-par-buffer"></a><a href="#le-rendu-par-buffer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Le rendu par buffer</h2>
<p>Une solution simple est de construire à l'initialition des buffers contenant nos données. Ces buffers sont stockés directement sur la carte graphique et identifiés dans le code CPU par un entier. Il suffit ensuite durant la boucle de rendu de dire à OpenGL &quot;hé ! dessine les données de ce buffer !&quot;.</p>
<p>On minimise ainsi les transferts de données entre CPU et GPU or c'est ce qui coute le plus cher.</p>
<p><img src="/openglnoel/img/vbo_rendering.png" alt="Buffer Rendering"></p>
<p>Voici un exemple de code pour dessiner un triangle... blanc (pour avoir de la couleur c'est plus compliqué). Inutile de lire dans le détail pour l'instant, l'objectif est plutôt d'essayer de comprendre la différence avec le code OpenGL 2.</p>
<pre><code class="hljs css language-cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    initWindowSystem(); <span class="hljs-comment">// SDL, GLFW, SFML, etc.</span>
    
    <span class="hljs-comment">// Initialisation de GLEW; nous verrons dans le prochain TP à quoi cela sert.</span>
    GLint error;
    <span class="hljs-keyword">if</span>(GLEW_OK != (error = glewInit())) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Impossible d'initialiser Glew"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    
    <span class="hljs-comment">// Création d'un Vertex Buffer Object et d'un Vertex Array Object</span>
    GLuint vbo, vao;
    
    <span class="hljs-comment">// Allocation d'un Vertex Buffer Object:</span>
    glGenBuffers(<span class="hljs-number">1</span>, &amp;vbo);

    <span class="hljs-comment">// "vbo" devient le VBO courant sur la cible GL_ARRAY_BUFFER:</span>
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    
        <span class="hljs-comment">// Tableau des attributs des sommets</span>
        GLfloat vertices[] = {
            <span class="hljs-number">-0.5</span>, <span class="hljs-number">-0.5</span>, <span class="hljs-comment">// Premier vertex</span>
            <span class="hljs-number">0.5</span>, <span class="hljs-number">-0.5</span>, <span class="hljs-comment">// Deuxième vertex</span>
            <span class="hljs-number">0.</span>, <span class="hljs-number">0.5</span>, <span class="hljs-comment">// Troisème vertex</span>
        };
        
        <span class="hljs-comment">// Stockage des données du tableau vertices dans le vbo placé sur GL_ARRAY_BUFFER (c'est à dire "vbo" ici) :</span>
        glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);
    
    <span class="hljs-comment">// Plus de VBO sur la cible GL_ARRAY_BUFFER:</span>
    glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);
    
    <span class="hljs-comment">// Allocation d'un Vertex Array Objet:</span>
    glGenVertexArrays(<span class="hljs-number">1</span>, &amp;vao);
    
    <span class="hljs-comment">// "vao" devient le VAO courant:</span>
    glBindVertexArray(vao);
    
        <span class="hljs-comment">// "vbo" devient le VBO courant sur la cible GL_ARRAY_BUFFER:</span>
        glBindBuffer(GL_ARRAY_BUFFER, vbo);
        
        <span class="hljs-comment">// Activation de l'attribut de vertex 0; nous l'interpretons comme la position</span>
        glEnableVertexAttribArray(<span class="hljs-number">0</span> <span class="hljs-comment">/* Incide attribut*/</span>);
        <span class="hljs-comment">// On spécifie le type de donnée de l'attribut position ainsi que la manière dont il est stocké dans le VBO</span>
        glVertexAttribPointer(
            <span class="hljs-number">0</span> <span class="hljs-comment">/* Indice attribut */</span>, 
            <span class="hljs-number">2</span> <span class="hljs-comment">/* Nombre de composantes */</span>, 
            GL_FLOAT <span class="hljs-comment">/* Type d'une composante */</span>, 
            GL_FALSE <span class="hljs-comment">/* Pas de normalisation */</span>, 
            <span class="hljs-number">2</span> * <span class="hljs-keyword">sizeof</span>(GLfloat) <span class="hljs-comment">/* Taille en octet d'un vertex complet entre chaque attribut position */</span>, 
            <span class="hljs-number">0</span> <span class="hljs-comment">/* OpenGL doit utiliser le VBO attaché à GL_ARRAY_BUFFER et commencer à l'offset 0 */</span>);
        
    <span class="hljs-comment">// Plus de VAO courant:</span>
    glBindVertexArray(<span class="hljs-number">0</span>);
    
    <span class="hljs-keyword">bool</span> loop = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">while</span>(loop) {
        <span class="hljs-comment">// "vao" devient le VAO courant, OpenGL l'utilisera lors du dessin pour avoir des informations sur les sommets</span>
        glBindVertexArray(vao);
        
        <span class="hljs-comment">// OpenGL doit dessiner des triangles en utilisant 3 sommets (donc un seul triangle)</span>
        glDrawArrays(GL_TRIANGLES, <span class="hljs-number">0</span> <span class="hljs-comment">/* Pas d'offset au début du VBO */</span>, <span class="hljs-number">3</span>);
        
        <span class="hljs-comment">// Plus de VAO courant:</span>
        glBindVertexArray(<span class="hljs-number">0</span>);
        
        SDL_Event e;
        <span class="hljs-keyword">while</span>(SDL_PollEvent(&amp;e)) {
            <span class="hljs-keyword">if</span>(e.type == SDL_QUIT) {
                loop = <span class="hljs-literal">false</span>;
            }
        }

        SDL_GL_SwapBuffers();
    }
    
    glDeleteVertexArrays(<span class="hljs-number">1</span>, &amp;vao);
    glDeleteBuffers(<span class="hljs-number">1</span>, &amp;vbo);
    
    exitWindowSystem();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>C'est déjà plus long, et on a même pas la couleur &gt;.&lt; ! On remarque que le code de rendu ne fait maintenant plus que 3 lignes. Toutes les données sont placées dans un Vertex Buffer Object avant la boucle principale. Un Vertex Array Object stocke le format des données qu'on envoit à OpenGL (3 positions composée chacune de 2 flottants).</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction"><span class="arrow-prev">← </span><span>Introduction</span></a><a class="docs-next button" href="/openglnoel/docs/intro-sdk-01-philogl-03-pipeline-programmable"><span>Pipeline Programmable</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#quest-ce-que-le-rendu-direct">Qu'est ce que le rendu direct</a></li><li><a href="#le-problème-du-rendu-direct">Le problème du rendu direct</a></li><li><a href="#le-rendu-par-buffer">Le rendu par buffer</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/openglnoel/" class="nav-home"><img src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]" width="66" height="58"/></a><div><h5>About Me</h5><a href="http://laurentnoel.fr">Personal website</a><a href="https://github.com/Celeborn2BeAlive/">Github</a></div><div><h5>About This Website</h5><a href="/openglnoel/blog">Blog</a><a class="github-button" href="https://github.com/celeborn2bealive/openglnoel" data-icon="octicon-star" data-count-href="/celeborn2bealive/openglnoel/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">openglnoel</a><a href="https://docusaurus.io/">Powered by Docusaurus</a></div><div><h5>About OpenGL</h5><a href="docs.gl">Documentation (docs.gl)</a><a href="https://www.khronos.org/opengl/wiki/">Wiki</a></div></section><section class="copyright">Copyright © 2021 Laurent NOEL</section></footer></div></body></html>