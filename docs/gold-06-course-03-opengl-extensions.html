<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Extensions OpenGL · OpenGL[&quot;noël&quot;]</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Le méchanisme d&#x27;extensions OpenGL permet aux constructeurs de carte graphique d&#x27;ajouter à l&#x27;API des fonctionnalités avancées qui ne sont pas encore présentes dans le Core profile."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Extensions OpenGL · OpenGL[&quot;noël&quot;]"/><meta property="og:type" content="website"/><meta property="og:url" content="https://celeborn2bealive.github.io/openglnoel/"/><meta property="og:description" content="Le méchanisme d&#x27;extensions OpenGL permet aux constructeurs de carte graphique d&#x27;ajouter à l&#x27;API des fonctionnalités avancées qui ne sont pas encore présentes dans le Core profile."/><meta property="og:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><link rel="shortcut icon" href="/openglnoel/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/atom.xml" title="OpenGL[&quot;noël&quot;] Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/feed.xml" title="OpenGL[&quot;noël&quot;] Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/openglnoel/js/code-block-buttons.js"></script><script type="text/javascript" src="/openglnoel/js/disqus.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/openglnoel/js/scrollSpy.js"></script><link rel="stylesheet" href="/openglnoel/css/main.css"/><script src="/openglnoel/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/openglnoel/"><img class="logo" src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]"/><h2 class="headerTitleWithLogo">OpenGL[&quot;noël&quot;]</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction" target="_self">Introduction et SDK</a></li><li class=""><a href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base" target="_self">Bronze</a></li><li class=""><a href="/openglnoel/docs/silver-01-3d-theorie-01-introduction" target="_self">Silver</a></li><li class="siteNavGroupActive"><a href="/openglnoel/docs/gold-01-intro-sdk-01-introduction" target="_self">Gold</a></li><li class=""><a href="/openglnoel/blog/" target="_self">Blog</a></li><li class=""><a href="http://docs.gl" target="_self">OpenGL Documentation</a></li><li class=""><a href="https://www.khronos.org/opengl/wiki/" target="_self">OpenGL Wiki</a></li><li class=""><a href="https://github.com/celeborn2bealive/openglnoel" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Annexe: API OpenGL</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction et SDK</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-01-intro-sdk-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-01-intro-sdk-03-fiche-info">Fiche d&#x27;information</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-01-intro-sdk-05-projet">Projet - Un viewer glTF</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Forward Renderer</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-01-pipeline">Pipeline de Rendu</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-02-geometrie">Geometrie</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-03-shaders">Shaders</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-04-transformations">Transformations</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-05-lighting">Lighting</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-06-textures">Textures</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-07-load-obj">Chargement de modèles OBJ</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-08-plus-loin">Aller plus loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Deferred Renderer</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-01-pipeline">Pipeline de Rendu</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-02-geometry-pass">Geometrie Pass</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-03-shading-pass">Shading Pass</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-04-plus-loin">Aller plus loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Shadow Mapping</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-02-dir-shadow-map">Directional Shadow Map</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-03-percentage-closest-filtering">Percentage Closest Filtering</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-04-aller-plus-loin">Aller Plus Loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Post Processing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-02-gamma-correction">Gamma Correction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-03-extraction-contours">Extraction et Rendu de Contours</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-04-depth-of-field">Depth of Field</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Annexe: API OpenGL</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-01-opengl-context">Contexte OpenGL</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-02-gpu-pipeline">Pipeline de Rendu</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/openglnoel/docs/gold-06-course-03-opengl-extensions">Extensions OpenGL</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-04-opengl-objects">Objets OpenGL</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-05-buffer-objects">Buffer Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-06-vertex-array-objects">Vertex Array Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-07-textures">Texture Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-08-framebuffer-objects">Framebuffer Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-09-shaders">Shaders</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Extensions OpenGL</h1></header><article><div><span><p>Le méchanisme d'extensions OpenGL permet aux constructeurs de carte graphique d'ajouter à l'API des fonctionnalités avancées qui ne sont pas encore présentes dans le Core profile.</p>
<p>Il est assez standard d'utiliser des extensions OpenGL et d'adapter son moteur en fonction des extensions disponibles sur la carte graphique de l'utilisateur.</p>
<p>Le nom des extensions suit une nomenclature assez précises. Il y a 3 types d'extensions:</p>
<ul>
<li>Propriétaires: Spécifiques à un seul constructeur. Par exemple les extensions préfixées par GL_NV sont spécifiques aux GPU de NVidia.</li>
<li>Génériques: Généralement implémentées par un grand nombre de constructeurs. Préfixées par GL_EXT</li>
<li>ARB: Extensions génériques approuvées par l'<a href="https://www.opengl.org/archives/about/arb/">OpenGL ARB</a>, destinées à entrer dans le Core profile d'une future version d'OpenGL.</li>
</ul>
<p>Les extensions sont détaillées dans un fichier texte dedié assez difficile à lire (exemple: <a href="https://www.opengl.org/registry/specs/ARB/vertex_array_object.txt">https://www.opengl.org/registry/specs/ARB/vertex_array_object.txt</a>) car il mentionne des additions, suppressions ou modifications dans la spécification générale d'OpenGL.</p>
<p>Plus d'infos sur le Wiki: <a href="https://www.khronos.org/opengl/wiki/OpenGL_Extension">https://www.khronos.org/opengl/wiki/OpenGL_Extension</a></p>
<p>Pour savoir si une extension OpenGL est proposée par votre driver, vous pouvez utiliser la commande <em>glxinfo sous Linux (</em>nvidia-config --glxinfo* sous certains système) et piper le résultat dans un grep du nom de l'extension recherchée. Sous windows vous pouvez passer par un utilitaire tel que <a href="http://realtech-vr.com/admin/glview">GLview</a>.</p>
<p>Quelques extensions très interessantes:</p>
<h2><a class="anchor" aria-hidden="true" id="direct-state-access"></a><a href="#direct-state-access" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Direct State Access</h2>
<p>L'extension Direct State Access (DSA) (<a href="https://www.opengl.org/registry/specs/EXT/direct_state_access.txt">GL_EXT_direct_state_access</a>, puis <a href="https://www.opengl.org/registry/specs/ARB/direct_state_access.txt">GL_ARB_direct_state_access</a>, puis introduite en Core 4.5) propose une nouvelle manière de modifier/accéder aux objets OpenGL, sans avoir à les binder.</p>
<p>Cela permet d'éviter de se préoccuper de l'état global du contexte OpenGL lorsque l'on veut manipuler les objets OpenGL et ainsi d'éviter un grand nombre d'erreurs de programmation.</p>
<p><span class="badge warning"></span>
Cette extension n'est pas disponible sur toutes les cartes graphiques. En particulier les machines de la FAC n'en sont pas equipées entièrement (il y a l'extension <strong>GL_EXT_direct_state_access</strong> qui n'est que partielle). Si vous n'y avez pas accès, ne l'utilisez pas: cette extension ne fournit que des facilités de programmation, pas de fonctionnalité en plus.</p>
<p>Cette extension est très pratique car elle permet d'éviter de binder les objets OpenGL pour les manipuler (on passe aux fonctions directement l'identifiant de l'objet), et donc d'éviter les erreurs liées au mécanisme de binding. Je vous conseille donc de l'utiliser autant que possible.</p>
<p><a href="https://www.opengl.org/registry/specs/ARB/direct_state_access.txt">Lien vers le document de référence</a>.</p>
<p>Voici des exemples de code en version OpenGL 3 classique et en version Direct State Access (directement tiré du document):</p>
<h2><a class="anchor" aria-hidden="true" id="example-1-creating-a-buffer-object-without-polluting-the-opengl-states"></a><a href="#example-1-creating-a-buffer-object-without-polluting-the-opengl-states" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example 1: Creating a buffer object without polluting the OpenGL states</h2>
<pre><code class="hljs css language-cpp"><span class="hljs-comment">// Bind to Create</span>
<span class="hljs-function">GLuint <span class="hljs-title">CreateBuffer</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-comment">// Save the previous bound buffer</span>
  GLuint restoreBuffer = <span class="hljs-number">0</span>;
  glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &amp;restoreBuffer);

  <span class="hljs-comment">// Reserve the buffer name and create the buffer object</span>
  uint buffer = <span class="hljs-number">0</span>;
  glGenBuffers(<span class="hljs-number">1</span>, &amp;buffer);
  glBindBuffer(GL_ARRAY_BUFFER, buffer);

  <span class="hljs-comment">// Restaure the previous bound buffer to avoid polluting</span>
  <span class="hljs-comment">// the rendering states</span>
  glBindBuffer(GL_ARRAY_BUFFER, restoreBuffer);

  <span class="hljs-keyword">return</span> buffer;
}

<span class="hljs-comment">// Direct State Access</span>
<span class="hljs-function">GLuint <span class="hljs-title">CreateBuffer</span><span class="hljs-params">()</span>
</span>{
  GLuint buffer = <span class="hljs-number">0</span>;
  glCreateBuffer(<span class="hljs-number">1</span>, &amp;buffer);

  <span class="hljs-keyword">return</span> buffer;
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="example-2-creating-a-vertex-array-object-without-polluting-the-opengl-states"></a><a href="#example-2-creating-a-vertex-array-object-without-polluting-the-opengl-states" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example 2: Creating a vertex array object without polluting the OpenGL states</h2>
<pre><code class="hljs css language-cpp"><span class="hljs-comment">// OpenGL 3.0 Bind to Create for vertex array object</span>
<span class="hljs-function">GLuint <span class="hljs-title">CreateVertexArray</span><span class="hljs-params">(GLuint BufferName[])</span>
</span>{
  <span class="hljs-comment">// Save the previous bound vertex array and array buffer</span>
  GLuint restoreVertexArray = <span class="hljs-number">0</span>;
  glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &amp;restoreVertexArray);
  GLuint restoreBuffer = <span class="hljs-number">0</span>;
  glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &amp;restoreBuffer);

  glGenVertexArrays(<span class="hljs-number">1</span>, &amp;VertexArrayName);
  glBindVertexArray(VertexArrayName);
    glEnableVertexAttribArray(semantic::attr::POSITION);
    glEnableVertexAttribArray(semantic::attr::TEXCOORD);

    glBindBuffer(GL_ARRAY_BUFFER, BufferName[buffer::VERTEX]);
    glVertexAttribPointer(semantic::attr::POSITION, <span class="hljs-number">2</span>, GL_FLOAT, 
      GL_FALSE, <span class="hljs-keyword">sizeof</span>(glf::vertex_v2fv2f), BUFFER_OFFSET(<span class="hljs-number">0</span>));
    glVertexAttribPointer(semantic::attr::TEXCOORD, <span class="hljs-number">2</span>, GL_FLOAT, 
      GL_FALSE, <span class="hljs-keyword">sizeof</span>(glf::vertex_v2fv2f), BUFFER_OFFSET(<span class="hljs-keyword">sizeof</span>(glm::vec2)));

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, BufferName[buffer::ELEMENT]);

  <span class="hljs-comment">// The GL_ARRAY_BUFFER_BINDING is a context state, not a vertex array state.</span>
  glBindBuffer(GL_ARRAY_BUFFER, restoreBuffer);
  glBindVertexArray(restoreVertexArray);

  <span class="hljs-keyword">return</span> vertexArrayName;
}

<span class="hljs-comment">// OpenGL 4.3 Bind to Create for vertex array object</span>
<span class="hljs-function">GLuint <span class="hljs-title">CreateVertexArray</span><span class="hljs-params">(GLuint BufferName[])</span>
</span>{
  <span class="hljs-comment">// Save the previous bound vertex array</span>
  GLuint restoreVertexArray = <span class="hljs-number">0</span>;
  glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &amp;restoreVertexArray);

  GLuint vertexArrayName = <span class="hljs-number">0</span>;
  glGenVertexArrays(<span class="hljs-number">1</span>, &amp;vertexArrayName);
  glBindVertexArray(VertexArrayName);
    glEnableVertexAttribArray(semantic::attr::POSITION);
    glEnableVertexAttribArray(semantic::attr::TEXCOORD);

    glVertexAttribBinding(semantic::attr::POSITION, <span class="hljs-number">0</span>);
    glVertexAttribFormat(semantic::attr::POSITION, <span class="hljs-number">2</span>, GL_FLOAT, 
      GL_FALSE, <span class="hljs-number">0</span>);

    glVertexAttribBinding(semantic::attr::TEXCOORD, <span class="hljs-number">0</span>);
    glVertexAttribFormat(semantic::attr::TEXCOORD, <span class="hljs-number">2</span>, GL_FLOAT, 
      GL_FALSE, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>) * <span class="hljs-number">2</span>);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, BufferName[buffer::ELEMENT]);
    glBindVertexBuffer(<span class="hljs-number">0</span>, BufferName[buffer::VERTEX], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
  glBindVertexArray(restoreVertexArray);

  <span class="hljs-keyword">return</span> vertexArrayName;
}

<span class="hljs-comment">// Direct State Access</span>
<span class="hljs-function">GLuint <span class="hljs-title">CreateVertexArray</span><span class="hljs-params">(GLuint BufferName[])</span>
</span>{
  GLuint vertexArrayName = <span class="hljs-number">0</span>;
  glCreateVertexArrays(<span class="hljs-number">1</span>, &amp;vertexArrayName);

  glEnableVertexAttribArray(VertexArrayName, semantic::attr::POSITION);
  glEnableVertexAttribArray(VertexArrayName, semantic::attr::TEXCOORD);

  glVertexArrayAttribBinding(VertexArrayName, semantic::attr::POSITION, <span class="hljs-number">0</span>);
  glVertexArrayAttribFormat(VertexArrayName, semantic::attr::POSITION, <span class="hljs-number">2</span>, GL_FLOAT, 
    GL_FALSE, <span class="hljs-number">0</span>);

  glVertexArrayAttribBinding(VertexArrayName, semantic::attr::TEXCOORD, <span class="hljs-number">0</span>);
  glVertexArrayAttribFormat(VertexArrayName, semantic::attr::TEXCOORD, <span class="hljs-number">2</span>, GL_FLOAT, 
    GL_FALSE, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>) * <span class="hljs-number">2</span>);

  glVertexArrayElementBuffer(VertexArrayName, BufferName[buffer::ELEMENT]);
  glVertexArrayVertexBuffer(VertexArrayName, <span class="hljs-number">0</span>, BufferName[buffer::VERTEX], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);

  <span class="hljs-keyword">return</span> vertexArrayName;
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="example-3-querying-the-bound-texture-to-a-texture-image-unit-for-debugging"></a><a href="#example-3-querying-the-bound-texture-to-a-texture-image-unit-for-debugging" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example 3: Querying the bound texture to a texture image unit for debugging</h2>
<pre><code class="hljs css language-cpp"><span class="hljs-comment">// Select to query</span>
<span class="hljs-comment">// We need the &lt;target&gt; or we need to loop over all the possible targets</span>
<span class="hljs-function">GLuint <span class="hljs-title">GetBoundTexture</span><span class="hljs-params">(GLenum target, GLuint unit)</span>
</span>{
  GLuint restore = <span class="hljs-number">0</span>;
  glGetIntegerv(GL_ACTIVE_TEXTURE, &amp;restore);

  glActiveTexture(unit);

  GLuint name = <span class="hljs-number">0</span>;
  glGetIntegerv(target, &amp;name);

  glActiveTexture(restore);
}

<span class="hljs-comment">// Direct State Access</span>
<span class="hljs-comment">// target_binding is e.g. GL_TEXTURE_BINDING_2D for the 2D texture</span>
<span class="hljs-function">GLuint <span class="hljs-title">GetBoundTexture</span><span class="hljs-params">(GLenum target_binding, GLuint unit)</span>
</span>{
  GLuint name = <span class="hljs-number">0</span>;
  glGetIntegeri_v(target_binding, unit, &amp;name);
  <span class="hljs-keyword">return</span> name;
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="debug-output"></a><a href="#debug-output" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Debug Output</h2>
<p>L'extension Debug Output (<a href="https://www.opengl.org/registry/specs/ARB/debug_output.txt">GL_ARB_debug_output</a>, puis introduite en Core 4.3) à fait beaucoup de bien aux développeurs OpenGL puisqu'elle fournit un méchanisme de messages d'erreurs bien plus efficace que l'ignoble fonction <em>glGetError</em>.</p>
<p>L'idée est de donner une fonction de callback à OpenGL qui sera appelée par l'implémentation dès qu'une erreur est rencontrée. Il est de plus possible de filtrer de manière assez fine les erreurs/warning à ignorer.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/openglnoel/docs/gold-06-course-02-gpu-pipeline"><span class="arrow-prev">← </span><span>Pipeline de Rendu</span></a><a class="docs-next button" href="/openglnoel/docs/gold-06-course-04-opengl-objects"><span class="function-name-prevnext">Objets OpenGL</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#direct-state-access">Direct State Access</a></li><li><a href="#example-1-creating-a-buffer-object-without-polluting-the-opengl-states">Example 1: Creating a buffer object without polluting the OpenGL states</a></li><li><a href="#example-2-creating-a-vertex-array-object-without-polluting-the-opengl-states">Example 2: Creating a vertex array object without polluting the OpenGL states</a></li><li><a href="#example-3-querying-the-bound-texture-to-a-texture-image-unit-for-debugging">Example 3: Querying the bound texture to a texture image unit for debugging</a></li><li><a href="#debug-output">Debug Output</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/openglnoel/" class="nav-home"><img src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]" width="66" height="58"/></a><div><h5>About Me</h5><a href="http://laurentnoel.fr">Personal website</a><a href="https://github.com/Celeborn2BeAlive/">Github</a></div><div><h5>About This Website</h5><a href="/openglnoel/blog">Blog</a><a class="github-button" href="https://github.com/celeborn2bealive/openglnoel" data-icon="octicon-star" data-count-href="/celeborn2bealive/openglnoel/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">openglnoel</a><a href="https://docusaurus.io/">Powered by Docusaurus</a></div><div><h5>About OpenGL</h5><a href="docs.gl">Documentation (docs.gl)</a><a href="https://www.khronos.org/opengl/wiki/">Wiki</a></div></section><section class="copyright">Copyright © 2019 Laurent NOEL</section></footer></div></body></html>