<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Aller plus loin · OpenGL[&quot;noël&quot;]</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;Voici plusieurs choses améliorable pour rendre notre deferred renderer plus interessant:&lt;/p&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Aller plus loin · OpenGL[&quot;noël&quot;]"/><meta property="og:type" content="website"/><meta property="og:url" content="https://celeborn2bealive.github.io/openglnoel/index.html"/><meta property="og:description" content="&lt;p&gt;Voici plusieurs choses améliorable pour rendre notre deferred renderer plus interessant:&lt;/p&gt;
"/><meta property="og:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><link rel="shortcut icon" href="/openglnoel/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/atom.xml" title="OpenGL[&quot;noël&quot;] Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/feed.xml" title="OpenGL[&quot;noël&quot;] Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/openglnoel/js/code-block-buttons.js"></script><script type="text/javascript" src="/openglnoel/js/disqus.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><link rel="stylesheet" href="/openglnoel/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/openglnoel/"><img class="logo" src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]"/><h2 class="headerTitleWithLogo">OpenGL[&quot;noël&quot;]</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction" target="_self">Introduction et SDK</a></li><li class=""><a href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base" target="_self">Bronze</a></li><li class=""><a href="/openglnoel/docs/silver-01-3d-theorie-01-introduction" target="_self">Silver</a></li><li class="siteNavGroupActive"><a href="/openglnoel/docs/gold-01-intro-sdk-01-introduction" target="_self">Gold</a></li><li class=""><a href="/openglnoel/blog/" target="_self">Blog</a></li><li class=""><a href="http://docs.gl" target="_self">OpenGL Documentation</a></li><li class=""><a href="https://www.khronos.org/opengl/wiki/" target="_self">OpenGL Wiki</a></li><li class=""><a href="https://github.com/celeborn2bealive/openglnoel" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Deferred Renderer</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction et SDK</h3><ul><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-01-intro-sdk-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-01-intro-sdk-03-fiche-info">Fiche d&#x27;information</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-01-intro-sdk-05-projet">Projet - Un viewer glTF</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Forward Renderer</h3><ul><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-01-pipeline">Pipeline de Rendu</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-02-geometrie">Geometrie</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-03-shaders">Shaders</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-04-transformations">Transformations</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-05-lighting">Lighting</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-06-textures">Textures</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-07-load-obj">Chargement de modèles OBJ</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-08-plus-loin">Aller plus loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Deferred Renderer</h3><ul><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-01-pipeline">Pipeline de Rendu</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-02-geometry-pass">Geometrie Pass</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-03-shading-pass">Shading Pass</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-04-plus-loin">Aller plus loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Shadow Mapping</h3><ul><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-02-dir-shadow-map">Directional Shadow Map</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-03-percentage-closest-filtering">Percentage Closest Filtering</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-04-aller-plus-loin">Aller Plus Loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Post Processing</h3><ul><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-02-gamma-correction">Gamma Correction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-03-extraction-contours">Extraction et Rendu de Contours</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-04-depth-of-field">Depth of Field</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Annexe: API OpenGL</h3><ul><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-01-opengl-context">Contexte OpenGL</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-02-gpu-pipeline">Pipeline de Rendu</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-03-opengl-extensions">Extensions OpenGL</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-04-opengl-objects">Objets OpenGL</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-05-buffer-objects">Buffer Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-06-vertex-array-objects">Vertex Array Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-07-textures">Texture Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-08-framebuffer-objects">Framebuffer Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-09-shaders">Shaders</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Aller plus loin</h1></header><article><div><span><p>Voici plusieurs choses améliorable pour rendre notre deferred renderer plus interessant:</p>
<h2><a class="anchor" aria-hidden="true" id="compute-shader-pour-la-shading-pass"></a><a href="#compute-shader-pour-la-shading-pass" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Compute Shader pour la Shading Pass</h2>
<p>Dessiner un quad pour la shading pass, c'est en réalité se compliquer la vie pour rien. Tout ce qu'on veut c'est traiter chacun des pixels du GBuffer, en parallèle sur GPU. D'une certaine manière, ce qu'on aimerait faire c'est un genre de kernel Cuda.</p>
<p>Ca tombe bien, les compute shaders (dispo depuis OpenGL 4.3) permettent exactement de faire ça.</p>
<p>Trouvez vous un tuto sur le net sur les compute shaders et essayez d'adapter votre shading pass pour utiliser un CS plutot que dessin quad + VS + FS.</p>
<h2><a class="anchor" aria-hidden="true" id="light-culling-simple"></a><a href="#light-culling-simple" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Light Culling simple</h2>
<p>Il est assez facile en deferred de faire le rendu de la contribution de plusieurs lights en accumulant le résultat de plusieurs shading pass.</p>
<p>De plus, avec des lights dont l'interaction est limités dans l'espace (point light avec un radius par exemple), il est possible de remplacer le dessin du Quad par une forme quelquonque qui vient couvrir en espace ecran la forme du volume projeté de la light. On traite ainsi moins de pixels a chaque shading pass et on gagne du temps. Les <a href="http://ogldev.atspace.co.uk/www/tutorial36/tutorial36.html">parties 2 et 3</a> du tutorial d'ogldev détaillent cette méthode. Implémentez là.</p>
<blockquote>
<p>Ces deux exercices sont un peu antagonistes. Dans le premier on remplace le dessin du Quad par l'execution d'un compute shader.
Dans le deuxième on remplace le dessin du Quad par des dessins de différents formes.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="conclusion-et-forward"></a><a href="#conclusion-et-forward" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion et Forward+</h2>
<p>Ces deux premiers TPs vous ont permis d'implémenter les deux pipelines de rendu temps réel les plus utilisé: forward et deferred.</p>
<p>Ils ont tous les deux des avantages et inconvénients:</p>
<h3><a class="anchor" aria-hidden="true" id="forward"></a><a href="#forward" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Forward</h3>
<p>Avantages:</p>
<ul>
<li>Simple a mettre en oeuvre, un seul programme GLSL</li>
<li>Accès aux propriétés de l'objet en cours de rendu au moment de l'illumination via les uniforms</li>
<li>Possibilité d'exploiter les techniques d'anti-aliasing du GPU</li>
</ul>
<p>Désavantages:</p>
<ul>
<li>Potentiellement beaucoup de fragment traités puis occultés</li>
<li>Pas d'information globale sur l'ensemble de la géométrie visible (en tout cas pas sans précalcul)</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="deferred"></a><a href="#deferred" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Deferred</h3>
<p>Avantages:</p>
<ul>
<li>Possibilité d'utiliser le GBuffer pour faire du light culling, post-process ou autre</li>
<li>Shading pass seulement sur les fragments non occultés -&gt; gain de perfs si shading pass couteuse (souvent le cas)</li>
</ul>
<p>Désavantages:</p>
<ul>
<li>Gourmand en mémoire et bande passante (grosse résolution = grosses textures à sortir, vive la 4K et la VR !)</li>
<li>Pour avoir accès a des informations sur les objets à rendre dans la shading pass, il faut les écrire dans des textures -&gt; difficile de mélanger différent modèles de shading sur un meme rendu</li>
<li>Par defaut, impossible de rendre des objets transparents</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="forward-1"></a><a href="#forward-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Forward+</h3>
<p>Une autre méthode a été développé par AMD, appelé Forward + (<a href="http://www.gdcvault.com/play/1016435/Forward-Rendering-Pipeline-for-Modern">voir ici</a> et <a href="http://fr.slideshare.net/takahiroharada/forward-34779335">la</a>), qui tente d'obtenir les avantages des deux méthodes sans les inconvénients.</p>
<p>Sans trop entrer dans les détails, voici le fonctionnement général de l'algo:</p>
<ul>
<li>depth pré-pass: rendu uniquement du depth buffer</li>
<li>light culling: utilisation du depth buffer pour associer les lights à des tiles de pixels</li>
<li>lighting: rendu en forward, mais utilisation du depth buffer précalculé pour discard les fragments occultés, + utilisation des lights associés aux tiles de pixels</li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/openglnoel/docs/gold-03-deferred-renderer-03-shading-pass"><span class="arrow-prev">← </span><span>Shading Pass</span></a><a class="docs-next button" href="/openglnoel/docs/gold-04-shadow-mapping-01-introduction"><span>Introduction</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#compute-shader-pour-la-shading-pass">Compute Shader pour la Shading Pass</a></li><li><a href="#light-culling-simple">Light Culling simple</a></li><li><a href="#conclusion-et-forward">Conclusion et Forward+</a><ul class="toc-headings"><li><a href="#forward">Forward</a></li><li><a href="#deferred">Deferred</a></li><li><a href="#forward-1">Forward+</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/openglnoel/" class="nav-home"><img src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]" width="66" height="58"/></a><div><h5>About Me</h5><a href="http://laurentnoel.fr">Personal website</a><a href="https://github.com/Celeborn2BeAlive/">Github</a></div><div><h5>About This Website</h5><a href="/openglnoel/blog">Blog</a><a class="github-button" href="https://github.com/celeborn2bealive/openglnoel" data-icon="octicon-star" data-count-href="/celeborn2bealive/openglnoel/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">openglnoel</a><a href="https://docusaurus.io/">Powered by Docusaurus</a></div><div><h5>About OpenGL</h5><a href="docs.gl">Documentation (docs.gl)</a><a href="https://www.khronos.org/opengl/wiki/">Wiki</a></div></section><section class="copyright">Copyright © 2019 Laurent NOEL</section></footer></div></body></html>