<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Introduction · OpenGL[&quot;noël&quot;]</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&gt; &lt;span class=&quot;badge warning&quot;&gt;&lt;/span&gt; La partie Silver n&#x27;a pas encore été adaptée au nouveau template disponible sur Github."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Introduction · OpenGL[&quot;noël&quot;]"/><meta property="og:type" content="website"/><meta property="og:url" content="https://celeborn2bealive.github.io/openglnoel/"/><meta property="og:description" content="&gt; &lt;span class=&quot;badge warning&quot;&gt;&lt;/span&gt; La partie Silver n&#x27;a pas encore été adaptée au nouveau template disponible sur Github."/><meta property="og:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><link rel="shortcut icon" href="/openglnoel/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/atom.xml" title="OpenGL[&quot;noël&quot;] Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/feed.xml" title="OpenGL[&quot;noël&quot;] Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/openglnoel/js/code-block-buttons.js"></script><script type="text/javascript" src="/openglnoel/js/disqus.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/openglnoel/js/scrollSpy.js"></script><link rel="stylesheet" href="/openglnoel/css/main.css"/><script src="/openglnoel/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/openglnoel/"><img class="logo" src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]"/><h2 class="headerTitleWithLogo">OpenGL[&quot;noël&quot;]</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction" target="_self">Intro et SDK</a></li><li class=""><a href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base" target="_self">Bronze</a></li><li class="siteNavGroupActive siteNavItemActive"><a href="/openglnoel/docs/silver-01-3d-theorie-01-introduction" target="_self">Silver</a></li><li class=""><a href="/openglnoel/docs/gold-01-intro-sdk-01-introduction" target="_self">Gold</a></li><li class=""><a href="/openglnoel/blog/" target="_self">Blog</a></li><li class=""><a href="http://docs.gl" target="_self">OpenGL Documentation</a></li><li class=""><a href="https://www.khronos.org/opengl/wiki/" target="_self">OpenGL Wiki</a></li><li class=""><a href="https://github.com/celeborn2bealive/openglnoel" target="_self">GitHub</a></li><li class=""><a href="https://gltf-viewer-tutorial.gitlab.io" target="_self">My glTF Viewer Tutorial</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>3D - La théorie</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">3D - La théorie</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/openglnoel/docs/silver-01-3d-theorie-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-01-3d-theorie-02-normal-matrix">La Normal Matrix</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-01-3d-theorie-03-3d-vertex-shader">Un exemple de Vertex Shader pour la 3D</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-01-3d-theorie-04-glm">La bibliothèque glm</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">3D - La pratique</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-02-classe-sphere-cone">Les classes Sphere et Cone</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-03-dessiner-sphere">Dessiner une sphere</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-04-dessiner-lune">Dessiner une lune</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-05-dessiner-terre">Dessiner la terre</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-06-multi-texturing">Multi-texturing</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-07-plusieurs-shaders">Utiliser plusieurs shaders</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Gestion de la caméra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-03-camera-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-03-camera-02-trackball-camera">Trackball Camera</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-03-camera-03-freefly-camera">Freefly Camera</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Put the lights on !</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-04-lighting-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-04-lighting-02-directional-light">Directional Light</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-04-lighting-03-point-light">Point Light</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-04-lighting-04-aller-plus-loin">Aller plus loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Projet(s)</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-05-projets-01-iminecraft">Projet: IM(A)ineCraft</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Introduction</h1></header><article><div><span><blockquote>
<p><span class="badge warning"></span> La partie Silver n'a pas encore été adaptée au nouveau template disponible sur Github.</p>
</blockquote>
<p>Pour &quot;dessiner&quot; des objets en 3D sur une surface 2D (votre écran), il est nécéssaire d'appliquer une projection. En réalité OpenGL a très peu de connaissances sur votre 3D: l'algorithme de rasterization est appliqué sur les coordonnées projetées avec l'ajout de la profondeur simplement pour décider si un fragment vient masquer un fragment déjà présent dans le framebuffer. Nous allons donc commencer par une partie un peu théorique pour détailler chaque espace de coordonnée.</p>
<h2><a class="anchor" aria-hidden="true" id="coordonnées-homogènes"></a><a href="#coordonnées-homogènes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Coordonnées homogènes</h2>
<p>Bien que l'on travaille en 3D, on utilisera le plus souvent des vecteur 4D pour représenter nos points / vecteurs et des matrices 4x4 pour représenter nos transformations.</p>
<p>Si l'on ne fait pas ça, on ne peut pas 1) représenter la translation avec une matrice et 2) représenter la projection avec une matrice. Or il est interessant de pouvoir faire cela afin de combiner toutes les transformations simplement en multipliant les matrices.</p>
<p>Notre application enverra des vecteurs 3D au GPU et dans les shaders nous les transformerons en vecteur 4D en respectant la règle suivante: si l'entité est un point (une position) on ajoute 1 comme quatrième coordonnées, si c'est un vecteur (une normale par exemple) on ajoute 0 comme quatrième coordonnées.</p>
<ul>
<li>Position \((x,y,z) \rightarrow (x,y,z,1)\)</li>
<li>Vecteur \((x,y,z) \rightarrow (x,y,z,0)\)</li>
</ul>
<p>De cette manière une position est correctement translaté par une matrice de translation et un vecteur ne bouge pas (ce qui est cohérent car un vecteur n'a pas de position).</p>
<p><span class="badge todo"></span> Soit la matrice de translation 4x4 \(T_{tx,ty,tz} = \begin{pmatrix}
1&amp;0&amp;0&amp;tx \\
0&amp;1&amp;0&amp;ty \\
0&amp;0&amp;1&amp;tz \\
0&amp;0&amp;0&amp;1
\end{pmatrix}\).
Vérifiez sur papier qu'en multipliant \(T_{tx,ty,tz}\) par \(P_1=(x,y,z,1)\) on obtient bien \(P_2=(x+tx,y+ty,z+tz,1)\) et qu'en multipliant \(T_{tx,ty,tz}\) par \(V_1=(x,y,z,0)\) on obtient bien \(V_2=(x,y,z,0)\). Attention à l'ordre de multiplication: \(P_2=T_{tx,ty,tz}P1\) (toujours l'entité à transformer à droite et la matrice à gauche).</p>
<h2><a class="anchor" aria-hidden="true" id="vue-globale-des-transformations"></a><a href="#vue-globale-des-transformations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Vue globale des transformations</h2>
<p><img src="/openglnoel/img/coordinates.svg" alt="coordinates"></p>
<p>Ce schéma donne une vision globale de la suite de transformations appliquées sur un vertex. La partie en jaune doit être implantée dans votre vertex shader. Il est très facile de transformer le sommet d'entrée: il suffit d'appliquer une ou plusieurs multiplication matricielle pour calculer la variable de sortie <strong>gl_Position</strong>.</p>
<h2><a class="anchor" aria-hidden="true" id="model-coordinates"></a><a href="#model-coordinates" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Model Coordinates</h2>
<p>Les Model Coordinates (MC) sont les coordonnées des sommets dans l'espace local à l'objet courant. Ce sont celles qui sont fournies par l'application en les stockant dans des VBOs. Par exemple dans les TP précédents les MC de notre triangle étaient: \(P1=(−1,−1)\), \(P2=(1,−1)\) et \(P3=(0,1)\).</p>
<p>Les fichiers générés par les logiciels de modélisation 3D contiennent les MC des objets.</p>
<h2><a class="anchor" aria-hidden="true" id="world-coordinates"></a><a href="#world-coordinates" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>World Coordinates</h2>
<p>Les World Coordinates (WC) sont les coordonnées des sommets dans l'espace du monde. Chaque objet possède une Model Matrix \(M\) permettant d'obtenir les WC de ses sommets à partir des MC. Si on note \(P_m\) les MC d'un sommet et \(P_w\) ses WC, on a la relation suivante:</p>
<p>$$
P_w=M \times P_m
$$</p>
<p>Chaque colonne de la Model Matrix d'un objet est un vecteur du repère de ce dernier exprimé le monde. La 4ème colonne est l'origine du repère. Voici un schéma (coordonnées en 2D pour la lisibilité) pour mieux comprendre:</p>
<p><img src="/openglnoel/img/model_matrix.png" alt="Transform"></p>
<h2><a class="anchor" aria-hidden="true" id="view-coordinates"></a><a href="#view-coordinates" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>View Coordinates</h2>
<p>Les View Coordinates (VC) sont les coordonnées des sommets dans l'espace de la caméra. On les obtient en multipliant les WC par la View Matrix \(V\):</p>
<p>$$
P_v=V \times P_w = V \times M \times P_m
$$</p>
<p>La matrice \(MV=V \times M\) est appelée la ModelView Matrix. Attention: on la nomme dans l'ordre inverse de la multiplication.</p>
<p>Les colonnes de la matrice View sont les vecteurs du repère du monde exprimé dans le repère de la caméra (la 4eme colonne est l'origine du monde exprimé dans le repère de la caméra). On peut voir la View Matrix comme une Model Matrix pour le monde complet (vu comme un unique objet).</p>
<h2><a class="anchor" aria-hidden="true" id="clip-coordinates"></a><a href="#clip-coordinates" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Clip Coordinates</h2>
<p>Les Clip Coordinates (CC) sont les coordonnées qu'il faut placer dans la variable <strong>gl_Position</strong> du fragment shader. Le GPU prend ensuite le relai. On les obtient en multipliant les VC par la Projection Matrix \(P\):</p>
<p>$$
P_{clip} = P \times P_w = P \times V \times M \times P_m
$$</p>
<p>La matrice \(MVP=P \times V \times M\) est appelée la ModelViewProjection Matrix.</p>
<h2><a class="anchor" aria-hidden="true" id="les-normalized-device-coordinates-ndc"></a><a href="#les-normalized-device-coordinates-ndc" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Les Normalized Device Coordinates (NDC)</h2>
<p>Les NDC sont calculées par le GPU en divisant les CC par la quatrième composante. Soit \(P_{clip}=(x_{clip},y_{clip},z_{clip},w_{clip})\) un point exprimé en Clip Coordinates. Alors on a:</p>
<p>$$
P_{ndc}=(x_{ndc},y_{ndc},z_{ndc})=(x_{clip}/w_{clip},y_{clip}/w_{clip},z_{clip}/w_{clip})
$$</p>
<p>On remarque qu'a partir de ce point, le GPU ne travaille plus en coordonnées homogènes.</p>
<p>On a de plus une propriété interessante: sur chacun des axes les NDC sont comprisent entre -1 et 1 pour les points visibles depuis la caméra. Si un fragment a ses NDC non comprisent entre -1 et 1 alors GPU ne le traitera pas.</p>
<h2><a class="anchor" aria-hidden="true" id="window-coordinates"></a><a href="#window-coordinates" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Window Coordinates</h2>
<p>Les Window Coordinates (WC) sont les coordonnées de fragments exprimés en pixels. OpenGL utilise les données passées en utilisant la fonction <strong>glViewport(X, Y, W, H)</strong> (qui définit la zone de la fenêtre dans laquelle dessiner) et la fonction <strong>glDepthRange(N, F)</strong> (qui définit la range de profondeur) pour obtenir les WC à partir des NDC:</p>
<p>$$
(x_{wc},y_{wc},z_{wc})=(\frac{W}{2}x_{ndc}+(X+\frac{W}{2}),\frac{H}{2}y_{ndc}+(Y+\frac{H}{2}),\frac{F−N}{2}z_{ndc}+\frac{F+N}{2})
$$</p>
<p>\((x_{wc},y_{wc})\) définit les coordonnées du pixel qui recevra la couleur du fragment et \(z_{wc}\) est la profondeur qui sera écrite dans le Depth Buffer si le Depth Test est activé.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-next button" href="/openglnoel/docs/silver-01-3d-theorie-02-normal-matrix"><span>La Normal Matrix</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#coordonnées-homogènes">Coordonnées homogènes</a></li><li><a href="#vue-globale-des-transformations">Vue globale des transformations</a></li><li><a href="#model-coordinates">Model Coordinates</a></li><li><a href="#world-coordinates">World Coordinates</a></li><li><a href="#view-coordinates">View Coordinates</a></li><li><a href="#clip-coordinates">Clip Coordinates</a></li><li><a href="#les-normalized-device-coordinates-ndc">Les Normalized Device Coordinates (NDC)</a></li><li><a href="#window-coordinates">Window Coordinates</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/openglnoel/" class="nav-home"><img src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]" width="66" height="58"/></a><div><h5>About Me</h5><a href="http://laurentnoel.fr">Personal website</a><a href="https://github.com/Celeborn2BeAlive/">Github</a></div><div><h5>About This Website</h5><a href="/openglnoel/blog">Blog</a><a class="github-button" href="https://github.com/celeborn2bealive/openglnoel" data-icon="octicon-star" data-count-href="/celeborn2bealive/openglnoel/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">openglnoel</a><a href="https://docusaurus.io/">Powered by Docusaurus</a></div><div><h5>About OpenGL</h5><a href="docs.gl">Documentation (docs.gl)</a><a href="https://www.khronos.org/opengl/wiki/">Wiki</a></div></section><section class="copyright">Copyright © 2021 Laurent NOEL</section></footer></div></body></html>