<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Geometrie Pass · OpenGL[&quot;noël&quot;]</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Comme indiqué en introduction, la première passe de rendu est la Geometry Pass, dont l&#x27;objectif est de &quot;dessiner&quot; dans un GBuffer les informations concernant les objets visibles à l&#x27;écran."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Geometrie Pass · OpenGL[&quot;noël&quot;]"/><meta property="og:type" content="website"/><meta property="og:url" content="https://celeborn2bealive.github.io/openglnoel/"/><meta property="og:description" content="Comme indiqué en introduction, la première passe de rendu est la Geometry Pass, dont l&#x27;objectif est de &quot;dessiner&quot; dans un GBuffer les informations concernant les objets visibles à l&#x27;écran."/><meta property="og:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><link rel="shortcut icon" href="/openglnoel/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/atom.xml" title="OpenGL[&quot;noël&quot;] Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/feed.xml" title="OpenGL[&quot;noël&quot;] Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/openglnoel/js/code-block-buttons.js"></script><script type="text/javascript" src="/openglnoel/js/disqus.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/openglnoel/js/scrollSpy.js"></script><link rel="stylesheet" href="/openglnoel/css/main.css"/><script src="/openglnoel/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/openglnoel/"><img class="logo" src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]"/><h2 class="headerTitleWithLogo">OpenGL[&quot;noël&quot;]</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/openglnoel/docs/gltf-viewer-01-intro-01-intro" target="_self">glTF Viewer Tutorial</a></li><li class=""><a href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction" target="_self">Intro et SDK</a></li><li class=""><a href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base" target="_self">Bronze</a></li><li class=""><a href="/openglnoel/docs/silver-01-3d-theorie-01-introduction" target="_self">Silver</a></li><li class="siteNavGroupActive"><a href="/openglnoel/docs/gold-01-intro-sdk-01-introduction" target="_self">Gold</a></li><li class=""><a href="/openglnoel/blog/" target="_self">Blog</a></li><li class=""><a href="http://docs.gl" target="_self">OpenGL Documentation</a></li><li class=""><a href="https://www.khronos.org/opengl/wiki/" target="_self">OpenGL Wiki</a></li><li class=""><a href="https://github.com/celeborn2bealive/openglnoel" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Deferred Renderer</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction et SDK</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-01-intro-sdk-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-01-intro-sdk-03-fiche-info">Fiche d&#x27;information</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-01-intro-sdk-05-projet">Projet - Un viewer glTF</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Forward Renderer</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-01-pipeline">Pipeline de Rendu</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-02-geometrie">Geometrie</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-03-shaders">Shaders</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-04-transformations">Transformations</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-05-lighting">Lighting</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-06-textures">Textures</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-07-load-obj">Chargement de modèles OBJ</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-08-plus-loin">Aller plus loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Deferred Renderer</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-01-pipeline">Pipeline de Rendu</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-02-geometry-pass">Geometrie Pass</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-03-shading-pass">Shading Pass</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-04-plus-loin">Aller plus loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Shadow Mapping</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-02-dir-shadow-map">Directional Shadow Map</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-03-percentage-closest-filtering">Percentage Closest Filtering</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-04-aller-plus-loin">Aller Plus Loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Post Processing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-02-gamma-correction">Gamma Correction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-03-extraction-contours">Extraction et Rendu de Contours</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-04-depth-of-field">Depth of Field</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Annexe: API OpenGL</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-01-opengl-context">Contexte OpenGL</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-02-gpu-pipeline">Pipeline de Rendu</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-03-opengl-extensions">Extensions OpenGL</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-04-opengl-objects">Objets OpenGL</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-05-buffer-objects">Buffer Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-06-vertex-array-objects">Vertex Array Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-07-textures">Texture Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-08-framebuffer-objects">Framebuffer Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-09-shaders">Shaders</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Geometrie Pass</h1></header><article><div><span><p>Comme indiqué en introduction, la première passe de rendu est la Geometry Pass, dont l'objectif est de &quot;dessiner&quot; dans un GBuffer les informations concernant les objets visibles à l'écran.</p>
<p>Pour cela, il va falloir créer les textures OpenGL destinées à contenir ces informations, et les attacher à un <strong>framebuffer object</strong>, qui va permettre d'écrire dans ces textures plutot qu'a l'écran.</p>
<p>Pour ces TPs, dupliquez l'app de l'exercice du foward renderer afin d'avoir une scene chargée et stockée sur GPU pour être rendue.
Nommez la nouvelle app &quot;deferred-renderer&quot;.</p>
<h2><a class="anchor" aria-hidden="true" id="shaders"></a><a href="#shaders" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Shaders</h2>
<p>Nous allons commencer par les shaders car c'est le plus simple.
Renommez les shaders <em>forward.vs.glsl</em> et <em>forward.fs.glsl</em> en <em>geometryPass.vs.glsl</em> et <em>geometryPass.fs.glsl</em>.</p>
<p>Il faut ensuite modifier le fragment shader (plus exactement le simplifier).</p>
<p>Tout d'abord modifier les sorties. On avait:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fColor;
</code></pre>
<p>a remplacer par:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fPosition;
<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fNormal;
<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fAmbient;
<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">3</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fDiffuse;
<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">location</span> = <span class="hljs-number">4</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> fGlossyShininess;
</code></pre>
<p>On va donc écrire dans 5 textures en tout.</p>
<p>Dans le main du shader, remplacez tout le code d'illumination par des écritures dans les variables de sortie. Ne pas oublier de normaliser <em>vViewSpaceNormal</em> avant de l'écrire dans <em>fNormal</em>.</p>
<p>A noter que l'on écrit pas les texCoords en sortie car on ne les utilise que pour lire les coefficients ambiant, diffus et glossy des textures de l'objet en cours de rendu. Les texCoords ne sont donc pas necessaire à la Shading Pass puisqu'on écrit directement ces coefficients dans des textures du GBuffer.</p>
<p>Les variables de sortie de matériaux doivent stocker la multiplication du coefficient associé avec la valeur lue dans la texture. Par exemple:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> uKd;
<span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> uKdSampler;

[...]

<span class="hljs-comment">// Dans le main:</span>
<span class="hljs-type">vec3</span> kd = uKd * <span class="hljs-type">vec3</span>(<span class="hljs-built_in">texture</span>(uKdSampler, vTexCoords));
fDiffuse = kd;
</code></pre>
<p>Enfin, il faut packer la shininess dans le canal alpha de la variable de sortie <em>fGlossyShininess</em>.</p>
<p>Dans le code de Application, chargez ces shaders pour tester leur compilation.</p>
<h2><a class="anchor" aria-hidden="true" id="textures-du-gbuffer"></a><a href="#textures-du-gbuffer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Textures du GBuffer</h2>
<p>Dans la classe Application, déclarez un tableau de <em>GLuint</em> pour stocker les texture objects, ainsi que l'enum suivant:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-keyword">enum</span> GBufferTextureType
{
    GPosition = <span class="hljs-number">0</span>,
    GNormal,
    GAmbient,
    GDiffuse,
    GGlossyShininess,
    GDepth, <span class="hljs-comment">// On doit créer une texture de depth mais on écrit pas directement dedans dans le FS. OpenGL le fait pour nous (et l'utilise).</span>
    GBufferTextureCount
};
GLuint m_GBufferTextures[GBufferTextureCount];
</code></pre>
<p>Dans le constructeur, créer et initialiser ces textures avec comme dimension la taille de la fenêtre.</p>
<blockquote>
<p>Vous pouvez créer toutes les textures en un seul appel à glGenTextures (ou glCreateTextures en DSA) car nos identifiants sont stockés dans un tableau. Il suffit de passer à la fonction le nombre de textures à créer.</p>
</blockquote>
<p>Le format à passer à <em>glTexStorage2D</em> dépend du type de texture, vous pouvez utiliser le tableau suivant, en correspondance avec l'enum:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-keyword">const</span> GLenum m_GBufferTextureFormat[GBufferTextureCount] = { GL_RGB32F, GL_RGB32F, GL_RGB32F, GL_RGB32F, GL_RGBA32F, GL_DEPTH_COMPONENT32F };
</code></pre>
<p>Il est inutile de remplir les textures avec <em>glTexSubImage2D</em> car elles sont destinées à être remplies par le fragment shader.</p>
<p>Fonctions GL à utiliser:</p>
<table>
<thead>
<tr><th>Sans DSA</th><th>DSA</th></tr>
</thead>
<tbody>
<tr><td>glGenTextures</td><td>glCreateTextures</td></tr>
<tr><td>glBindTexture(GL_TEXTURE_2D, texID)</td><td></td></tr>
<tr><td>glTexStorage2D</td><td>glTextureStorage2D</td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="framebuffer-object"></a><a href="#framebuffer-object" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Framebuffer object</h2>
<p>Déclarez une variable <em>GLuint m_FBO</em> dans la classe Application.</p>
<p>Dans le constructeur, après création des texture objects, créez le FBO (<em>glGenFramebuffers</em>) et bindez le sur la cible <em>GL_DRAW_FRAMEBUFFER</em>.</p>
<p>Il faut ensuite attacher toutes nos textures au FBO en utilisant la fonction <em>glFramebufferTexture2D</em>.</p>
<pre><code class="hljs css language-cpp">glFramebufferTexture2D( GLenum target,
    GLenum attachment,
    GLenum textarget,
    GLuint texture,
    GLint level);
</code></pre>
<p>La target est la cible sur laquelle est bindée de FBO (<em>GL_DRAW_FRAMEBUFFER</em>).</p>
<p>L'attachment est un point d'attache de la forme <em>GL_COLOR_ATTACHMENT0 + i</em>, ou <em>i</em> est l'index de la texture dans son tableau (de <em>GPosition</em> à <em>GGlossyShininess</em>).
Pour la texture de profondeur (<em>GDepth</em>), elle doit être attachée sur le point <em>GL_DEPTH_ATTACHMENT</em>.</p>
<p>Dans notre cas, <em>textarget</em> doit être mis à <em>GL_TEXTURE_2D</em> car toutes nos textures sont 2D (on pourrait aussi faire le rendu dans des layers de textures 3D, il faudrait alors changer ce paramètre).</p>
<p>Enfin, <em>level</em> doit être mis à 0 (c'est le niveau de mipmap dans lequel dessiner).</p>
<p>Une fois les textures attachées, il faut indiquer à OpenGL une association &quot;sortie du fragment shader&quot; vers texture.
Comme vous le verrez au prochain exercice, le fragment shader peut avoir plusieurs sorties indicées avec des <em>layout(location = i)</em> (de la meme manière que les entrée du vertex shader).
Il faut dire à OpenGL comment les locations doivent être connectées aux textures du FBO.</p>
<p>Cela passe par la fonction <em>glDrawBuffers</em>, qui prend le nombre de sorties du fragment shader et un tableau de <em>GL_COLOR_ATTACHMENTi</em> afin de faire la liaison. Nous allons faire assez simple:</p>
<pre><code class="hljs css language-cpp">GLenum drawBuffers[] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2, GL_COLOR_ATTACHMENT3, GL_COLOR_ATTACHMENT4 };
glDrawBuffers(<span class="hljs-number">5</span>, drawBuffers);
</code></pre>
<p>Ici on va envoyer la sortie <em>i</em> du fragment shader vers l'attachment <em>GL_COLOR_ATTACHMENTi</em> du FBO.
C'est ce qui parait le plus logique mais, si on voulait, on pourrait tout à fait envoyer la sortie 3 du fragment shader vers la texture attachée sur GL_COLOR_ATTACHMENT0, par exemple.</p>
<p>Utilisez ensuite la fonction <em>glCheckFramebufferStatus</em> afin de vérifier si le framebuffer créé est correct (si ce n'est pas le cas, bon debug !).</p>
<p>Enfin débindez le framebuffer de la cible <em>GL_DRAW_FRAMEBUFFER</em>.</p>
<p>Fonctions GL à utiliser:</p>
<table>
<thead>
<tr><th>Sans DSA</th><th>DSA</th></tr>
</thead>
<tbody>
<tr><td>glGenFramebuffers</td><td>glCreateFramebuffers</td></tr>
<tr><td>glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fbo)</td><td></td></tr>
<tr><td>glFramebufferTexture2D</td><td>glNamedFramebufferTexture</td></tr>
<tr><td>glDrawBuffers</td><td>glNamedFramebufferDrawBuffers</td></tr>
<tr><td>glCheckFramebufferStatus</td><td>glCheckNamedFramebufferStatus</td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="boucle-de-rendu"></a><a href="#boucle-de-rendu" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Boucle de rendu</h2>
<p>Au rendu assez peu de chose à changer.</p>
<p>Avant de dessiner, binder le framebuffer sur la cible <em>GL_DRAW_FRAMEBUFFER</em>. Cela va indiquer à OpenGL que le fragment shader va écrire dans les textures attachées au FBO.</p>
<p>Il faut également faire un <em>.use()</em> sur le programme correspondant aux <em>geometryPass.glsl</em></p>
<p>Après le dessin de la scène, débindez le FBO. Voila.</p>
<p>Pour tester que tout fonctionne bien, on peut blitter les textures du GBuffer à l'écran.</p>
<p>Après le débind du FBO, rebindez le, cette fois ci sur la cible <em>GL_READ_FRAMEBUFFER</em>.</p>
<p>Utilisez ensuite la fonction <em>glReadBuffer</em>, qui prend en paramètre un <em>GL_COLOR_ATTACHMENT0 + i</em>, correspondant à la texture du GBuffer que vous voulez afficher. Vous pouvez par example afficher la texture de normals en passant <em>GL_COLOR_ATTACHMENT0 + GNormal</em>. Faites ensuite en sorte de pouvoir choisir la texture à afficher via la GUI (avec des boutons radio, <em>ImgGui::RadioButton</em>).</p>
<p>Puis utilisez la fonction <em>glBlitFramebuffer</em> qui permet de &quot;copier-coller&quot; (avec filtre) une portion du FBO bindé sur <em>GL_READ_FRAMEBUFFER</em> vers le FBO bindé sur <em>GL_DRAW_FRAMEBUFFER</em> (c'est à dire l'écran, lorsque rien n'est bindé dessus).</p>
<p>Finalement, débindez le FBO de <em>GL_READ_FRAMEBUFFER</em>. A noter qu'en DSA il n'y a rien à binder pour l'étape du blit (il faut quand même binder sur <em>GL_DRAW_FRAMEBUFFER</em> avant de dessiner la scène).</p>
<p>Fonctions GL à utiliser:</p>
<table>
<thead>
<tr><th>Sans DSA</th><th>DSA</th></tr>
</thead>
<tbody>
<tr><td>glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fbo)</td><td>glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fbo)</td></tr>
<tr><td>glBindFramebuffer(GL_READ_FRAMEBUFFER, fbo)</td><td></td></tr>
<tr><td>glReadBuffer</td><td>glNamedFramebufferReadBuffer</td></tr>
<tr><td>glBlitFramebuffer</td><td>glBlitNamedFramebuffer</td></tr>
</tbody>
</table>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/openglnoel/docs/gold-03-deferred-renderer-01-pipeline"><span class="arrow-prev">← </span><span>Pipeline de Rendu</span></a><a class="docs-next button" href="/openglnoel/docs/gold-03-deferred-renderer-03-shading-pass"><span>Shading Pass</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#shaders">Shaders</a></li><li><a href="#textures-du-gbuffer">Textures du GBuffer</a></li><li><a href="#framebuffer-object">Framebuffer object</a></li><li><a href="#boucle-de-rendu">Boucle de rendu</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/openglnoel/" class="nav-home"><img src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]" width="66" height="58"/></a><div><h5>About Me</h5><a href="http://laurentnoel.fr">Personal website</a><a href="https://github.com/Celeborn2BeAlive/">Github</a></div><div><h5>About This Website</h5><a href="/openglnoel/blog">Blog</a><a class="github-button" href="https://github.com/celeborn2bealive/openglnoel" data-icon="octicon-star" data-count-href="/celeborn2bealive/openglnoel/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">openglnoel</a><a href="https://docusaurus.io/">Powered by Docusaurus</a></div><div><h5>About OpenGL</h5><a href="docs.gl">Documentation (docs.gl)</a><a href="https://www.khronos.org/opengl/wiki/">Wiki</a></div></section><section class="copyright">Copyright © 2020 Laurent NOEL</section></footer></div></body></html>