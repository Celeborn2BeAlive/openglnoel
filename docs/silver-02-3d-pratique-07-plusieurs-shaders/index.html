<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Utiliser plusieurs shaders · OpenGL[&quot;noël&quot;]</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;Là ça devient compliqué car chaque programme GPU (un programme = un vertex shader + un fragment shader) possède son propre ensemble de variables uniformes. Par exemple, si deux programmes utilise la variable uniforme &amp;quot;uMVPMatrix&amp;quot;, celle ci peu avoir une location différente pour chacun des deux programme. Il faudra donc récupérer deux fois sa location: une fois pour le premier programme et une fois pour le second programme.&lt;/p&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Utiliser plusieurs shaders · OpenGL[&quot;noël&quot;]"/><meta property="og:type" content="website"/><meta property="og:url" content="https://celeborn2bealive.github.io/openglnoel/"/><meta property="og:description" content="&lt;p&gt;Là ça devient compliqué car chaque programme GPU (un programme = un vertex shader + un fragment shader) possède son propre ensemble de variables uniformes. Par exemple, si deux programmes utilise la variable uniforme &amp;quot;uMVPMatrix&amp;quot;, celle ci peu avoir une location différente pour chacun des deux programme. Il faudra donc récupérer deux fois sa location: une fois pour le premier programme et une fois pour le second programme.&lt;/p&gt;
"/><meta property="og:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><link rel="shortcut icon" href="/openglnoel/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/atom.xml" title="OpenGL[&quot;noël&quot;] Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/feed.xml" title="OpenGL[&quot;noël&quot;] Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/openglnoel/js/code-block-buttons.js"></script><script type="text/javascript" src="/openglnoel/js/disqus.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><link rel="stylesheet" href="/openglnoel/css/main.css"/><script src="/openglnoel/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/openglnoel/"><img class="logo" src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]"/><h2 class="headerTitleWithLogo">OpenGL[&quot;noël&quot;]</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction" target="_self">Introduction et SDK</a></li><li class=""><a href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base" target="_self">Bronze</a></li><li class="siteNavGroupActive"><a href="/openglnoel/docs/silver-01-3d-theorie-01-introduction" target="_self">Silver</a></li><li class=""><a href="/openglnoel/docs/gold-01-intro-sdk-01-introduction" target="_self">Gold</a></li><li class=""><a href="/openglnoel/blog/" target="_self">Blog</a></li><li class=""><a href="http://docs.gl" target="_self">OpenGL Documentation</a></li><li class=""><a href="https://www.khronos.org/opengl/wiki/" target="_self">OpenGL Wiki</a></li><li class=""><a href="https://github.com/celeborn2bealive/openglnoel" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>3D - La pratique</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">3D - La théorie</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-01-3d-theorie-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-01-3d-theorie-02-normal-matrix">La Normal Matrix</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-01-3d-theorie-03-3d-vertex-shader">Un exemple de Vertex Shader pour la 3D</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-01-3d-theorie-04-glm">La bibliothèque glm</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">3D - La pratique</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-02-classe-sphere-cone">Les classes Sphere et Cone</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-03-dessiner-sphere">Dessiner une sphere</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-04-dessiner-lune">Dessiner une lune</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-05-dessiner-terre">Dessiner la terre</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-06-multi-texturing">Multi-texturing</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/openglnoel/docs/silver-02-3d-pratique-07-plusieurs-shaders">Utiliser plusieurs shaders</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Gestion de la caméra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-03-camera-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-03-camera-02-trackball-camera">Trackball Camera</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-03-camera-03-freefly-camera">Freefly Camera</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Put the lights on !</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-04-lighting-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-04-lighting-02-directional-light">Directional Light</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-04-lighting-03-point-light">Point Light</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-04-lighting-04-aller-plus-loin">Aller plus loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Projet(s)</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/silver-05-projets-01-iminecraft">Projet: IM(A)ineCraft</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Utiliser plusieurs shaders</h1></header><article><div><span><p>Là ça devient compliqué car chaque programme GPU (un programme = un vertex shader + un fragment shader) possède son propre ensemble de variables uniformes. Par exemple, si deux programmes utilise la variable uniforme &quot;uMVPMatrix&quot;, celle ci peu avoir une location différente pour chacun des deux programme. Il faudra donc récupérer deux fois sa location: une fois pour le premier programme et une fois pour le second programme.</p>
<p>Afin d'avoir un code à peu près propre, nous allons utiliser une structure pour représenter chaque programme. La structure <strong>EarthProgram</strong> contiendra le programme pour dessiner la terre, ainsi que les locations de chacun de ses variables uniforme. La structure <strong>MoonProgram</strong> contiendra la même chose mais pour les shaders correspondant à la lune.</p>
<p>Voici un exemple de ces deux structure dans mon code:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">EarthProgram</span> {</span>
    Program m_Program;

    GLint uMVPMatrix;
    GLint uMVMatrix;
    GLint uNormalMatrix;
    GLint uEarthTexture;
    GLint uCloudTexture;

    EarthProgram(<span class="hljs-keyword">const</span> FilePath&amp; applicationPath):
        m_Program(loadProgram(applicationPath.dirPath() + <span class="hljs-string">"shaders/3D.vs.glsl"</span>,
                              applicationPath.dirPath() + <span class="hljs-string">"shaders/multiTex3D.fs.glsl"</span>)) {
        uMVPMatrix = glGetUniformLocation(m_Program.getGLId(), <span class="hljs-string">"uMVPMatrix"</span>);
        uMVMatrix = glGetUniformLocation(m_Program.getGLId(), <span class="hljs-string">"uMVMatrix"</span>);
        uNormalMatrix = glGetUniformLocation(m_Program.getGLId(), <span class="hljs-string">"uNormalMatrix"</span>);
        uEarthTexture = glGetUniformLocation(m_Program.getGLId(), <span class="hljs-string">"uEarthTexture"</span>);
        uCloudTexture = glGetUniformLocation(m_Program.getGLId(), <span class="hljs-string">"uCloudTexture"</span>);
    }
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MoonProgram</span> {</span>
    Program m_Program;

    GLint uMVPMatrix;
    GLint uMVMatrix;
    GLint uNormalMatrix;
    GLint uTexture;

    MoonProgram(<span class="hljs-keyword">const</span> FilePath&amp; applicationPath):
        m_Program(loadProgram(applicationPath.dirPath() + <span class="hljs-string">"shaders/3D.vs.glsl"</span>,
                              applicationPath.dirPath() + <span class="hljs-string">"shaders/tex3D.fs.glsl"</span>)) {
        uMVPMatrix = glGetUniformLocation(m_Program.getGLId(), <span class="hljs-string">"uMVPMatrix"</span>);
        uMVMatrix = glGetUniformLocation(m_Program.getGLId(), <span class="hljs-string">"uMVMatrix"</span>);
        uNormalMatrix = glGetUniformLocation(m_Program.getGLId(), <span class="hljs-string">"uNormalMatrix"</span>);
        uTexture = glGetUniformLocation(m_Program.getGLId(), <span class="hljs-string">"uTexture"</span>);
    }
};
</code></pre>
<p>Puisque le shader <strong>tex3D.fs.glsl</strong> utilise une seule variable uniforme de texture, il n'y a qu'une seule variable membre pour stocker la location dans la structure MoonProgram ( contrairement à la structure EarthProgram qui en contient deux).</p>
<p>Il faut voir chacune de ces structure comme la représentation CPU du programme GPU associé. Elles nous permettent de faire facilement l'interface entre CPU et GPU.</p>
<p><span class="badge todo"></span> Ajoutez ces deux structures à votre code. Si besoin modifiez le nom des variables uniformes dans le constructeur ainsi que le nom de la variable membre associée pour stocker la location.</p>
<p><span class="badge todo"></span> Dans la fonction main du code C++, remplacez le chargement des shaders par une déclaration d'une variable pour chacune des structures:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-function">FilePath <span class="hljs-title">applicationPath</span><span class="hljs-params">(argv[<span class="hljs-number">0</span>])</span></span>;
<span class="hljs-function">EarthProgram <span class="hljs-title">earthProgram</span><span class="hljs-params">(applicationPath)</span></span>;
<span class="hljs-function">MoonProgram <span class="hljs-title">moonProgram</span><span class="hljs-params">(applicationPath)</span></span>;
</code></pre>
<p>Puisque nous avons à présent deux programmes GPU, on ne peut plus faire un &quot;.use()&quot; global dans la partie initialisation comme on le faisait jusqu'a présent. Il va falloir, avant le dessin de chaque entitée (terre ou lune), changer le programme utilisé en utilisant la méthode use() sur la variable membre <strong>m_Program</strong> de la structure adaptée. De même pour modifier les variables uniformes. Voici par exemple mon code pour dessiner la terre, dans la boucle de rendu:</p>
<pre><code class="hljs css language-cpp">earthProgram.m_Program.use();

glUniform1i(earthProgram.uEarthTexture, <span class="hljs-number">0</span>);
glUniform1i(earthProgram.uCloudTexture, <span class="hljs-number">1</span>);

glm::mat4 globalMVMatrix = glm::translate(glm::mat4(<span class="hljs-number">1.f</span>), glm::vec3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-5</span>));

glm::mat4 earthMVMatrix = glm::rotate(globalMVMatrix, windowManager.getTime(), glm::vec3(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));
glUniformMatrix4fv(earthProgram.uMVMatrix, <span class="hljs-number">1</span>, GL_FALSE, 
    glm::value_ptr(earthMVMatrix));
glUniformMatrix4fv(earthProgram.uNormalMatrix, <span class="hljs-number">1</span>, GL_FALSE, 
    glm::value_ptr(glm::transpose(glm::inverse(earthMVMatrix))));
glUniformMatrix4fv(earthProgram.uMVPMatrix, <span class="hljs-number">1</span>, GL_FALSE, 
    glm::value_ptr(projMatrix * earthMVMatrix));

glActiveTexture(GL_TEXTURE0);
glBindTexture(GL_TEXTURE_2D, earthTexture);
glActiveTexture(GL_TEXTURE1);
glBindTexture(GL_TEXTURE_2D, cloudTexture);

glDrawArrays(GL_TRIANGLES, <span class="hljs-number">0</span>, sphere.getVertexCount());
</code></pre>
<p>On observe que j'utilise la variable earthProgram pour activer le bon programme et modifier les bonnes uniformes. Pour dessiner la lune il faut utiliser la variable moonProgram.</p>
<p><span class="badge todo"></span> Modifiez votre code pour utiliser vos deux programmes séquentiellement.</p>
<p>Concernant l'appel à la méthode <strong>use()</strong>: celle ci est assez couteuse, on ne peut pas se permettre de changer de programme GPU à chaque dessin. C'est pourquoi avant cet exercice on le faisait en dehors de la boucle de rendu. Puisque vous dessinez plusieurs lunes, vous pourriez être tenté de faire l'appel <strong>moonProgram.m_Program.use()</strong> à chaque tour de la boucle qui dessine les lunes. La bonne solution est de faire cet appel avant cette boucle. Ainsi on ne fera pas:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; nbMoon; ++i) {
    moonProgram.m_Program.use();

    <span class="hljs-comment">// Modification des uniformes ...</span>

    glDrawArrays(...);
}
</code></pre>
<p>Mais plutot:</p>
<pre><code class="hljs css language-cpp">moonProgram.m_Program.use();
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; nbMoon; ++i) {
    <span class="hljs-comment">// Modification des uniformes ...</span>

    glDrawArrays(...);
}
</code></pre>
<p>Dans un vrai moteur, on regroupe les appels de dessin de manière à minimiser le nombre de changement de shaders. Si on dessiner 42 terres et 69 lunes, on dessinerais d'abord toutes les terres avec le programme GPU pour dessiner la terre, puis ensuite toutes les lunes avec le programme GPU pour dessiner la lune. Cela permet de changer seulement deux fois de programme par tour de boucle de rendu.</p>
<p>Si au contraire on alternait dessin terre - dessin lune - dessin terre - dessin lune - etc. on devrait à chaque fois changer de programme, ce qui tuerait les performances (vous pouvez essayer si le coeur vous en dit !).</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/openglnoel/docs/silver-02-3d-pratique-06-multi-texturing"><span class="arrow-prev">← </span><span>Multi-texturing</span></a><a class="docs-next button" href="/openglnoel/docs/silver-03-camera-01-introduction"><span>Introduction</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/openglnoel/" class="nav-home"><img src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]" width="66" height="58"/></a><div><h5>About Me</h5><a href="http://laurentnoel.fr">Personal website</a><a href="https://github.com/Celeborn2BeAlive/">Github</a></div><div><h5>About This Website</h5><a href="/openglnoel/blog">Blog</a><a class="github-button" href="https://github.com/celeborn2bealive/openglnoel" data-icon="octicon-star" data-count-href="/celeborn2bealive/openglnoel/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">openglnoel</a><a href="https://docusaurus.io/">Powered by Docusaurus</a></div><div><h5>About OpenGL</h5><a href="docs.gl">Documentation (docs.gl)</a><a href="https://www.khronos.org/opengl/wiki/">Wiki</a></div></section><section class="copyright">Copyright © 2019 Laurent NOEL</section></footer></div></body></html>