<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Gamma Correction · OpenGL[&quot;noël&quot;]</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Un premiere filtre simple que nous allons appliquer à l&#x27;image est la **gamma correction**. Ce filtre corrige les couleurs d&#x27;une image pour tenir compte du rendu non linéaire des couleurs qu&#x27;un moniteur affiche. Pour plus de détails consultez [l&#x27;article wikipedia](http://en.wikipedia.org/wiki/Gamma_correction) ou [cet article](http://www.geeks3d.com/20101001/tutorial-gamma-correction-a-story-of-linearity/)."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Gamma Correction · OpenGL[&quot;noël&quot;]"/><meta property="og:type" content="website"/><meta property="og:url" content="https://celeborn2bealive.github.io/openglnoel/"/><meta property="og:description" content="Un premiere filtre simple que nous allons appliquer à l&#x27;image est la **gamma correction**. Ce filtre corrige les couleurs d&#x27;une image pour tenir compte du rendu non linéaire des couleurs qu&#x27;un moniteur affiche. Pour plus de détails consultez [l&#x27;article wikipedia](http://en.wikipedia.org/wiki/Gamma_correction) ou [cet article](http://www.geeks3d.com/20101001/tutorial-gamma-correction-a-story-of-linearity/)."/><meta property="og:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><link rel="shortcut icon" href="/openglnoel/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/atom.xml" title="OpenGL[&quot;noël&quot;] Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/feed.xml" title="OpenGL[&quot;noël&quot;] Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/openglnoel/js/code-block-buttons.js"></script><script type="text/javascript" src="/openglnoel/js/disqus.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/openglnoel/js/scrollSpy.js"></script><link rel="stylesheet" href="/openglnoel/css/main.css"/><script src="/openglnoel/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/openglnoel/"><img class="logo" src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]"/><h2 class="headerTitleWithLogo">OpenGL[&quot;noël&quot;]</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction" target="_self">Intro et SDK</a></li><li class=""><a href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base" target="_self">Bronze</a></li><li class=""><a href="/openglnoel/docs/silver-01-3d-theorie-01-introduction" target="_self">Silver</a></li><li class="siteNavGroupActive"><a href="/openglnoel/docs/gold-01-intro-sdk-01-introduction" target="_self">Gold</a></li><li class=""><a href="/openglnoel/blog/" target="_self">Blog</a></li><li class=""><a href="http://docs.gl" target="_self">OpenGL Documentation</a></li><li class=""><a href="https://www.khronos.org/opengl/wiki/" target="_self">OpenGL Wiki</a></li><li class=""><a href="https://github.com/celeborn2bealive/openglnoel" target="_self">GitHub</a></li><li class=""><a href="https://gltf-viewer-tutorial.gitlab.io" target="_self">My glTF Viewer Tutorial</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Post Processing</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction et SDK</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-01-intro-sdk-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-01-intro-sdk-03-fiche-info">Fiche d&#x27;information</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-01-intro-sdk-05-projet">Projet - Un viewer glTF</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Forward Renderer</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-01-pipeline">Pipeline de Rendu</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-02-geometrie">Geometrie</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-03-shaders">Shaders</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-04-transformations">Transformations</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-05-lighting">Lighting</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-06-textures">Textures</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-07-load-obj">Chargement de modèles OBJ</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-08-plus-loin">Aller plus loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Deferred Renderer</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-01-pipeline">Pipeline de Rendu</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-02-geometry-pass">Geometrie Pass</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-03-shading-pass">Shading Pass</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-04-plus-loin">Aller plus loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Shadow Mapping</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-02-dir-shadow-map">Directional Shadow Map</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-03-percentage-closest-filtering">Percentage Closest Filtering</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-04-aller-plus-loin">Aller Plus Loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Post Processing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-01-introduction">Introduction</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-02-gamma-correction">Gamma Correction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-03-extraction-contours">Extraction et Rendu de Contours</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-04-depth-of-field">Depth of Field</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Annexe: API OpenGL</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-01-opengl-context">Contexte OpenGL</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-02-gpu-pipeline">Pipeline de Rendu</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-03-opengl-extensions">Extensions OpenGL</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-04-opengl-objects">Objets OpenGL</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-05-buffer-objects">Buffer Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-06-vertex-array-objects">Vertex Array Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-07-textures">Texture Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-08-framebuffer-objects">Framebuffer Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-09-shaders">Shaders</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Gamma Correction</h1></header><article><div><span><p>Un premiere filtre simple que nous allons appliquer à l'image est la <strong>gamma correction</strong>. Ce filtre corrige les couleurs d'une image pour tenir compte du rendu non linéaire des couleurs qu'un moniteur affiche. Pour plus de détails consultez <a href="http://en.wikipedia.org/wiki/Gamma_correction">l'article wikipedia</a> ou <a href="http://www.geeks3d.com/20101001/tutorial-gamma-correction-a-story-of-linearity/">cet article</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="gamma-correction"></a><a href="#gamma-correction" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Gamma correction</h2>
<p>Le principe de la correction gamma est d'élever la valeur de tous les pixels (les 3 composantes R, G et B) à la puissance (1 / G) où G est la valeur de gamma. En general on prend G = 2.2, mais cette valeur doit être modifiable en temps réel dans votre application. Ce processus à pour effet de réhausser fortement les valeurs sombres par rapport aux valeurs claires.</p>
<p>Algorithmiquement cela donne:</p>
<ul>
<li>Pour chaque pixel (i, j)
<ul>
<li>outImage(i, j) = pow(inputImage(i, j), 1 / G)</li>
</ul></li>
</ul>
<p>Facile, non ? On va faire ça sur GPU.</p>
<h2><a class="anchor" aria-hidden="true" id="le-compute-shader"></a><a href="#le-compute-shader" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Le Compute Shader</h2>
<p>Ajoutez un fichier <strong>gammaCorrect.cs.glsl</strong> au repertoire des shaders de l'application a remplissez le avec le code suivant (à réécrire, pas de copier-coller):</p>
<pre><code class="hljs css language-glsl"><span class="hljs-meta">#version 430</span>

<span class="hljs-keyword">layout</span>(<span class="hljs-keyword">local_size_x</span> = <span class="hljs-number">1</span>, <span class="hljs-keyword">local_size_y</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span>;

<span class="hljs-type">void</span> main() {
    <span class="hljs-comment">// todo</span>
}
</code></pre>
<p>Ce code à la structure de base d'un compute shader. Un compute shader est destiné à être lancé en parallèle sur un grand nombre d'unités de calcul. Ces unités de calcul correspondent aux coeurs GPU et sont les même qu'en Cuda.</p>
<p>Les unités sont répartis en groupes. La ligne:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">local_size_x</span> = <span class="hljs-number">1</span>, <span class="hljs-keyword">local_size_y</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span>;
</code></pre>
<p>définit la taille des groupes de calcul, ici 1x1. Il est possible de partager des données entre différentes unités d'un même groupe afin de construire des algorithmes parallèles élaborés. Ici nous faisons simple en spécifiant des groupes de taille 1x1 car nous n'avons pas de donnés à partager pour la gamma correction (les executions sont completement indépendantes).</p>
<p>Les compute shaders possèdent plusieurs variables d'entrée prédéfinies:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-keyword">in</span> <span class="hljs-type">uvec3</span> <span class="hljs-built_in">gl_NumWorkGroups</span>; <span class="hljs-comment">// Nombre de groupes lancés sur les 3 dimensions</span>
<span class="hljs-keyword">in</span> <span class="hljs-type">uvec3</span> <span class="hljs-built_in">gl_WorkGroupID</span>; <span class="hljs-comment">// ID du groupe actuel</span>
<span class="hljs-keyword">in</span> <span class="hljs-type">uvec3</span> <span class="hljs-built_in">gl_LocalInvocationID</span>; <span class="hljs-comment">// ID de l'unité de calcul actuelle au sein de son groupe</span>
<span class="hljs-keyword">in</span> <span class="hljs-type">uvec3</span> <span class="hljs-built_in">gl_GlobalInvocationID</span>; <span class="hljs-comment">// ID de l'unité de calcul actuelle au sein de toutes les unités</span>
<span class="hljs-keyword">in</span> <span class="hljs-type">uint</span>  <span class="hljs-built_in">gl_LocalInvocationIndex</span>; <span class="hljs-comment">// ID ramené entre 0 et le nombre d'unité de calcul par groupe</span>
</code></pre>
<p>Pour plus de détails sur les compute shaders, il est important de <a href="https://www.khronos.org/opengl/wiki/Compute_Shader">lire cette page du wiki OpenGL</a>.</p>
<p>La variable qui va nous servir pour faire la gamma correction est <strong>gl_GlobalInvocationID</strong>. L'idée est d'avoir une unité de calcul lancée pour chaque pixel de l'image à traiter. C'est cette variable qui nous permet d'identifier l'unité de calcul actuelle, et donc le pixel à traiter.</p>
<p>Ajoutez la ligne:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-type">ivec2</span> pixelCoords = <span class="hljs-type">ivec2</span>(<span class="hljs-built_in">gl_GlobalInvocationID</span>.xy);
</code></pre>
<p>au main du shader. Ici on récupère les coordonnées du pixel à traiter à partir de l'ID de l'unité de calcul courante.</p>
<p>Il va maintenant falloir traiter le pixel. Pour ça il faut lire sa valeur, qui doit venir d'une image. Pour passer des informations à un compute shader, il faut passer par des variables uniformes. Une solution est donc de prendre en uniform un sampler2D qui nous permettra de lire la texture beauty et de lui appliquer le gamma.</p>
<p>En réalité plutot que d'utiliser un sampler2D, nous allons utiliser un nouveau type de variable GLSL permettant de lire/écrire des images: un image2D.</p>
<p>Dans le shader avant le main ajoutez la ligne:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">rgba32f</span>, <span class="hljs-keyword">binding</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-keyword">readonly</span> <span class="hljs-type">image2D</span> uInputImage;
</code></pre>
<p>Cette déclaration peut paraitre compliquée, on va donc la décomposer:</p>
<ul>
<li>rgba32f indique le type de l'image que nous allons fournir en entrée. GLSL impose de spécifier ce type lorsque l'image n'est pas en writeonly.</li>
<li>binding = 0 indique que l'image coté CPU devra être bindée sur l'image unit 0 (à ne pas confondre avec les textures unit, mais le système est similaire) avant d'executer le shader.</li>
<li>readonly indique que nous allons seulement lire l'image</li>
<li>et image2D est simplement le type</li>
</ul>
<p>Cette variable uniform va nous permettre de lire l'image d'entrée, mais il faut également une image de sortie. Ajoutez à la suite:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">binding</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">uniform</span> <span class="hljs-keyword">writeonly</span> <span class="hljs-type">image2D</span> uOutputImage;
</code></pre>
<p>Ici le binding est 1, on devra donc binder l'image de sortie sur l'image unit 1 avant d'executer le shader. On specifie que l'image est en writeonly, on a donc pas besoin de specifier le type de l'image.</p>
<p>A nouveau, <a href="https://www.khronos.org/opengl/wiki/Image_Load_Store">une page du wiki à lire</a> concernant les images coté GLSL et CPU.</p>
<p>Enfin coté uniformes, ajoutez une variable <strong>float uGammaExponent</strong> qui nous servira à indiquer au shader la valeur de gamma à appliquer.</p>
<p>Il faut maintenant completer le main. Pour cela on doit:</p>
<ul>
<li>lire la valeur du pixel dans l'image d'entrée</li>
<li>elever cette valeur à la puissance uGammaExponent</li>
<li>écrire la nouvelle valeur dans l'image de sortie.</li>
</ul>
<p>3 lignes de code donc. Pour cela utilisez les fonctions GLSL suivantes:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-type">vec4</span> <span class="hljs-built_in">imageLoad</span>(<span class="hljs-type">image2D</span> image​, <span class="hljs-type">ivec2</span> pixelCoords); <span class="hljs-comment">// Lit un pixel</span>
<span class="hljs-type">void</span> <span class="hljs-built_in">imageStore</span>(<span class="hljs-type">image2D</span> image, <span class="hljs-type">ivec2</span> pixelCoords, <span class="hljs-type">vec4</span> data); <span class="hljs-comment">// Ecrit un pixel</span>
<span class="hljs-type">vec4</span> <span class="hljs-built_in">pow</span>(<span class="hljs-type">vec4</span> valeur, <span class="hljs-type">vec4</span> exponent); <span class="hljs-comment">// Fonction puissance</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="chargement-du-compute-shader"></a><a href="#chargement-du-compute-shader" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Chargement du Compute Shader</h2>
<p>Coté C++ il faut charger le shader et récuperer les uniformes.</p>
<p>Commencez par ajouter la variable membre <strong>glmlv::GLProgram m_gammaCorrectionProgram</strong> à la classe application. A l'initialisation utilisez la fonction <strong>glmlv::loadProgram</strong> pour charger le shader <strong>gammaCorrect.cs.glsl</strong> (un seul chemin à mettre dans les accolades donc).</p>
<p>Au niveau des uniformes il n'y a en fait qu'une seule location à récupérer: celle de <strong>uGammaExponent</strong>, à stocker dans une variable membre.</p>
<p>Les deux autres (uInputImage et uOutputImage) n'ont pas à être récupérer car nous avons spécifié leur binding directement dans le shader. Si ca n'avait pas été le cas, il aurait fallut récupérer leur location et utiliser glUniform1i pour spécifier les images unit depuis le code C++ (comme pour les samplers).</p>
<p>A ce stade essayez de lancer l'executable afin de verifier que le shader compile bien.</p>
<h2><a class="anchor" aria-hidden="true" id="la-texture-de-rendu"></a><a href="#la-texture-de-rendu" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>La texture de rendu</h2>
<p>Nous allons avoir besoin d'une nouvelle texture et d'un FBO associé pour stocker l'image après gamma correction. Comme vous l'avez fait en introduction pour la beauty, rajoutez des variables membre <strong>GLuint m_GammaCorrectedBeautyTexture</strong> et <strong>GLuint m_GammaCorrectedBeautyFBO</strong> à la classe Application. Faites ce qu'il faut à l'initialisation pour que cette nouvelle texture et ce FBO soient fonctionnel.</p>
<h2><a class="anchor" aria-hidden="true" id="lappel-au-compute-shader"></a><a href="#lappel-au-compute-shader" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>L'appel au Compute Shader</h2>
<p>Nous avons tout en place pour appeler le compute shader dans le code de rendu, après la shading pass:</p>
<ol>
<li>Utilisez le nouveau programme avec la methode use()</li>
<li>Envoyez l'uniforme uGammaExponent avec la fonction glUniform1f. Pour cela definissez une variablle gamma en haut de la fonction (initialisée à 2.2), et envoyez au shader la valeur (1 / gamma). Faites en sorte que gamma soit modifiable depuis la GUI en utilisant la fonction <strong>ImGui::InputFloat</strong></li>
<li>Bindez les deux images sur les image units 0 et 1 en utilisant la fonction OpenGL <strong>glBindImageTexture</strong> (voir ci dessous pour le prototype).</li>
<li>Enfin appelez la fonction <strong>glDispatchCompute</strong> pour lancer le compute shader.</li>
</ol>
<p>La fonction <strong>glBindImageTexture</strong> a le prototype suivant:</p>
<pre><code class="hljs css language-glsl"><span class="hljs-type">void</span> glBindImageTexture(
    GLuint unit,
    GLuint <span class="hljs-built_in">texture</span>,
    GLint level,
    GLboolean layered,
    GLint layer,
    GLenum access,
    GLenum format);
</code></pre>
<p>Il faut appeler cette fonction 2 fois avec unit = 0 et 1 alternativement, et texture = m_BeautyTexture et m_GammaCorrectedTexture alternativement.
Le paramètre access doit être mis à GL_READ_ONLY pour le premier appel et GL_WRITE_ONLY pour le second.</p>
<p>Les autres paramètres doivent prendre les valeurs level = 0, layered = GL_FALSE, layer = 0 et format = GL_RGBA32F pour les deux appels.</p>
<h2><a class="anchor" aria-hidden="true" id="le-blit-à-lécran"></a><a href="#le-blit-à-lécran" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Le blit à l'écran</h2>
<p>Il ne reste plus qu'a afficher l'image gamma corrected à l'écran. Pour cela remplacez le binding de m_BeautyFBO par celui de m_GammaCorrectedBeautyFBO avant le blit à l'écran.</p>
<p>Lancez l'executable et vérifiez que la modification du gamma depuis la GUI affecte bien l'apparence de l'image (un gamma plus elevé doit rendre l'image plus claire).</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/openglnoel/docs/gold-05-post-processing-01-introduction"><span class="arrow-prev">← </span><span>Introduction</span></a><a class="docs-next button" href="/openglnoel/docs/gold-05-post-processing-03-extraction-contours"><span>Extraction et Rendu de Contours</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#gamma-correction">Gamma correction</a></li><li><a href="#le-compute-shader">Le Compute Shader</a></li><li><a href="#chargement-du-compute-shader">Chargement du Compute Shader</a></li><li><a href="#la-texture-de-rendu">La texture de rendu</a></li><li><a href="#lappel-au-compute-shader">L'appel au Compute Shader</a></li><li><a href="#le-blit-à-lécran">Le blit à l'écran</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/openglnoel/" class="nav-home"><img src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]" width="66" height="58"/></a><div><h5>About Me</h5><a href="http://laurentnoel.fr">Personal website</a><a href="https://github.com/Celeborn2BeAlive/">Github</a></div><div><h5>About This Website</h5><a href="/openglnoel/blog">Blog</a><a class="github-button" href="https://github.com/celeborn2bealive/openglnoel" data-icon="octicon-star" data-count-href="/celeborn2bealive/openglnoel/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">openglnoel</a><a href="https://docusaurus.io/">Powered by Docusaurus</a></div><div><h5>About OpenGL</h5><a href="docs.gl">Documentation (docs.gl)</a><a href="https://www.khronos.org/opengl/wiki/">Wiki</a></div></section><section class="copyright">Copyright © 2021 Laurent NOEL</section></footer></div></body></html>