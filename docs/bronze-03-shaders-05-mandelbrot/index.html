<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Mandelbrot · OpenGL[&quot;noël&quot;]</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Nous allons à nouveau faire le rendu d&#x27;une texture procédurale, sur toute la fenêtre cette fois. L&#x27;objectif est de coder le rendu de [la fractale de Mandelbrot](https://www.wikiwand.com/fr/Ensemble_de_Mandelbrot). Pour cet exercice, reprenez le fichier template de base (TPtemplate.cpp), copiez le et renommez le."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Mandelbrot · OpenGL[&quot;noël&quot;]"/><meta property="og:type" content="website"/><meta property="og:url" content="https://celeborn2bealive.github.io/openglnoel/"/><meta property="og:description" content="Nous allons à nouveau faire le rendu d&#x27;une texture procédurale, sur toute la fenêtre cette fois. L&#x27;objectif est de coder le rendu de [la fractale de Mandelbrot](https://www.wikiwand.com/fr/Ensemble_de_Mandelbrot). Pour cet exercice, reprenez le fichier template de base (TPtemplate.cpp), copiez le et renommez le."/><meta property="og:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><link rel="shortcut icon" href="/openglnoel/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/atom.xml" title="OpenGL[&quot;noël&quot;] Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/feed.xml" title="OpenGL[&quot;noël&quot;] Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/openglnoel/js/code-block-buttons.js"></script><script type="text/javascript" src="/openglnoel/js/disqus.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/openglnoel/js/scrollSpy.js"></script><link rel="stylesheet" href="/openglnoel/css/main.css"/><script src="/openglnoel/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/openglnoel/"><img class="logo" src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]"/><h2 class="headerTitleWithLogo">OpenGL[&quot;noël&quot;]</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/openglnoel/docs/gltf-viewer-01-intro-01-intro" target="_self">glTF Viewer Tutorial</a></li><li class=""><a href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction" target="_self">Intro et SDK</a></li><li class="siteNavGroupActive"><a href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base" target="_self">Bronze</a></li><li class=""><a href="/openglnoel/docs/silver-01-3d-theorie-01-introduction" target="_self">Silver</a></li><li class=""><a href="/openglnoel/docs/gold-01-intro-sdk-01-introduction" target="_self">Gold</a></li><li class=""><a href="/openglnoel/blog/" target="_self">Blog</a></li><li class=""><a href="http://docs.gl" target="_self">OpenGL Documentation</a></li><li class=""><a href="https://www.khronos.org/opengl/wiki/" target="_self">OpenGL Wiki</a></li><li class=""><a href="https://github.com/celeborn2bealive/openglnoel" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Les shaders</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Hello Triangle</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base">Le code de base</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-02-hello-triangle-02-triangle-blanc">Dessiner un triangle blanc</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-02-hello-triangle-03-triangle-couleurs">Dessiner un triangle en couleurs</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-02-hello-triangle-04-vertex-structure">Utiliser une structure de vertex</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-02-hello-triangle-05-dessiner-quad">Dessiner un quad</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-02-hello-triangle-06-dessiner-disque">Dessiner un disque</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-02-hello-triangle-07-index-buffers">Utiliser les buffers d&#x27;index</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Les shaders</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-01-kesako">Shaders, kesako ?</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-02-exemple">Les shaders par l&#x27;exemple</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-03-compilation">Charger, compiler et utiliser</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-04-jouer">Jouer avec les shaders</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-05-mandelbrot">Mandelbrot</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-06-la-suite">Préparer la suite</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-07-triangle-tourne">Un triangle qui tourne</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-08-matrices">Envoyer des matrices</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-09-plusieurs-triangles">Plusieur triangles</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-10-textures">Textures</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Mandelbrot</h1></header><article><div><span><p>Nous allons à nouveau faire le rendu d'une texture procédurale, sur toute la fenêtre cette fois. L'objectif est de coder le rendu de <a href="https://www.wikiwand.com/fr/Ensemble_de_Mandelbrot">la fractale de Mandelbrot</a>. Pour cet exercice, reprenez le fichier template de base (TPtemplate.cpp), copiez le et renommez le.</p>
<p><img src="/openglnoel/img/mandelbrot.png" alt="Mandelbrot"></p>
<h2><a class="anchor" aria-hidden="true" id="dessiner-toute-la-fenêtre"></a><a href="#dessiner-toute-la-fenêtre" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dessiner toute la fenêtre</h2>
<p><span class="badge todo"></span> Première chose à faire: dessiner un quad qui occupe tout l'ecran (de -1 à 1 sur chacun des axes). Nous avons déjà dessiné un quad dans un exercice précédent donc vous ne devriez pas avoir de problème. N'envoyez que des positions dans le VBO (pas de couleur). Testez votre programme avant de passer à la suite (la fenêtre doit être toute blanche).</p>
<h2><a class="anchor" aria-hidden="true" id="mettre-en-place-les-shaders"></a><a href="#mettre-en-place-les-shaders" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mettre en place les shaders</h2>
<p><span class="badge todo"></span> Créez deux shaders <strong>mandelbrot.vs.glsl</strong> et <strong>mandelbrot.fs.glsl</strong>. Codez les pour le moment de manière à afficher du rouge à la place du blanc. Depuis l'application chargez les. Testez votre application pour vérifier que la fenêtre est bien rouge.</p>
<p><span class="badge todo"></span> Comme pour certains des exercices précédents, nous allons avoir besoin de la position du fragment en entrée dans le fragment shader. Faites en sorte qu'elle soit passée du vertex au fragment shader. Pour vérifier que c'est correct affichez cette position comme si c'était une couleur (le x,y devient le r,g de la couleur de sortie).</p>
<h2><a class="anchor" aria-hidden="true" id="la-fractale-de-mandelbrot"></a><a href="#la-fractale-de-mandelbrot" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>La fractale de Mandelbrot</h2>
<p>La fractale de Mandelbrot est un ensemble noté \(M\) de nombres complexes respectant une certaine propriété. L'idée pour dessiner cet ensemble est d'identifier chaque fragment à un nombre complexe. En effet, les nombres complexes peuvent être placés sur un plan, et donc dessinés en 2D. Nous dessinerons en noir les fragments donc le nombre complexe associé appartient à l'ensemble de mandelbrot et en blanc les autres.</p>
<p>Commençons par la définition formelle de l'ensemble \(M\). Pour chaque nombre complexe \(c=a+ib\), on définit une suite récurrente d'autres nombre complexe:</p>
<ul>
<li>\(z_0(c)=c\)</li>
<li>\(z_{k+1}(c)=z_k(c)^2+c\)</li>
</ul>
<p>Prenons par exemple le nombre c=2+i et calculons les premiers termes de la suite (rappel: \(i^2=−1\)):</p>
<p>$$
z_0(c)=2+i
$$</p>
<p>$$z_1(c)=z_0(c)^2+c=(2+i)^2+(2+i)=(2^2+2×2×i+i^2)+(2+i)\\=4+4i−1+2+i=5+5i$$</p>
<p>$$z_2(c)=z_1(c)^2+c=(5+5i)^2+(2+i)=(5^2+2×5×i+5^2i^2)+(2+i)\\=25+10i−25+2+i=2+11i$$</p>
<p>Pour chaque nombre complexe c, on s'interesse au comportement de la suite \((z_n(c))_{n \geq 0}\). Si tous les elements de la suite sont situés dans le disque de rayon 2 centré sur l'origine \((0,0)\), alors \(c\) appartient à \(M\). Si des elements de la suite sont situés à l'exterieur de ce disque, alors \(c\) n'appartient pas à \(M\). Cela revient à vérifier si la condition \(\forall n \in \mathbb{N}, |z_n(c)| \leq 2\) est respectée (rappel: \(|z_n(c)|\) est le module du nombre complexe \(z_n(c)\) et représente la distance entre l'origine et le point associé au nombre complexe).</p>
<p>Comment convertir tout ça en code ? c'est simple: dans le fragment shader on récupère la position \((x,y)\) du fragment (obtenue en entrée grace au vertex shader). A partir de cette position on calcule les termes de la suite \(z_n(x+iy)\) pour \(n\) variant de \(0\) à un entier maximal \(N_{max}\) fixé (dans une boucle). Si le module d'un des termes est supérieur à 2, on quitte la boucle et on sort la couleur blanche. Si ce n'est pas le cas, on sort la couleur noire.</p>
<p>Concretement, on n'affiche qu'une approximation de la fractale. Plus \(N_{max}\) est elevé, meilleure est l'approximation (et plus long est le calcul).</p>
<p><span class="badge todo"></span> Le calcul des termes de la suite requiert une multiplication complexe (le terme précédent élevé au carré). La multiplication des <strong>vec2</strong> en GLSL ne correspond pas à la multiplication complexe (car il n'y a pas de prise en compte de i). Dans le fragment shader, ecrivez une fonction <strong>vec2 complexSqr(vec2 z)</strong>$** qui calcule le carré du nombre complexe <strong>z.x+i*z.y</strong> représenté par <strong>z</strong>. Comprenez bien que i n'apparait pas dans la fonction, ce n'est qu'une entitée mathématique. Le calcul doit d'abord être posé sur papier, en appliquant la propriété \(i^2=−1\). A partir de ça on renvoit dans la fonction un <strong>vec2</strong> ayant en x la partie réelle et en y la partie imaginaire du résultat.</p>
<p><span class="badge todo"></span> Implantez dans le main du fragment shader l'algorithme décrit plus haut pour calculer la couleur du fragment en fonction de son appartenance à l'ensemble de mandelbrot. N'oubliez pas d'utiliser votre fonction <strong>complexSqr</strong> pour calculer chacun des termes de la suite ! Pour calculer le module des termes, vous pouvez utiliser la fonction GLSL length qui calcule la longueur d'un vecteur (c'est équivalent au module).</p>
<p><span class="badge todo"></span> Une fois que vous avez la fractale en noir et blanc, il est possible d'ameliorer facilement le rendu en affichant une couleur qui dépend du nombre de tour de boucle qui se sont écoulés avant que la condition soit rompue. Imaginons que le test échoue au tour de boucle <strong>j</strong>, vous pouvez afficher comme couleur la valeur: <strong>vec3(float(j) / Nmax)</strong>; Avec un peu d'imagination vous pouvez même faire plus joli :)</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/openglnoel/docs/bronze-03-shaders-04-jouer"><span class="arrow-prev">← </span><span>Jouer avec les shaders</span></a><a class="docs-next button" href="/openglnoel/docs/bronze-03-shaders-06-la-suite"><span>Préparer la suite</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#dessiner-toute-la-fenêtre">Dessiner toute la fenêtre</a></li><li><a href="#mettre-en-place-les-shaders">Mettre en place les shaders</a></li><li><a href="#la-fractale-de-mandelbrot">La fractale de Mandelbrot</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/openglnoel/" class="nav-home"><img src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]" width="66" height="58"/></a><div><h5>About Me</h5><a href="http://laurentnoel.fr">Personal website</a><a href="https://github.com/Celeborn2BeAlive/">Github</a></div><div><h5>About This Website</h5><a href="/openglnoel/blog">Blog</a><a class="github-button" href="https://github.com/celeborn2bealive/openglnoel" data-icon="octicon-star" data-count-href="/celeborn2bealive/openglnoel/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">openglnoel</a><a href="https://docusaurus.io/">Powered by Docusaurus</a></div><div><h5>About OpenGL</h5><a href="docs.gl">Documentation (docs.gl)</a><a href="https://www.khronos.org/opengl/wiki/">Wiki</a></div></section><section class="copyright">Copyright © 2020 Laurent NOEL</section></footer></div></body></html>