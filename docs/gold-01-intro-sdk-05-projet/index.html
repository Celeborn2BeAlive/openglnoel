<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Projet - Un viewer glTF · OpenGL[&quot;noël&quot;]</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;L&#x27;objectif de ce projet est de réaliser en C++ un viewer de modèles au format glTF, similaire à celui de &lt;a href=&quot;https://sketchfab.com/&quot;&gt;Sketchfab&lt;/a&gt;.&lt;/p&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Projet - Un viewer glTF · OpenGL[&quot;noël&quot;]"/><meta property="og:type" content="website"/><meta property="og:url" content="https://celeborn2bealive.github.io/openglnoel/"/><meta property="og:description" content="&lt;p&gt;L&#x27;objectif de ce projet est de réaliser en C++ un viewer de modèles au format glTF, similaire à celui de &lt;a href=&quot;https://sketchfab.com/&quot;&gt;Sketchfab&lt;/a&gt;.&lt;/p&gt;
"/><meta property="og:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><link rel="shortcut icon" href="/openglnoel/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/atom.xml" title="OpenGL[&quot;noël&quot;] Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/feed.xml" title="OpenGL[&quot;noël&quot;] Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/openglnoel/js/code-block-buttons.js"></script><script type="text/javascript" src="/openglnoel/js/disqus.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><link rel="stylesheet" href="/openglnoel/css/main.css"/><script src="/openglnoel/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/openglnoel/"><img class="logo" src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]"/><h2 class="headerTitleWithLogo">OpenGL[&quot;noël&quot;]</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction" target="_self">Introduction et SDK</a></li><li class=""><a href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base" target="_self">Bronze</a></li><li class=""><a href="/openglnoel/docs/silver-01-3d-theorie-01-introduction" target="_self">Silver</a></li><li class="siteNavGroupActive"><a href="/openglnoel/docs/gold-01-intro-sdk-01-introduction" target="_self">Gold</a></li><li class=""><a href="/openglnoel/blog/" target="_self">Blog</a></li><li class=""><a href="http://docs.gl" target="_self">OpenGL Documentation</a></li><li class=""><a href="https://www.khronos.org/opengl/wiki/" target="_self">OpenGL Wiki</a></li><li class=""><a href="https://github.com/celeborn2bealive/openglnoel" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Introduction et SDK</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction et SDK</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-01-intro-sdk-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-01-intro-sdk-03-fiche-info">Fiche d&#x27;information</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/openglnoel/docs/gold-01-intro-sdk-05-projet">Projet - Un viewer glTF</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Forward Renderer</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-01-pipeline">Pipeline de Rendu</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-02-geometrie">Geometrie</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-03-shaders">Shaders</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-04-transformations">Transformations</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-05-lighting">Lighting</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-06-textures">Textures</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-07-load-obj">Chargement de modèles OBJ</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-02-forward-renderer-08-plus-loin">Aller plus loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Deferred Renderer</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-01-pipeline">Pipeline de Rendu</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-02-geometry-pass">Geometrie Pass</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-03-shading-pass">Shading Pass</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-03-deferred-renderer-04-plus-loin">Aller plus loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Shadow Mapping</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-02-dir-shadow-map">Directional Shadow Map</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-03-percentage-closest-filtering">Percentage Closest Filtering</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-04-shadow-mapping-04-aller-plus-loin">Aller Plus Loin</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Post Processing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-01-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-02-gamma-correction">Gamma Correction</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-03-extraction-contours">Extraction et Rendu de Contours</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-05-post-processing-04-depth-of-field">Depth of Field</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Annexe: API OpenGL</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-01-opengl-context">Contexte OpenGL</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-02-gpu-pipeline">Pipeline de Rendu</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-03-opengl-extensions">Extensions OpenGL</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-04-opengl-objects">Objets OpenGL</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-05-buffer-objects">Buffer Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-06-vertex-array-objects">Vertex Array Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-07-textures">Texture Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-08-framebuffer-objects">Framebuffer Objects</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/gold-06-course-09-shaders">Shaders</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Projet - Un viewer glTF</h1></header><article><div><span><p>L'objectif de ce projet est de réaliser en C++ un viewer de modèles au format glTF, similaire à celui de <a href="https://sketchfab.com/">Sketchfab</a>.</p>
<p>Voici des liens vers des modèles glTF qui me serviront à tester votre application:</p>
<ul>
<li><a href="https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0">Les samples officiels glTF du KhronosGroup</a></li>
<li><a href="https://skfb.ly/6IPnQ">Une collection de modèles Sketchfab telechargeables</a></li>
</ul>
<p>Je me suis un peu enflammé dans la collection, il y a beaucoup de modèles, pas la peine de tout essayer (et vous n'arriverez sans doute pas a reproduire le look exact).</p>
<h2><a class="anchor" aria-hidden="true" id="contraintes"></a><a href="#contraintes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Contraintes</h2>
<ul>
<li>En C++</li>
<li>OpenGL 4+</li>
<li>Dans une application de votre fork du repository des TDs</li>
<li>En monome ou binome (pas en trinome, pas en quatrome, pas en quicome, et pas à zero).</li>
<li>Date de rendu: <strong>31 Mars 2019 minuit au plus tard</strong></li>
<li>Modalité de rendu: Vous m'enverrez un mail indiquant le numéro du commit correspondant à votre rendu de projet sur votre repository. Ce commit devra avoir été pushé avant l'heure  limite de rendu.</li>
<li>Vous joindrez au mail un rapport court (moins de deux pages) en pdf m'indiquant la liste des fonctionnalités implémentées, les difficultés rencontrées, et les eventuels problemes non résolu. <strong>Dans le rapport indiquez moi aussi les modèles glTF que vous avez testé</strong>.</li>
</ul>
<p>Conseil pour travailler en binome sur Git: vous pouvez vous faire des pull request entre differents fork.</p>
<h2><a class="anchor" aria-hidden="true" id="fonctionalites-de-base"></a><a href="#fonctionalites-de-base" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fonctionalités de base</h2>
<p>Voici la liste minimale des fonctionalités à implementer:</p>
<ul>
<li>Chargement d'un modèle glTF dont le chemin est passé sur la ligne de commande (c'est à dire à lire dans argv[1]).</li>
<li>Gestion au minimum d'une scene statique</li>
<li>Caméra trackball initialisée en face de l'objet (up = +Y, regarde vers -Z de la scène, et située à une distance du centre de l'objet tel que l'objet soit entierement visible)</li>
<li>Controle de la caméra similaire à Sketchfab: scroll = zoom/dezoom, left press + drag = rotation autour du centre de la caméra, right press + drag ou middle press + drag = deplacement du centre de la caméra dans son plan X-Y (permet de changer le centre de rotation).</li>
<li>Une lumière directionnelle modifiable via ImGUI</li>
<li>Une shadow map avec percentage closest filtering sur la lumière directionnelle</li>
<li>Gamma correction controlable depuis la GUI (par defaut un gamma à 2.2).</li>
<li>Deferred rendering, avec possibilité d'afficher les couches du GBuffer depuis la GUI à la place du rendu final</li>
<li>Materiaux diffus + emission, avec pour couleur diffuse la <strong>baseColor</strong> du materiau (voir plus bas dans la partie glTF) et pour ambiant son <strong>emissionColor</strong>.</li>
</ul>
<p>Si tous ces points sont implémentés correctement, alors <strong>vous aurez une note de 12/20</strong>. Pour augmenter cette note, il faudra implementer des techniques non vues en TD. Voir une liste de proposition plus bas.</p>
<h2><a class="anchor" aria-hidden="true" id="le-format-gltf"></a><a href="#le-format-gltf" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Le format glTF</h2>
<p>Ce format développé par Khronos group permet d'échanger facilement des scènes statiques ou animées, avec un modèle de matériaux dit PBR (physically based rendering). La première chose à faire est d'aller lire la spécification sur <a href="https://github.com/KhronosGroup/glTF">le repository github de glTF</a>. Il y a également une overview permettant de rapidement comprendre les concepts du format.</p>
<p>Les modèles disponibles sur Sketchfab sont automatiquement converti en glTF, ce qui vous permettra d'essayer votre viewer sur un grand nombre d'exemple. <a href="https://sketchfab.com/models?features=downloadable&amp;sort_by=-likeCount">Ce lien propose les modèles gratuits</a> triés par popularité, et <a href="https://sketchfab.com/features/gltf">ce lien</a> propose des modèles payants et gratuit selectionnés par Sketchfab pour leur qualité.</p>
<p>Pour charger un fichier glTF, vous pouvez utiliser la biliothèque <a href="https://github.com/syoyo/tinygltf">tinygltf</a>, déjà présente dans le template. C'est une bibliotheque header only. Dans un unique cpp il faut mettre les lignes:</p>
<pre><code class="hljs css language-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TINYGLTF_IMPLEMENTATION</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;tiny_gltf.h&gt;</span></span>
</code></pre>
<p>Ce qui defini l'implementation de la lib. Dans les autres cpp ou hpp qui utilise la lib, il suffit juste d'inclure le header de tinygltf, sans le define.</p>
<p>Le modèle de materiaux utilisé par glTF est dit PBR, car il se base sur un modèle mathématique physiquement plausible. En gros on a un lobe d'emission, un lobe diffus et un lobe speculaire, ce dernier étant controllé par un paramètre metallic et un paramètre de rugosité (roughness). Les equations sont détaillées <a href="https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-b-brdf-implementation">sur ce lien</a>. En plus de ça on a un paramètre d'opacité pour rendre plus ou moins opaque l'objet, et une normal map.</p>
<p><strong>A minima je vous demande de gérer le lobe diffus</strong>, comme vu en TD, avec comme couleur le paramètre baseColor du materiaux (une texture la plupart du temps). En plus de ça l'emission est a ajouter (c'est de l'ambiant en gros). Vous aurez donc quelque chose de la forme:</p>
<p>$$
outColor = emissionColor + baseColor * \cos(\theta_i) * L
$$</p>
<p>ou \(\theta\) est l'angle entre la normale et la direction vers la lumière, et \(L\) l'intensité lumineuse.</p>
<p>L'implémentation du modele complet de materiaux permettra l'obtention de points supplémentaires (voir plus bas).</p>
<p>Le format glTF permet de representer des modèles animés. De la même manière, l'implementation de la gestion des animations des modeles permettra d'obtenir des points supplémentaires.</p>
<h2><a class="anchor" aria-hidden="true" id="exemples-de-techniques-avancees-pour-gratter-des-points"></a><a href="#exemples-de-techniques-avancees-pour-gratter-des-points" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Exemples de techniques avancées pour gratter des points</h2>
<p>Comme je l'ai dit plus haut, l'implementation des fonctionnalités de base est noté sur 12. Les 8 points restant peuvent être obtenu via l'implementation de techniques de rendu avancées que l'on a pas vu en TD. Heuresement pour vous le net regorge de tutoriaux (le site <a href="https://learnopengl.com/">https://learnopengl.com/</a> est une mine d'or). Voici une liste d'idées et les points associés.</p>
<p><span class="badge warning"></span> Ne pas commencer l'implementation des techniques avancées tant que les fonctionnalités de base ne sont pas traitées.</p>
<h3><a class="anchor" aria-hidden="true" id="gestion-des-animations-2-pts"></a><a href="#gestion-des-animations-2-pts" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Gestion des animations (2 pts)</h3>
<ul>
<li>Chargement et rendu sur GPU des animations du GLTF</li>
<li>Possibilité de controler depuis la GUI la timeline d'animation et les differentes animations à jouer</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="modele-de-shading-pbr-2-pts"></a><a href="#modele-de-shading-pbr-2-pts" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Modèle de shading PBR (2 pts)</h3>
<ul>
<li>Implementation du modèle complet metallicRoughness (avec éclairage depuis la directional light)</li>
</ul>
<p>References / Aide:</p>
<ul>
<li><a href="https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-b-brdf-implementation">https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-b-brdf-implementation</a></li>
<li><a href="https://learnopengl.com/PBR/Theory">https://learnopengl.com/PBR/Theory</a></li>
<li><a href="https://learnopengl.com/PBR/Lighting">https://learnopengl.com/PBR/Lighting</a></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="lighting-avance-depuis-une-environment-light-3-pts-a-faire-apres-le-modele-de-shading-pbr"></a><a href="#lighting-avance-depuis-une-environment-light-3-pts-a-faire-apres-le-modele-de-shading-pbr" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lighting avancé depuis une environment light (3 pts, a faire après le modèle de shading PBR)</h3>
<ul>
<li>Chargement d'une texture d'environment</li>
<li>Calcul du terme diffus depuis cette env light avec une technique par harmoniques spheriques</li>
<li>Calcul du terme speculaire avec prefiltrage et échantillonage</li>
</ul>
<p>References / Aide:</p>
<ul>
<li><a href="https://learnopengl.com/PBR/IBL/Diffuse-irradiance">https://learnopengl.com/PBR/IBL/Diffuse-irradiance</a></li>
<li><a href="https://learnopengl.com/PBR/IBL/Specular-IBL">https://learnopengl.com/PBR/IBL/Specular-IBL</a></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="chargement-et-rendu-de-lumieres-ponctuelle-en-respectant-l-extension-gltf-khr-lights-punctual-1-pt"></a><a href="#chargement-et-rendu-de-lumieres-ponctuelle-en-respectant-l-extension-gltf-khr-lights-punctual-1-pt" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Chargement et rendu de lumières ponctuelle en respectant l'extension glTF KHR_lights_punctual (1 pt)</h3>
<p>Par défaut le format glTF ne permet pas de stocker des lumières. Mais l'extension KHR_lights_punctal definit une syntaxe pour traiter des points lights, spot lights et directional lights. La bibliothèque tinygltf semble les charger dans sa structure de donnée (sinon il faudra coder le chargement).</p>
<ul>
<li>Charger les lumières du fichier d'entrée avec tinygltf ou avec votre code si necessaire</li>
<li>Faire le rendu de ces lumières en plus de la directional light de base (et de l'environment light si vous avez choisit de l'implementer)</li>
</ul>
<p>Il sera peut être difficile de trouver des scènes contenant des lumières. Dans ce cas ajoutez en a la main dans le fichier json de scènes existantes.</p>
<p>References / Aide:</p>
<ul>
<li><a href="https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual">https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual</a></li>
<li><a href="https://learnopengl.com/Lighting/Light-casters">https://learnopengl.com/Lighting/Light-casters</a></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="normal-mapping-1-pt"></a><a href="#normal-mapping-1-pt" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Normal mapping (1 pt)</h3>
<p>Technique assez simple à implementer et très documentée sur le net.</p>
<p>References / Aide:</p>
<ul>
<li><a href="https://learnopengl.com/Advanced-Lighting/Normal-Mapping">https://learnopengl.com/Advanced-Lighting/Normal-Mapping</a></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="screen-space-ambiant-occlusion-2-pt"></a><a href="#screen-space-ambiant-occlusion-2-pt" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Screen space ambiant occlusion (2 pt)</h3>
<p>Même chose que pour le normal mapping, assez simple à coder, sympa visuellement et bien documenté.</p>
<p>References / Aide:</p>
<ul>
<li><a href="https://learnopengl.com/Advanced-Lighting/SSAO">https://learnopengl.com/Advanced-Lighting/SSAO</a></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="bloom-1-pt"></a><a href="#bloom-1-pt" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Bloom (1 pt)</h3>
<p>Post process sympa mais un peu cheap permettant un halo autour des objets emissifs. L'idée est de rendre une passe d'emission et de la blurrer.</p>
<p>References / Aide:</p>
<ul>
<li><a href="https://learnopengl.com/Advanced-Lighting/Bloom">https://learnopengl.com/Advanced-Lighting/Bloom</a></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="rendu-de-la-transparence-3-pt"></a><a href="#rendu-de-la-transparence-3-pt" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rendu de la transparence (3 pt)</h3>
<p>Le format glTF permet de definir une opacité sur le materiaux des objets. L'idée est de rendre la transparence des objets. Pour ça il faudra passer par une passe de rendu forward qui ne rend que les objets transparent par dessus le rendu final du deferred (il faudra partager le depth buffer entre le deferred et le forward). Il faudra également trier les objets transparent selon leur profondeur par rapport à la camera.</p>
<p>Si on ne fait pas le rendu des objets transparent avec la technique deferred rendering, c'est parce que le GBuffer ne contient que les données d'un point par pixel. Or la transparence conduit à traiter plusieurs points par pixel, ce qui est possible en forward.</p>
<p>References / Aide:</p>
<ul>
<li><a href="https://learnopengl.com/Advanced-OpenGL/Blending">https://learnopengl.com/Advanced-OpenGL/Blending</a></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="shadow-mapping-depuis-les-points-light-3-pt"></a><a href="#shadow-mapping-depuis-les-points-light-3-pt" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Shadow mapping depuis les points light (3 pt)</h3>
<p>En TD nous avons vu le shadow mapping sur une directional light. Il est également possible de faire cette technique avec une point light. Pour cela il faut rendre la scene 6 fois sur chaque face d'une cube map entourant la point light. Ce n'est pas si compliqué que ça, mais assez facile de foutre le bordel dans les etats OpenGL.</p>
<p>References / Aide:</p>
<ul>
<li><a href="https://learnopengl.com/Advanced-Lighting/Shadows/Point-Shadows">https://learnopengl.com/Advanced-Lighting/Shadows/Point-Shadows</a></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="frustum-culling-1-ou-3-pts"></a><a href="#frustum-culling-1-ou-3-pts" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Frustum culling (1 ou 3 pts)</h3>
<p>Le frustum culling permet d'eviter d'essayer de dessiner des objets situé en dehors du champs de vue de la caméra. Il est possible de faire ce culling sur CPU avant de faire les appels de dessin, ou sur GPU et dans ce cas utiliser l'indirect rendering pour gérer les commandes de dessin sur GPU en faisant le culling (cette generation doit se faire dans un compute shader).</p>
<ul>
<li>Frustum culling sur CPU: 1pt</li>
<li>Frustum culling sur GPU: 2pts supplémentaires</li>
</ul>
<p>References / Aide:</p>
<ul>
<li><a href="http://www.lighthouse3d.com/tutorials/view-frustum-culling/">http://www.lighthouse3d.com/tutorials/view-frustum-culling/</a></li>
<li><a href="https://www.khronos.org/opengl/wiki/Vertex_Rendering#Indirect_rendering">https://www.khronos.org/opengl/wiki/Vertex_Rendering#Indirect_rendering</a></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="autres-techniques-en-vrac"></a><a href="#autres-techniques-en-vrac" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Autres techniques en vrac</h3>
<p>Les techniques suivantes sont issues de la recherche et il est plus difficile de trouver de la documentation sur leur implementation (la plupart du temps il n'y a que l'article scientifique associé). Chacune rapportera 5 points.</p>
<ul>
<li>Reflective Shadow Maps (a faire après &quot;Shadow mapping depuis les points light&quot; car plus compliqué): Permet le rendu de l'éclairage indirect après un rebond depuis la lumière
<ul>
<li><a href="http://www.klayge.org/material/3_12/GI/rsm.pdf">http://www.klayge.org/material/3_12/GI/rsm.pdf</a></li>
</ul></li>
<li>Rendu d'area lights: plus physiques, les area lights en temps réel permettent un rendu beaucoup plus réaliste
<ul>
<li><a href="https://eheitzresearch.wordpress.com/415-2/">https://eheitzresearch.wordpress.com/415-2/</a></li>
<li><a href="https://blog.selfshadow.com/publications/s2016-advances/">https://blog.selfshadow.com/publications/s2016-advances/</a></li>
</ul></li>
<li>Clustered Shading: Permet de rendre en temps réel beaucoup de lumières
<ul>
<li><a href="http://www.cse.chalmers.se/~uffe/clustered_shading_preprint.pdf">http://www.cse.chalmers.se/~uffe/clustered_shading_preprint.pdf</a></li>
<li><a href="http://www.humus.name/Articles/PracticalClusteredShading.pdf">http://www.humus.name/Articles/PracticalClusteredShading.pdf</a></li>
<li><a href="http://efficientshading.com/2014/01/01/efficient-real-time-shading-with-many-lights/">http://efficientshading.com/2014/01/01/efficient-real-time-shading-with-many-lights/</a></li>
<li><a href="http://efficientshading.com/2013/08/01/practical-clustered-deferred-and-forward-shading/">http://efficientshading.com/2013/08/01/practical-clustered-deferred-and-forward-shading/</a></li>
</ul></li>
</ul>
<p>Si vous avez d'autres idées, mettez les en commentaire. Si je trouve ça assez challenge je les ajouterais à la liste avec une quantité de points associée.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/openglnoel/docs/gold-01-intro-sdk-03-fiche-info"><span class="arrow-prev">← </span><span>Fiche d&#x27;information</span></a><a class="docs-next button" href="/openglnoel/docs/gold-02-forward-renderer-01-pipeline"><span>Pipeline de Rendu</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#contraintes">Contraintes</a></li><li><a href="#fonctionalites-de-base">Fonctionalités de base</a></li><li><a href="#le-format-gltf">Le format glTF</a></li><li><a href="#exemples-de-techniques-avancees-pour-gratter-des-points">Exemples de techniques avancées pour gratter des points</a><ul class="toc-headings"><li><a href="#gestion-des-animations-2-pts">Gestion des animations (2 pts)</a></li><li><a href="#modele-de-shading-pbr-2-pts">Modèle de shading PBR (2 pts)</a></li><li><a href="#lighting-avance-depuis-une-environment-light-3-pts-a-faire-apres-le-modele-de-shading-pbr">Lighting avancé depuis une environment light (3 pts, a faire après le modèle de shading PBR)</a></li><li><a href="#chargement-et-rendu-de-lumieres-ponctuelle-en-respectant-l-extension-gltf-khr-lights-punctual-1-pt">Chargement et rendu de lumières ponctuelle en respectant l'extension glTF KHR_lights_punctual (1 pt)</a></li><li><a href="#normal-mapping-1-pt">Normal mapping (1 pt)</a></li><li><a href="#screen-space-ambiant-occlusion-2-pt">Screen space ambiant occlusion (2 pt)</a></li><li><a href="#bloom-1-pt">Bloom (1 pt)</a></li><li><a href="#rendu-de-la-transparence-3-pt">Rendu de la transparence (3 pt)</a></li><li><a href="#shadow-mapping-depuis-les-points-light-3-pt">Shadow mapping depuis les points light (3 pt)</a></li><li><a href="#frustum-culling-1-ou-3-pts">Frustum culling (1 ou 3 pts)</a></li><li><a href="#autres-techniques-en-vrac">Autres techniques en vrac</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/openglnoel/" class="nav-home"><img src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]" width="66" height="58"/></a><div><h5>About Me</h5><a href="http://laurentnoel.fr">Personal website</a><a href="https://github.com/Celeborn2BeAlive/">Github</a></div><div><h5>About This Website</h5><a href="/openglnoel/blog">Blog</a><a class="github-button" href="https://github.com/celeborn2bealive/openglnoel" data-icon="octicon-star" data-count-href="/celeborn2bealive/openglnoel/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">openglnoel</a><a href="https://docusaurus.io/">Powered by Docusaurus</a></div><div><h5>About OpenGL</h5><a href="docs.gl">Documentation (docs.gl)</a><a href="https://www.khronos.org/opengl/wiki/">Wiki</a></div></section><section class="copyright">Copyright © 2019 Laurent NOEL</section></footer></div></body></html>