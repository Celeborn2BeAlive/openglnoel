<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Utiliser les buffers d&#x27;index · OpenGL[&quot;noël&quot;]</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Les deux exercices précédent vous ont permis d&#x27;aborder le dessin de formes arbitraires via le découpage en triangle. Il s&#x27;avère que les triangles possèdent des sommets en commun. Or, en l&#x27;état actuel des choses, vous devez dupliquer ces sommets dans le VBO pour pouvoir dessiner tous les triangles. Cette duplication entraine une perte d&#x27;espace mémoire qui peut s&#x27;avérer importante lors de l&#x27;affichage de grandes scenes."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Utiliser les buffers d&#x27;index · OpenGL[&quot;noël&quot;]"/><meta property="og:type" content="website"/><meta property="og:url" content="https://celeborn2bealive.github.io/openglnoel/"/><meta property="og:description" content="Les deux exercices précédent vous ont permis d&#x27;aborder le dessin de formes arbitraires via le découpage en triangle. Il s&#x27;avère que les triangles possèdent des sommets en commun. Or, en l&#x27;état actuel des choses, vous devez dupliquer ces sommets dans le VBO pour pouvoir dessiner tous les triangles. Cette duplication entraine une perte d&#x27;espace mémoire qui peut s&#x27;avérer importante lors de l&#x27;affichage de grandes scenes."/><meta property="og:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://celeborn2bealive.github.io/openglnoel/img/logo.png"/><link rel="shortcut icon" href="/openglnoel/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/atom.xml" title="OpenGL[&quot;noël&quot;] Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://celeborn2bealive.github.io/openglnoel/blog/feed.xml" title="OpenGL[&quot;noël&quot;] Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/openglnoel/js/code-block-buttons.js"></script><script type="text/javascript" src="/openglnoel/js/disqus.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/openglnoel/js/scrollSpy.js"></script><link rel="stylesheet" href="/openglnoel/css/main.css"/><script src="/openglnoel/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/openglnoel/"><img class="logo" src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]"/><h2 class="headerTitleWithLogo">OpenGL[&quot;noël&quot;]</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/openglnoel/docs/gltf-viewer-01-intro-01-intro" target="_self">glTF Viewer Tutorial</a></li><li class=""><a href="/openglnoel/docs/intro-sdk-01-philogl-01-introduction" target="_self">Intro et SDK</a></li><li class="siteNavGroupActive"><a href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base" target="_self">Bronze</a></li><li class=""><a href="/openglnoel/docs/silver-01-3d-theorie-01-introduction" target="_self">Silver</a></li><li class=""><a href="/openglnoel/docs/gold-01-intro-sdk-01-introduction" target="_self">Gold</a></li><li class=""><a href="/openglnoel/blog/" target="_self">Blog</a></li><li class=""><a href="http://docs.gl" target="_self">OpenGL Documentation</a></li><li class=""><a href="https://www.khronos.org/opengl/wiki/" target="_self">OpenGL Wiki</a></li><li class=""><a href="https://github.com/celeborn2bealive/openglnoel" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Hello Triangle</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Hello Triangle</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-02-hello-triangle-01-code-de-base">Le code de base</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-02-hello-triangle-02-triangle-blanc">Dessiner un triangle blanc</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-02-hello-triangle-03-triangle-couleurs">Dessiner un triangle en couleurs</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-02-hello-triangle-04-vertex-structure">Utiliser une structure de vertex</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-02-hello-triangle-05-dessiner-quad">Dessiner un quad</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-02-hello-triangle-06-dessiner-disque">Dessiner un disque</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/openglnoel/docs/bronze-02-hello-triangle-07-index-buffers">Utiliser les buffers d&#x27;index</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Les shaders</h3><ul class=""><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-01-kesako">Shaders, kesako ?</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-02-exemple">Les shaders par l&#x27;exemple</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-03-compilation">Charger, compiler et utiliser</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-04-jouer">Jouer avec les shaders</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-05-mandelbrot">Mandelbrot</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-06-la-suite">Préparer la suite</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-07-triangle-tourne">Un triangle qui tourne</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-08-matrices">Envoyer des matrices</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-09-plusieurs-triangles">Plusieur triangles</a></li><li class="navListItem"><a class="navItem" href="/openglnoel/docs/bronze-03-shaders-10-textures">Textures</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Utiliser les buffers d&#x27;index</h1></header><article><div><span><p>Les deux exercices précédent vous ont permis d'aborder le dessin de formes arbitraires via le découpage en triangle. Il s'avère que les triangles possèdent des sommets en commun. Or, en l'état actuel des choses, vous devez dupliquer ces sommets dans le VBO pour pouvoir dessiner tous les triangles. Cette duplication entraine une perte d'espace mémoire qui peut s'avérer importante lors de l'affichage de grandes scenes.</p>
<p>Les buffers d'index, ou <strong>Index Buffer Objects (IBO)</strong>, permettent d'introduire un niveau d'indirection lors du dessin des triangles. En utilisant un IBO, on décrit les triangles par l'index de chacun de ses 3 sommets au lieu de donner les sommets directement. Cela permet d'avoir un seul exemplaire de chaque sommet dans le VBO mais plusieurs occurence de l'index des sommets dupliqués dans l'IBO. On remplace ainsi la duplication des sommets par une duplication de nombre entiers, ce qui consomme nettement moins d'espace mémoire.</p>
<p>Un IBO se créé avec les même fonctions que pour les VBOs (glGenBuffers, glBufferData, glBindBuffer, etc.). La différence est la cible de binding: on utilise <strong>GL_ELEMENT_ARRAY_BUFFER</strong> a la place de <strong>GL_ARRAY_BUFFER</strong>.</p>
<p>De plus l'IBO doit être enregistré dans le VAO, simplement en le bindant (sur <strong>GL_ELEMENT_ARRAY_BUFFER</strong> donc) après avoir bindé le VAO. Enfin, le dessin se fait avec la fonction <strong>glDrawElements</strong> à la place de <strong>glDrawArrays</strong>.</p>
<p>Plutot que de détailler chaque étape, voici le code source pour afficher le Quad en utilisant un IBO (lire les commentaires préfixés par &quot;=&gt;&quot;&quot; pour voir les changements par rapport au code de l'exercice du quad):</p>
<pre><code class="hljs css language-cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>{
    <span class="hljs-comment">// Initialize SDL and open a window</span>
    <span class="hljs-function">SDLWindowManager <span class="hljs-title">windowManager</span><span class="hljs-params">(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>, <span class="hljs-string">"GLImac"</span>)</span></span>;

    <span class="hljs-comment">// Initialize glew for OpenGL3+ support</span>
    GLenum glewInitError = glewInit();
    <span class="hljs-keyword">if</span>(GLEW_OK != glewInitError) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; glewGetErrorString(glewInitError) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> EXIT_FAILURE;
    }

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"OpenGL Version : "</span> &lt;&lt; glGetString(GL_VERSION) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"GLEW Version : "</span> &lt;&lt; glewGetString(GLEW_VERSION) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;

    <span class="hljs-function">FilePath <span class="hljs-title">applicationPath</span><span class="hljs-params">(argv[<span class="hljs-number">0</span>])</span></span>;
    Program program = loadProgram(applicationPath.dirPath() + <span class="hljs-string">"shaders/triangle.vs.glsl"</span>,
                                  applicationPath.dirPath() + <span class="hljs-string">"shaders/triangle.fs.glsl"</span>);
    program.use();

    GLuint vbo;
    glGenBuffers(<span class="hljs-number">1</span>, &amp;vbo);

    glBindBuffer(GL_ARRAY_BUFFER, vbo);

    <span class="hljs-comment">// =&gt; Tableau de sommets : un seul exemplaire de chaque sommet</span>
    Vertex2DColor vertices[] = {
        Vertex2DColor(glm::vec2(<span class="hljs-number">-0.5</span>, <span class="hljs-number">-0.5</span>), glm::vec3(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)), <span class="hljs-comment">// Sommet 0</span>
        Vertex2DColor(glm::vec2(<span class="hljs-number">0.5</span>, <span class="hljs-number">-0.5</span>), glm::vec3(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)), <span class="hljs-comment">// Sommet 1</span>
        Vertex2DColor(glm::vec2(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>), glm::vec3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)), <span class="hljs-comment">// Sommet 2</span>
        Vertex2DColor(glm::vec2(<span class="hljs-number">-0.5</span>, <span class="hljs-number">0.5</span>), glm::vec3(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)) <span class="hljs-comment">// Sommet 3</span>
    };
    <span class="hljs-comment">// =&gt; Penser à bien changer le nombre de sommet (4 au lieu de 6):</span>
    glBufferData(GL_ARRAY_BUFFER, <span class="hljs-number">4</span> * <span class="hljs-keyword">sizeof</span>(Vertex2DColor), vertices, GL_STATIC_DRAW);

    glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);

    <span class="hljs-comment">// =&gt; Creation du IBO</span>
    GLuint ibo;
    glGenBuffers(<span class="hljs-number">1</span>, &amp;ibo);

    <span class="hljs-comment">// =&gt; On bind sur GL_ELEMENT_ARRAY_BUFFER, cible reservée pour les IBOs</span>
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);

    <span class="hljs-comment">// =&gt; Tableau d'indices: ce sont les indices des sommets à dessiner</span>
    <span class="hljs-comment">// On en a 6 afin de former deux triangles</span>
    <span class="hljs-comment">// Chaque indice correspond au sommet correspondant dans le VBO</span>
    <span class="hljs-keyword">uint32_t</span> indices[] = {
        <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>
    };

    <span class="hljs-comment">// =&gt; On remplit l'IBO avec les indices:</span>
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-number">6</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>), indices, GL_STATIC_DRAW);

    <span class="hljs-comment">// =&gt; Comme d'habitude on debind avant de passer à autre chose</span>
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-number">0</span>);

    GLuint vao;
    glGenVertexArrays(<span class="hljs-number">1</span>, &amp;vao);

    glBindVertexArray(vao);

    <span class="hljs-comment">// =&gt; On bind l'IBO sur GL_ELEMENT_ARRAY_BUFFER; puisqu'un VAO est actuellement bindé,</span>
    <span class="hljs-comment">// cela a pour effet d'enregistrer l'IBO dans le VAO</span>
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);

    <span class="hljs-keyword">const</span> GLuint VERTEX_ATTR_POSITION = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">const</span> GLuint VERTEX_ATTR_COLOR = <span class="hljs-number">8</span>;
    glEnableVertexAttribArray(VERTEX_ATTR_POSITION);
    glEnableVertexAttribArray(VERTEX_ATTR_COLOR);
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glVertexAttribPointer(VERTEX_ATTR_POSITION, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, 
        <span class="hljs-keyword">sizeof</span>(Vertex2DColor), (<span class="hljs-keyword">const</span> GLvoid*) offsetof(Vertex2DColor, position));
    glVertexAttribPointer(VERTEX_ATTR_COLOR, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, 
        <span class="hljs-keyword">sizeof</span>(Vertex2DColor), (<span class="hljs-keyword">const</span> GLvoid*) offsetof(Vertex2DColor, color));
    glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);

    glBindVertexArray(<span class="hljs-number">0</span>);

    <span class="hljs-comment">// Application loop:</span>
    <span class="hljs-keyword">bool</span> done = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">while</span>(!done) {
        <span class="hljs-comment">// Event loop:</span>
        SDL_Event e;
        <span class="hljs-keyword">while</span>(windowManager.pollEvent(e)) {
            <span class="hljs-keyword">if</span>(e.type == SDL_QUIT) {
                done = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Leave the loop after this iteration</span>
            }
        }

        glClear(GL_COLOR_BUFFER_BIT);

        glBindVertexArray(vao);

        <span class="hljs-comment">// =&gt; On utilise glDrawElements à la place de glDrawArrays</span>
        <span class="hljs-comment">// Cela indique à OpenGL qu'il doit utiliser l'IBO enregistré dans le VAO</span>
        glDrawElements(GL_TRIANGLES, <span class="hljs-number">6</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);

        glBindVertexArray(<span class="hljs-number">0</span>);

        <span class="hljs-comment">// Update the display</span>
        windowManager.swapBuffers();
    }

    glDeleteBuffers(<span class="hljs-number">1</span>, &amp;vbo);
    glDeleteVertexArrays(<span class="hljs-number">1</span>, &amp;vao);

    <span class="hljs-keyword">return</span> EXIT_SUCCESS;
}
</code></pre>
<p><a href="/openglnoel/docs/assets/exo6_quad_IBO.cpp">Voici également un lien</a> vers le fichier source correspondant, que vous pouvez tester en le plaçant dans le repertoire source du TP1.</p>
<p><span class="badge todo"></span> En vous inspirant du code précédent, réécrivez le code de dessin du disque en utilisant un IBO afin d'éviter la duplication de sommets. Votre tableau de sommet doit alors contenir 1 + N sommets (1 pour le centre, N le nombre de triangles). Le tableau d'indices doit lui contenir 3 * N indices (de manière générale le tableau d'indices contient toujours le nombre de triangles multiplié par 3).</p>
<p>Voici le prototype de la fonction glDrawElements:</p>
<pre><code class="hljs css language-cpp">glDrawElements(
    GLenum mode,
    GLsizei count,
    GLenum type,
    <span class="hljs-keyword">const</span> GLvoid * indices)
</code></pre>
<p>Paramètres:</p>
<ul>
<li>GLenum mode: le type de primitives à dessiner (GL_TRIANGLES)</li>
<li>GLsizei count: le nombre d'indice à dessiner (nombre de triangles * 3)</li>
<li>GLenum type: une constante OpenGL correspondant au type des incides (GL_UNSIGNED_INT). Lorsqu'on utilise peu d'indices, il peut être plus efficace d'utiliser des - indices de type unsigned short ou unsigned char afin de consommer encore moins de mémoire.</li>
<li>const GLvoid * indices: encore un pointeur &quot;piège&quot;. C'est en fait l'offset dans le tableau d'indices à partir duquel commencer. On passe 0 car on veut utiliser tous les indices.</li>
</ul>
<p><span class="badge doc"></span> <a href="http://docs.gl/gl3/glDrawElements">glDrawElements</a></p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/openglnoel/docs/bronze-02-hello-triangle-06-dessiner-disque"><span class="arrow-prev">← </span><span>Dessiner un disque</span></a><a class="docs-next button" href="/openglnoel/docs/bronze-03-shaders-01-kesako"><span>Shaders, kesako ?</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/openglnoel/" class="nav-home"><img src="/openglnoel/img/logo.png" alt="OpenGL[&quot;noël&quot;]" width="66" height="58"/></a><div><h5>About Me</h5><a href="http://laurentnoel.fr">Personal website</a><a href="https://github.com/Celeborn2BeAlive/">Github</a></div><div><h5>About This Website</h5><a href="/openglnoel/blog">Blog</a><a class="github-button" href="https://github.com/celeborn2bealive/openglnoel" data-icon="octicon-star" data-count-href="/celeborn2bealive/openglnoel/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">openglnoel</a><a href="https://docusaurus.io/">Powered by Docusaurus</a></div><div><h5>About OpenGL</h5><a href="docs.gl">Documentation (docs.gl)</a><a href="https://www.khronos.org/opengl/wiki/">Wiki</a></div></section><section class="copyright">Copyright © 2020 Laurent NOEL</section></footer></div></body></html>